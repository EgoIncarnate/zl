Index: gcc/zls/Make-lang.in
===================================================================
--- gcc/zls/Make-lang.in	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/Make-lang.in	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,163 @@
+# Top level -*- makefile -*- fragment for GNU ZL-Simple
+#   Copyright (C) 1997, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2007,
+#   2008 Free Software Foundation, Inc.
+
+#This file is part of GCC.
+
+#GCC is free software; you can redistribute it and/or modify
+#it under the terms of the GNU General Public License as published by
+#the Free Software Foundation; either version 3, or (at your option)
+#any later version.
+
+#GCC is distributed in the hope that it will be useful,
+#but WITHOUT ANY WARRANTY; without even the implied warranty of
+#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+
+# This file provides the language dependent support in the main Makefile.
+# Each language makefile fragment must provide the following targets:
+#
+# foo.all.cross, foo.start.encap, foo.rest.encap,
+# foo.install-common, foo.install-man, foo.install-info, foo.install-pdf,
+# foo.info, foo.dvi, foo.pdf, foo.html, foo.uninstall,
+# foo.mostlyclean, foo.clean, foo.distclean,
+# foo.maintainer-clean, foo.stage1, foo.stage2, foo.stage3, foo.stage4
+#
+# where `foo' is the name of the language.
+#
+# It should also provide rules for:
+#
+# - making any compiler driver (eg: g++)
+# - the compiler proper (eg: cc1plus)
+# - define the names for selecting the language in LANGUAGES.
+
+#
+# Define the names for selecting ZL-Simple in LANGUAGES.
+zls: zls0$(exeext)
+
+# Tell GNU make to ignore these if they exist.
+.PHONY: zls
+
+# Use maximal warnings for this front end.
+zls-warn = $(LOOSE_WARN)
+
+# The compiler itself.
+# Shared with C front end:
+# Language-specific object files for C and Objective C.
+#C_AND_ZLS_OBJS = attribs.o c-errors.o c-lex.o c-pragma.o c-decl.o c-typeck.o \
+#  c-convert.o c-aux-info.o c-common.o c-format.o c-semantics.o \
+#  c-ppoutput.o c-cppbuiltin.o \
+#  c-objc-common.o c-dump.o c-pch.o c-parser.o $(C_TARGET_OBJS) \
+#  c-gimplify.o tree-mudflap.o c-pretty-print.o c-omp.o
+C_AND_ZLS_OBJS = attribs.o c-errors.o c-decl.o c-typeck.o \
+  c-convert.o c-aux-info.o c-common.o c-format.o c-semantics.o \
+  c-cppbuiltin.o \
+  c-objc-common.o c-dump.o $(C_TARGET_OBJS) \
+  c-gimplify.o tree-mudflap.o c-pretty-print.o c-omp.o
+
+ZLS_C_OBJS = $(C_AND_ZLS_OBJS) stub-objc.o
+
+# Language-specific object files for ZL-Simple.
+ZLS_OBJS = zls/lang.o zls/opts.o zls/stubs.o zls/parser.o	
+
+zls_OBJS = $(ZLS_OBJS) zls0-checksum.o
+
+zls0-dummy$(exeext): $(ZLS_OBJS) $(ZLS_C_OBJS) dummy-checksum.o $(BACKEND) $(LIBDEPS)
+	$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ \
+	      $(ZLS_OBJS) $(ZLS_C_OBJS) dummy-checksum.o \
+	      $(BACKEND) $(LIBS) $(BACKENDLIBS)
+
+zls0-checksum.c : zls0-dummy$(exeext) build/genchecksum$(build_exeext)
+	build/genchecksum$(build_exeext) zls0-dummy$(exeext) > $@
+
+zls0-checksum.o : zls0-checksum.c
+
+zls0$(exeext): $(ZLS_OBJS) $(ZLS_C_OBJS) zls0-checksum.o $(BACKEND) $(LIBDEPS)
+	$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ \
+	      $(ZLS_OBJS) $(ZLS_C_OBJS) zls0-checksum.o \
+	      $(BACKEND) $(LIBS) $(BACKENDLIBS)
+
+# ZL-Simple language specific files.
+
+zls/lang.o : zls/lang.c
+
+zls/opts.o : zls/opts.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)		\
+        $(TREE_H) $(C_PRAGMA_H) $(FLAGS_H) $(TOPLEV_H) langhooks.h		\
+        $(TREE_INLINE_H) $(DIAGNOSTIC_H) intl.h debug.h $(C_COMMON_H)	\
+        opts.h options.h $(MKDEPS_H) incpath.h cppdefault.h $(TARGET_H) \
+	$(TM_P_H) $(VARRAY_H)
+	$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) \
+		$< $(OUTPUT_OPTION) ## @TARGET_SYSTEM_ROOT_DEFINE@
+
+zls/parser.o: zls/parser.c
+
+zls/stubs.o: zls/stubs.c
+
+
+zls.srcextra:
+
+#
+# Build hooks:
+
+zls.all.cross:
+zls.start.encap:
+zls.rest.encap:
+zls.info:
+zls.install-info:
+zls.dvi:
+zls.pdf:
+zls.install-pdf:
+zls.html:
+zls.man:
+zls.srcinfo:
+zls.srcman:
+
+zls.tags: force
+	cd $(srcdir)/zls; etags -o TAGS.sub *.c *.h; \
+	etags --include TAGS.sub --include ../TAGS.sub
+
+lang_checks += check-zls
+
+#
+# Install hooks:
+# zls0 is installed elsewhere as part of $(COMPILERS).
+
+zls.install-common:
+
+zls.install-man:
+
+zls.uninstall:
+#
+# Clean hooks:
+# A lot of the ancillary files are deleted by the main makefile.
+# We just have to delete files specific to us.
+zls.mostlyclean:
+	-rm -f zls/*$(objext) zls/xforward zls/fflags
+	-rm -f zls/*$(coverageexts)
+zls.clean: zls.mostlyclean
+	-rm -rf zls-headers
+zls.distclean:
+	-rm -f zls/Makefile zls/Make-host zls/Make-target
+	-rm -f zls/config.status zls/config.cache
+zls.maintainer-clean:
+
+#
+# Stage hooks:
+
+zls.stage1: stage1-start
+	-mv zls/*$(objext) stage1/zls
+zls.stage2: stage2-start
+	-mv zls/*$(objext) stage2/zls
+zls.stage3: stage3-start
+	-mv zls/*$(objext) stage3/zls
+zls.stage4: stage4-start
+	-mv zls/*$(objext) stage4/zls
+zls.stageprofile: stageprofile-start
+	-mv zls/*$(objext) stageprofile/zls
+zls.stagefeedback: stagefeedback-start
+	-mv zls/*$(objext) stagefeedback/zls
Index: gcc/zls/stubs.c
===================================================================
--- gcc/zls/stubs.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/stubs.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,55 @@
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tree.h"
+#include "c-common.h"
+#include "c-pragma.h"
+
+// used by c-opts.c
+
+void init_c_lex (void) {
+}
+
+void preprocess_file (cpp_reader * ARG_UNUSED(r)) {
+}
+
+void init_pp_output(FILE * f) {
+}
+
+void pp_file_change (const struct line_map * ARG_UNUSED(d)) {
+}
+
+void fe_file_change (const struct line_map * ARG_UNUSED(d)) {
+}
+
+void pp_dir_change (cpp_reader * ARG_UNUSED(r), const char * ARG_UNUSED(s)) {
+}
+
+void init_pragma (void) {
+}
+
+void pch_init (void) {
+}
+
+void c_common_print_pch_checksum (FILE * ARG_UNUSED(f)) {
+}
+
+// used by c-decl.c
+
+void c_common_write_pch (void) {
+}
+
+void maybe_apply_pragma_weak (tree ARG_UNUSED(t)) {
+}
+
+void maybe_apply_pending_pragma_weaks (void) {
+}
+
+tree maybe_apply_renaming_pragma (tree ARG_UNUSED(t), tree asmname) {
+  return asmname;
+}
+
+// used by c-lex.c but GC also thinks its used to to GTY tag in c-common.h
+
+int pending_lang_change;
Index: gcc/zls/lang-specs.h
===================================================================
--- gcc/zls/lang-specs.h	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/lang-specs.h	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,26 @@
+/* Definitions for specs for Objective-C.
+   Copyright (C) 1998, 1999, 2002, 2002, 2003, 2005, 2007
+   Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+
+/* This is the contribution to the `default_compilers' array in gcc.c */
+
+  {".zls", "@zls", 0, 1, 0},
+  {"@zls",
+   "%{!M:%{!MM:%{!E:zls0 -fpreprocessed %i %(cc1_options) %{!fsyntax-only:%(invoke_as)}}}}", 0, 1, 0},
Index: gcc/zls/lang.c
===================================================================
--- gcc/zls/lang.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/lang.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,62 @@
+/* Language-specific hook definitions for C front end.
+   Copyright (C) 1991, 1995, 1997, 1998,
+   1999, 2000, 2001, 2003, 2004, 2005, 2007, 2008
+   Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 3, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "tree.h"
+#include "c-tree.h"
+#include "c-common.h"
+#include "ggc.h"
+#include "langhooks.h"
+#include "langhooks-def.h"
+#include "tree-inline.h"
+#include "diagnostic.h"
+#include "c-objc-common.h"
+#include "debug.h"		/* For debug_hooks.  */
+
+enum c_language_kind c_language = clk_c;
+
+/* Lang hooks common to C and ObjC are declared in c-objc-common.h;
+   consequently, there should be very few hooks below.  */
+
+#undef LANG_HOOKS_NAME
+#define LANG_HOOKS_NAME "ZL-Simple"
+#undef LANG_HOOKS_INIT
+#define LANG_HOOKS_INIT c_objc_common_init
+#undef LANG_HOOKS_PARSE_FILE
+#define LANG_HOOKS_PARSE_FILE c_common_parse_file
+
+/* Each front end provides its own lang hook initializer.  */
+const struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;
+
+/* Input filename.  */
+static const char *this_input_filename;
+
+/* Final processing of file-scope data.  The Objective-C version of
+   this function still does something.  */
+void finish_file (void)
+{
+}
+
+#include "gtype-zls.h"
Index: gcc/zls/tests/test3.out.zls
===================================================================
--- gcc/zls/tests/test3.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test3.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,71 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun foo (.) (void))
+(fun foo2 (.) (void))
+(fun main (.) (int))
+# definitions
+(fun main (.) (int) (block
+  (var x$1 (int) 0)
+  (block
+    (local_label break$1)
+    (local_label continue$1)
+  (label continue$1)
+    (if (not (eif (ne x$1 20) (eif (ne x$1 30) 1 (ne x$1 40)) 0))
+      (goto break$1)
+    )
+    (c-assign plus x$1 1)
+    (goto continue$1)
+  (label break$1)
+  )
+  (block
+    (local_label break$1)
+    (local_label continue$1)
+    (var i$1 (int) 9)
+    (var j$1 (int) 11)
+  (label loop$$1)
+    (if (not 1)
+      (goto break$1)
+    )
+    (block
+      (assign x$1 (plus i$1 x$1))
+    )
+  (label continue$1)
+    (noop)
+    (goto loop$$1)
+  (label break$1)
+  )
+  (c-assign bor x$1 3)
+)
+)
+# special
+# done
Index: gcc/zls/tests/test4.out.zls
===================================================================
--- gcc/zls/tests/test4.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test4.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,47 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+(.struct X)
+(talias X (struct X))
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+(.struct X
+  ((int) x)
+  ((int) y)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (.) (int))
+# definitions
+(var x1 (struct X))
+(fun main (.) (int) (block
+  (var i$1 (int) (member x1 x))
+)
+)
+# special
+# done
Index: gcc/zls/tests/test28.out.c
===================================================================
--- gcc/zls/tests/test28.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test28.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,47 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main();
+/* definitions */
+int x = 10;
+int y = 30;
+int y$$1;
+int main()
+{
+  int x$1 = 20;
+  (x$1 = (x + y$$1));
+}
+/* special */
+__attribute__((constructor)) static void init$s() {
+  (y$$1 = x);
+}
+/* done */
Index: gcc/zls/tests/test5.out.zls
===================================================================
--- gcc/zls/tests/test5.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test5.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,56 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (.) (int))
+# definitions
+(fun main (.) (int) (block
+  (local_label bla$1)
+  (var x$1 (int) 20)
+(label bla$1)
+  (block
+    (local_label break$1)
+    (.switch x$1
+      (block
+      (case 1)
+        (assign x$1 10)
+        (goto break$1)
+      (case)
+        (goto break$1)
+      )
+    )
+  (label break$1)
+  )
+  (goto bla$1)
+)
+)
+# special
+# done
Index: gcc/zls/tests/test47.out.c
===================================================================
--- gcc/zls/tests/test47.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test47.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,88 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+struct _Data$$1;
+struct _Data$$2;
+struct _Data$$3;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+struct _Data$$1 {
+  int x;
+  int y;
+};
+struct _Data$$2 {
+  struct _Data$$1 parent;
+  int z;
+};
+struct _Data$$3 {
+  struct _Data$$2 parent;
+  int z2;
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+void foo_p(struct _Data$$1 * p);
+void foo_c(struct _Data$$2 * p);
+void foo_s(struct _Data$$3 * p);
+int main();
+/* definitions */
+void foo_p(struct _Data$$1 * p)
+{
+  ;
+}
+void foo_c(struct _Data$$2 * p)
+{
+  ;
+}
+void foo_s(struct _Data$$3 * p)
+{
+  ;
+}
+int main()
+{
+  struct _Data$$1 p$1;
+  foo_p((&p$1));
+  struct _Data$$2 c$1;
+  foo_c((&c$1));
+  foo_p((&c$1.parent));
+  struct _Data$$3 s$1;
+  foo_s((&s$1));
+  foo_c((&s$1.parent));
+  foo_p((&s$1.parent.parent));
+  p$1.x;
+  p$1.y;
+  c$1.z;
+  (*((struct _Data$$1 *)(&c$1))).x;
+  (*((struct _Data$$1 *)(&c$1))).y;
+  s$1.z2;
+  (*((struct _Data$$2 *)(&s$1))).z;
+  (*((struct _Data$$1 *)(&s$1))).x;
+  (*((struct _Data$$1 *)(&s$1))).y;
+  return 0;
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test66.out.c
===================================================================
--- gcc/zls/tests/test66.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test66.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,53 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+struct X;
+struct _Data$$1;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+struct X {
+  int x;
+  int y;
+  char a[10];
+};
+struct _Data$$1 {
+  int x;
+  int y;
+  char a[10];
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main();
+/* definitions */
+int main()
+{
+  char const * str$1 = "4 8 0  4 8 0";
+  printf("%s\n", str$1);
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test6.out.zls
===================================================================
--- gcc/zls/tests/test6.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test6.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,43 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (.) (int))
+# definitions
+(fun main (.) (int) (block
+  (var X$1 (int))
+  (postinc X$1)
+  (c-assign plus X$1 1)
+  (c-assign minus X$1 1)
+)
+)
+# special
+# done
Index: gcc/zls/tests/test7.out.zls
===================================================================
--- gcc/zls/tests/test7.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test7.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,70 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (.) (int))
+# definitions
+(fun main (.) (int) (block
+  (var x$1 (int) 0)
+  (var z$1 (int))
+  (var z$2 (int) 0)
+  (assign z$2 20)
+  (var y$1 (int) z$2)
+  (c-assign plus y$1 1)
+  (assign y$1 (plus (c-assign times y$1 2) 4))
+  (block
+    (local_label break$1)
+    (local_label continue$1)
+    (noop)
+  (label loop$$1)
+    (if (not 1)
+      (goto break$1)
+    )
+    (plus x$1 1)
+  (label continue$1)
+    (noop)
+    (goto loop$$1)
+  (label break$1)
+  )
+  (if x$1
+    (block
+      (c-assign times x$1 20)
+      (c-assign times y$1 30)
+    )
+    (c-assign times y$1 2)
+  )
+  (assign z$1 (plus 5 5))
+  (assign z$1 (times (plus 2 3) (plus 2 3)))
+  (plus (times y$1 y$1) (times y$1 y$1))
+)
+)
+# special
+# done
Index: gcc/zls/tests/test9.out.zls
===================================================================
--- gcc/zls/tests/test9.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test9.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,46 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (.) (int))
+# definitions
+(fun main (.) (int) (block
+  (var x$1 (int))
+  (var y$1 (int))
+  (postinc x$1)
+  (c-assign plus x$1 1)
+  (postinc y$1)
+  (c-assign plus y$1 1)
+  (assign x$1 (assign y$1 5))
+)
+)
+# special
+# done
Index: gcc/zls/tests/test4.out.c
===================================================================
--- gcc/zls/tests/test4.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test4.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,47 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+struct X;
+typedef struct X X;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+struct X {
+  int x;
+  int y;
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main();
+/* definitions */
+struct X x1;
+int main()
+{
+  int i$1 = x1.x;
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test70.out.zls
===================================================================
--- gcc/zls/tests/test70.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test70.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,41 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+(.struct _data$$1)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (.) (int))
+# definitions
+(fun main (.) (int) (block
+  (call printf (. (s "%d\n") 12))
+)
+)
+# special
+# done
Index: gcc/zls/tests/test71.out.zls
===================================================================
--- gcc/zls/tests/test71.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test71.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,44 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (.) (int))
+# definitions
+(fun main (.) (int) (block
+  (var x$1 (float) (cast (float) (eblock    (var t$1 (double) (f 0x0p+0 (double)))
+    (eif (cast (int) t$1) t$1 (f 0x1.b333333333333p+2 (double)))
+  )))
+  (var y$1 (float) (f 0x1.8p+2 (float)))
+  (call printf (. (s "%f %f\n") x$1 y$1))
+)
+)
+# special
+# done
Index: gcc/zls/tests/test72.out.zls
===================================================================
--- gcc/zls/tests/test72.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test72.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,55 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun f (.) (void))
+(fun g (.) (void))
+(fun main (.) (int))
+# definitions
+(fun f (.) (void) (block
+  (var x$1 (float) (cast (float) (eblock    (var t$1 (double) (f 0x0p+0 (double)))
+    (eif (cast (int) t$1) t$1 (f 0x1.b333333333333p+2 (double)))
+  )))
+  (call printf (. (s "%f\n") x$1))
+)
+)
+(fun g (.) (void) (block
+  (var x$1 (float) (f 0x1.8p+2 (float)))
+  (call printf (. (s "%f\n") x$1))
+)
+)
+(fun main (.) (int) (block
+  (call f (.))
+  (call g (.))
+)
+)
+# special
+# done
Index: gcc/zls/tests/test73.out.zls
===================================================================
--- gcc/zls/tests/test73.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test73.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,41 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (.) (int))
+# definitions
+(fun main (.) (int) (block
+  (var x$1 (int) 1)
+  (return (plus x$1 2))
+)
+)
+# special
+# done
Index: gcc/zls/tests/test74.out.zls
===================================================================
--- gcc/zls/tests/test74.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test74.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,69 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun fabs (. ((double) x)) (double))
+(fun main (.) (int))
+# definitions
+(var r (double) (f 0x1.9e3779beddcbdp+0 (double)))
+(fun main (.) (int) (block
+  (var q$1 (double) (f 0x1.8p+1 (double)))
+  (var r$1 (double) (f 0x1p+1 (double)))
+  (block
+    (local_label break$1)
+    (local_label continue$1)
+    (noop)
+  (label loop$$1)
+    (if (not 1)
+      (goto break$1)
+    )
+    (block
+      (var a$1 (double) q$1)
+      (var b$1 (double) r$1)
+      (var a$2 (double) (div (minus a$1 (times r b$1)) (plus (cast (double) 1) r)))
+      (if (gt (call fabs (. (div a$2 (plus a$1 b$1)))) (f 0x1.47ae147ae147bp-7 (double)))
+        (block
+          (c-assign minus q$1 a$2)
+          (c-assign plus r$1 a$2)
+        )
+        (goto break$1)
+      )
+    )
+  (label continue$1)
+    (noop)
+    (goto loop$$1)
+  (label break$1)
+  )
+  (call printf (. (s "%f %f\n") q$1 r$1))
+)
+)
+# special
+# done
Index: gcc/zls/tests/test75.out.zls
===================================================================
--- gcc/zls/tests/test75.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test75.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,86 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+(.struct _Data$$1)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+(.struct _Data$$1
+  ((.ptr (int)) data)
+  ((size_t) sz)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun begin$$1 (. ((.ptr (struct _Data$$1)) this$1)) (.ptr (int)))
+(fun end$$1 (. ((.ptr (struct _Data$$1)) this$1)) (.ptr (int)))
+(fun main (.) (int))
+# definitions
+(fun begin$$1 (. ((.ptr (struct _Data$$1)) this$1)) (.ptr (int)) (block
+  (return (member (deref this$1) data))
+)
+)
+(fun end$$1 (. ((.ptr (struct _Data$$1)) this$1)) (.ptr (int)) (block
+  (return (plus (member (deref this$1) data) (member (deref this$1) sz)))
+)
+)
+(fun main (.) (int) (block
+  (var x$1 (struct _Data$$1))
+  (var d$1 (.array (int) 4) (.
+    1
+    5
+    3
+    2
+  ))
+  (assign (member x$1 data) d$1)
+  (assign (member x$1 sz) (cast (size_t) 4))
+  (var what$1 (.ptr (struct _Data$$1)) (addrof x$1))
+  (var i$1 (.ptr (int)) (call begin$$1 (. (addrof (deref what$1)))))
+  (var e$1 (.ptr (int)) (call end$$1 (. (addrof (deref what$1)))))
+  (block
+    (local_label break$1)
+    (local_label continue$1)
+    (noop)
+  (label loop$$1)
+    (if (not (ne i$1 e$1))
+      (goto break$1)
+    )
+    (block
+      (var el$1 (.ptr (int)) (addrof (deref i$1)))
+      (block
+        (call printf (. (s "%d\n") (deref el$1)))
+      )
+    )
+  (label continue$1)
+    (eblock      (c-assign plus i$1 1)
+    )
+    (goto loop$$1)
+  (label break$1)
+  )
+)
+)
+# special
+# done
Index: gcc/zls/tests/test77.out.zls
===================================================================
--- gcc/zls/tests/test77.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test77.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,46 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+(.struct _Data$$1)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+(.struct _Data$$1
+  ((int) x)
+  ((int) y)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (.) (int))
+# definitions
+(fun main (.) (int) (block
+  (var c$1 (struct _Data$$1))
+  (assign (member c$1 x) 20)
+)
+)
+# special
+# done
Index: gcc/zls/tests/test14.out.c
===================================================================
--- gcc/zls/tests/test14.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test14.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,41 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main();
+/* definitions */
+int main()
+{
+  int x$1[20];
+  return (*(x$1 + 0));
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test33.out.c
===================================================================
--- gcc/zls/tests/test33.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test33.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,56 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+enum E;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+enum E{
+  X$1 = 0,
+  Y$1 = 1,
+  Z = 2,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+enum E foo$$1();
+int f();
+int main();
+/* definitions */
+enum E foo$$1()
+{
+  return ((X$1 + Y$1) + Z);
+}
+int f()
+{
+  return ((int)foo$$1());
+}
+int main()
+{
+  return (f() + ((int)Z));
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test52.out.c
===================================================================
--- gcc/zls/tests/test52.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test52.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,63 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+struct S$$1;
+typedef struct S$$1 S$$2;
+struct S0$$1;
+typedef struct S0$$1 S0$$2;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+struct S$$1 {
+  int x;
+};
+struct S0$$1 {
+  int y;
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main();
+/* definitions */
+S0$$2 x$$1;
+struct S0$$1 y$$1;
+S$$2 x0;
+struct S$$1 s0;
+S0$$2 x1;
+struct S0$$1 s1;
+int main()
+{
+  x0.x;
+  s1.y;
+  s0.x;
+  s1.y;
+  S0$$2 x$1;
+  struct S0$$1 m$1;
+  x$1.y;
+  m$1.y;
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test71.out.c
===================================================================
--- gcc/zls/tests/test71.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test71.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,45 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main();
+/* definitions */
+int main()
+{
+  float x$1 = ((float)({
+    double t$1 = 0x0p+0;
+    (((int)t$1) ? t$1 : 0x1.b333333333333p+2);
+  }));
+  float y$1 = 0x1.8p+2f;
+  printf("%f %f\n", x$1, y$1);
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test18.out.c
===================================================================
--- gcc/zls/tests/test18.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test18.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,49 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+enum E;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+enum E{
+  C0 = 0,
+  C1 = 1,
+  C3 = 3,
+  C4 = 4,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main();
+/* definitions */
+int main()
+{
+  enum E e$1 = 0;
+  enum E e1$1 = 2;
+  return ((int)e1$1);
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test37.out.c
===================================================================
--- gcc/zls/tests/test37.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test37.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,62 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main();
+/* definitions */
+int main()
+{
+  int z$1 = 20;
+  {
+    (z$1 = 40);
+    {
+      printf("%d", z$1);
+    }
+    {
+      int z$2 = 50;
+      {
+        printf("%d", z$2);
+      }
+    }
+    {
+      int z$2 = 60;
+      {
+        printf("%d", z$1);
+      }
+    }
+    {
+      printf("%d", z$1);
+    }
+  }
+  (z$1 = 60);
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test56.out.c
===================================================================
--- gcc/zls/tests/test56.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test56.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,46 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int f();
+int main();
+/* definitions */
+int x;
+int f()
+{
+  return 0;
+}
+int main()
+{
+  (x = f());
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test75.out.c
===================================================================
--- gcc/zls/tests/test75.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test75.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,86 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+struct _Data$$1;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+struct _Data$$1 {
+  int * data;
+  size_t sz;
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int * begin$$1(struct _Data$$1 * this$1);
+int * end$$1(struct _Data$$1 * this$1);
+int main();
+/* definitions */
+int * begin$$1(struct _Data$$1 * this$1)
+{
+  return (*this$1).data;
+}
+int * end$$1(struct _Data$$1 * this$1)
+{
+  return ((*this$1).data + (*this$1).sz);
+}
+int main()
+{
+  struct _Data$$1 x$1;
+  int d$1[4] = {
+    1,
+    5,
+    3,
+    2,
+  };
+  (x$1.data = d$1);
+  (x$1.sz = ((size_t)4));
+  struct _Data$$1 * what$1 = (&x$1);
+  int * i$1 = begin$$1((&(*what$1)));
+  int * e$1 = end$$1((&(*what$1)));
+  {
+    __label__ break$1;
+    __label__ continue$1;
+    ;
+  loop$$1:;
+    if ((!(i$1 != e$1)))
+      goto break$1;
+    {
+      int * el$1 = (&(*i$1));
+      {
+        printf("%d\n", (*el$1));
+      }
+    }
+  continue$1:;
+    ({
+      (i$1 += 1);
+    });
+    goto loop$$1;
+  break$1:;
+  }
+}
+/* special */
+/* done */
Index: gcc/zls/tests/prelude.zls
===================================================================
--- gcc/zls/tests/prelude.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/prelude.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,368 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# macro sep. c. stuff
+(var _macro_funs_size (unsigned) 1)
+(var _macro_funs (.array (.ptr (char :const)) 1) (.
+  (s "parse_class")
+))
+(var _syntaxes_size (unsigned) 74)
+(.struct _syntaxes ((.ptr (char :const)) str) ((.ptr (struct UnmarkedSyntax)) syn))
+(var _syntaxes (.array (struct _syntaxes) 74) (.
+  (. (s "raw_syntax (name @ body :(public parent_n))") 0)
+  (. (s "syntax name") 0)
+  (. (s "syntax body") 0)
+  (. (s "syntax parent_n") 0)
+  (. (s "syntax {declare_user_type name;}") 0)
+  (. (s "syntax _Data") 0)
+  (. (s "syntax _Data") 0)
+  (. (s "syntax parent") 0)
+  (. (s "syntax parent") 0)
+  (. (s "syntax _VTable") 0)
+  (. (s "syntax _VTable") 0)
+  (. (s "syntax _vtable") 0)
+  (. (s "syntax _vtable") 0)
+  (. (s "syntax _vptr") 0)
+  (. (s "syntax _vptr") 0)
+  (. (s "syntax _constructor") 0)
+  (. (s "syntax _constructor") 0)
+  (. (s "syntax _vtable_init") 0)
+  (. (s "syntax _vtable_init") 0)
+  (. (s "syntax parent_n::_VTable") 0)
+  (. (s "syntax {parent_n parent;}") 0)
+  (. (s "syntax {make_subtype parent_n class_cast_up;}") 0)
+  (. (s "syntax {import parent_n;}") 0)
+  (. (s "raw_syntax (declare_user_type (mid name))") 0)
+  (. (s "raw_syntax ({...} @body)") 0)
+  (. (s "syntax body") 0)
+  (. (s "raw_syntax (what n @_)") 0)
+  (. (s "syntax what") 0)
+  (. (s "syntax n") 0)
+  (. (s "syntax {class _VTable : public $1 {$2;};}") 0)
+  (. (s "syntax {class _VTable {$1;};}") 0)
+  (. (s "syntax {void _vtable_init(_VTable * _vt) {$1;} }") 0)
+  (. (s "syntax _vtable_init") 0)
+  (. (s "syntax {__static_constructor void init() {parent_n::_vtable_init(&_vtable); _vtable_init(&_vtable);}}") 0)
+  (. (s "syntax {__static_constructor void init() {_vtable_init(&_vtable);}}") 0)
+  (. (s "syntax {macro _vptr (:this this = this) {*(_VTable * *)&(((parent_n *)this)->_vptr);}}") 0)
+  (. (s "raw_syntax (var (mid _vptr) (.ptr (mid _VTable)))") 0)
+  (. (s "syntax _vptr") 0)
+  (. (s "syntax {void _constructor() {_vptr = &_vtable;}}") 0)
+  (. (s "syntax _constructor") 0)
+  (. (s "syntax {class _VTable;}") 0)
+  (. (s "syntax _VTable") 0)
+  (. (s "syntax _VTable`outer") 0)
+  (. (s "syntax {struct _Data {$1; $2;};}") 0)
+  (. (s "syntax {finalize_user_type struct _Data;}") 0)
+  (. (s "syntax {_VTable _vtable;}") 0)
+  (. (s "syntax {export $1;}") 0)
+  (. (s "syntax {user_type name {$1; $2;}}") 0)
+  (. (s "raw_syntax (n @rest)") 0)
+  (. (s "syntax static") 0)
+  (. (s "raw_syntax(var (w/inner (mid n) internal) (mid rest))") 0)
+  (. (s "syntax {macro n () {n`internal;}}") 0)
+  (. (s "syntax {macro n (:this this = this) {(*(name *)this)..n;}}") 0)
+  (. (s "raw_syntax (n parms ret body)") 0)
+  (. (s "raw_syntax (@parms)") 0)
+  (. (s "syntax parms") 0)
+  (. (s "syntax static") 0)
+  (. (s "syntax virtual") 0)
+  (. (s "syntax nv") 0)
+  (. (s "syntax n`non_virtual") 0)
+  (. (s "syntax nv") 0)
+  (. (s "syntax n") 0)
+  (. (s "raw_syntax ((.ptr (mid name)) (fluid this))") 0)
+  (. (s "syntax ((name  *)this)") 0)
+  (. (s "syntax parms") 0)
+  (. (s "syntax (:this this = this)") 0)
+  (. (s "raw_syntax (fun (w/inner (mid n) internal) (.(mid $1)) (mid ret) (mid body))") 0)
+  (. (s "syntax {macro nv ($1) {n`internal($2);}}") 0)
+  (. (s "syntax {macro n ($1) {(this->_vptr->n)($2);}}") 0)
+  (. (s "syntax pfun") 0)
+  (. (s "raw_syntax (.ptr (.fun (.(mid $1)) (mid ret)))") 0)
+  (. (s "syntax n") 0)
+  (. (s "raw_syntax (var (mid n) (mid pfun))") 0)
+  (. (s "raw_syntax (assign (-> (id _vt) (id (mid n))) \n                                         (cast (mid pfun) (id (w/inner (mid n) internal))))") 0)
+))
+
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun new_mark_f (. ((.ptr (EnvironSnapshot)) )) (.ptr (Mark)))
+(fun syntax_flag (. ((.ptr (struct Syntax)) ) ((.ptr (struct UnmarkedSyntax)) )) (.ptr (struct Syntax)))
+(fun new_syntax_list (.) (.ptr (struct SyntaxList)))
+(fun syntax_list_empty (. ((.ptr (struct SyntaxList :const)) )) (int))
+(fun syntax_list_append (. ((.ptr (struct SyntaxList)) ) ((.ptr (struct Syntax)) )) (void))
+(fun syntax_enum_next (. ((.ptr (struct SyntaxEnum)) )) (.ptr (struct Syntax)))
+(fun match (. ((.ptr (struct Match)) ) ((.ptr (struct UnmarkedSyntax)) pattern) ((.ptr (struct Syntax)) with)) (.ptr (struct Match)))
+(fun match_args (. ((.ptr (struct Match)) ) ((.ptr (struct UnmarkedSyntax)) pattern) ((.ptr (struct Syntax)) with)) (.ptr (struct Match)))
+(fun match_local (. ((.ptr (struct Match)) ) ...) (.ptr (struct Match)))
+(fun match_var (. ((.ptr (struct Match)) ) ((.ptr (struct UnmarkedSyntax)) )) (.ptr (struct Syntax)))
+(fun match_varl (. ((.ptr (struct Match)) ) ((.ptr (struct UnmarkedSyntax)) )) (.ptr (struct SyntaxEnum)))
+(fun replace (. ((.ptr (struct UnmarkedSyntax)) ) ((.ptr (struct Match)) ) ((.ptr (Mark)) )) (.ptr (struct Syntax)))
+(fun get_context (. ((.ptr (struct Syntax)) )) (.ptr (Context)))
+(fun replace_context (. ((.ptr (struct UnmarkedSyntax)) ) ((.ptr (Context)) )) (.ptr (struct Syntax)))
+(fun partly_expand (. ((.ptr (struct Syntax)) ) ((Position) pos) ((.ptr (Environ)) )) (.ptr (struct Syntax)))
+(fun partly_expand_list (. ((.ptr (struct SyntaxEnum)) ) ((Position) pos) ((.ptr (Environ)) )) (.ptr (struct SyntaxEnum)))
+(fun pre_parse (. ((.ptr (struct Syntax)) ) ((.ptr (Environ)) )) (.ptr (struct Syntax)))
+(fun reparse (. ((.ptr (struct Syntax)) ) ((.ptr (char :const)) ) ((.ptr (Environ)) )) (.ptr (struct Syntax)))
+(fun string_to_syntax (. ((.ptr (char :const)) str)) (.ptr (struct UnmarkedSyntax)))
+(fun syntax_to_string (. ((.ptr (struct UnmarkedSyntax)) )) (.ptr (char :const)))
+(fun dump_syntax (. ((.ptr (struct UnmarkedSyntax)) )) (void))
+(fun user_type_info (. ((.ptr (struct Syntax)) ) ((.ptr (Environ)) )) (.ptr (struct UserTypeInfo)))
+(fun user_type_module (. ((.ptr (struct UserTypeInfo)) )) (.ptr (struct ModuleInfo)))
+(fun module_info (. ((.ptr (struct Syntax)) ) ((.ptr (Environ)) )) (.ptr (struct ModuleInfo)))
+(fun module_symbols (. ((.ptr (struct ModuleInfo)) )) (.ptr (struct SyntaxEnum)))
+(fun module_have_symbol (. ((.ptr (struct ModuleInfo)) ) ((.ptr (struct Syntax)) )) (bool))
+(fun temp_environ (. ((.ptr (Environ)) )) (.ptr (Environ)))
+(fun ct_value (. ((.ptr (struct Syntax)) ) ((.ptr (Environ)) )) (size_t))
+(fun error (. ((.ptr (struct Syntax)) ) ((.ptr (char :const)) ) ...) (.ptr (struct Syntax)))
+(fun get_symbol_prop (. ((.ptr (struct Syntax)) sym) ((.ptr (struct Syntax)) prop) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun symbol_exists (. ((.ptr (struct UnmarkedSyntax)) sym) ((.ptr (struct Syntax)) where) ((.ptr (Mark)) ) ((.ptr (Environ)) )) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun parse_class_var (. ((.ptr (struct Syntax)) p) ((.ptr (struct Match)) m) ((.ptr (Mark)) mark) ((.ptr (struct SyntaxList)) struct_b) ((.ptr (struct SyntaxList)) module_b)) (void))
+(fun parse_class_fun (. ((.ptr (struct Syntax)) p) ((.ptr (struct Match)) m) ((.ptr (Mark)) mark) ((.ptr (struct SyntaxList)) struct_b) ((.ptr (struct SyntaxList)) module_b) ((.ptr (struct UserTypeInfo)) parent_vtable) ((.ptr (struct SyntaxList)) vtable_b) ((.ptr (struct SyntaxList)) vtable_i) ((.ptr (Environ)) env)) (void))
+# definitions
+(var parse_class$env_ss (.ptr (struct EnvironSnapshot)))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)) (block
+  (var mark$1 (.ptr (Mark)) (call new_mark_f (. (id parse_class$env_ss))))
+  (var m$1 (.ptr (struct Match)) (call match_args (. 0 (member (deref (plus _syntaxes 0)) syn) p)))
+  (var name$1 (.ptr (struct Syntax)) (call match_var (. m$1 (member (deref (plus _syntaxes 1)) syn))))
+  (var body$1 (.ptr (struct Syntax)) (call match_var (. m$1 (member (deref (plus _syntaxes 2)) syn))))
+  (var parent_s$1 (.ptr (struct Syntax)) (call match_var (. m$1 (member (deref (plus _syntaxes 3)) syn))))
+  (if (not body$1)
+    (block
+      (return (call replace (. (member (deref (plus _syntaxes 4)) syn) m$1 mark$1)))
+    )
+  )
+  (var parent$1 (.ptr (struct UserTypeInfo)) (eif (cast (int) parent_s$1) (call user_type_info (. parent_s$1 env)) 0))
+  (var context$1 (.ptr (Context)) (call get_context (. name$1)))
+  (var parent_m$1 (.ptr (struct ModuleInfo)) 0)
+  (var parent_vtable$1 (.ptr (struct UserTypeInfo)) 0)
+  (var parent_vtable_n$1 (.ptr (struct Syntax)) 0)
+  (var vtable$1 (.ptr (struct Syntax)) 0)
+  (var struct_p$1 (.ptr (struct SyntaxList)) (call new_syntax_list (.)))
+  (var struct_b$1 (.ptr (struct SyntaxList)) (call new_syntax_list (.)))
+  (var module_p$1 (.ptr (struct SyntaxList)) (call new_syntax_list (.)))
+  (var module_b$1 (.ptr (struct SyntaxList)) (call new_syntax_list (.)))
+  (var vtable_b$1 (.ptr (struct SyntaxList)) (call new_syntax_list (.)))
+  (var vtable_i$1 (.ptr (struct SyntaxList)) (call new_syntax_list (.)))
+  (var exports$1 (.ptr (struct SyntaxList)) (call new_syntax_list (.)))
+  (assign m$1 (call match (. m$1 (member (deref (plus _syntaxes 5)) syn) (call replace_context (. (member (deref (plus _syntaxes 6)) syn) context$1)))))
+  (assign m$1 (call match (. m$1 (member (deref (plus _syntaxes 7)) syn) (call replace_context (. (member (deref (plus _syntaxes 8)) syn) context$1)))))
+  (assign m$1 (call match (. m$1 (member (deref (plus _syntaxes 9)) syn) (call replace_context (. (member (deref (plus _syntaxes 10)) syn) context$1)))))
+  (assign m$1 (call match (. m$1 (member (deref (plus _syntaxes 11)) syn) (call replace_context (. (member (deref (plus _syntaxes 12)) syn) context$1)))))
+  (assign m$1 (call match (. m$1 (member (deref (plus _syntaxes 13)) syn) (call replace_context (. (member (deref (plus _syntaxes 14)) syn) context$1)))))
+  (assign m$1 (call match (. m$1 (member (deref (plus _syntaxes 15)) syn) (call replace_context (. (member (deref (plus _syntaxes 16)) syn) context$1)))))
+  (assign m$1 (call match (. m$1 (member (deref (plus _syntaxes 17)) syn) (call replace_context (. (member (deref (plus _syntaxes 18)) syn) context$1)))))
+  (if (cast (int) parent$1)
+    (block
+      (assign parent_m$1 (call user_type_module (. parent$1)))
+      (assign parent_vtable_n$1 (call replace (. (member (deref (plus _syntaxes 19)) syn) m$1 mark$1)))
+      (assign parent_vtable$1 (call user_type_info (. parent_vtable_n$1 env)))
+      (call syntax_list_append (. struct_p$1 (call replace (. (member (deref (plus _syntaxes 20)) syn) m$1 mark$1))))
+      (call syntax_list_append (. module_p$1 (call replace (. (member (deref (plus _syntaxes 21)) syn) m$1 mark$1))))
+      (call syntax_list_append (. module_p$1 (call replace (. (member (deref (plus _syntaxes 22)) syn) m$1 mark$1))))
+      (var itr$1 (.ptr (struct SyntaxEnum)) (call module_symbols (. parent_m$1)))
+      (var syn$1 (.ptr (struct Syntax)))
+      (block
+        (local_label break$1)
+        (local_label continue$1)
+      (label continue$1)
+        (if (not (assign syn$1 (call syntax_enum_next (. itr$1))))
+          (goto break$1)
+        )
+        (block
+          (call syntax_list_append (. exports$1 syn$1))
+        )
+        (goto continue$1)
+      (label break$1)
+      )
+    )
+  )
+  (var lenv$1 (.ptr (Environ)) (call temp_environ (. env)))
+  (call pre_parse (. (call replace (. (member (deref (plus _syntaxes 23)) syn) m$1 mark$1)) lenv$1))
+  (var itr$1 (.ptr (struct SyntaxEnum)) (call partly_expand_list (. (call match_varl (. (call match (. 0 (member (deref (plus _syntaxes 24)) syn) body$1)) (member (deref (plus _syntaxes 25)) syn))) FieldPos lenv$1)))
+  (var member$1 (.ptr (struct Syntax)))
+  (block
+    (local_label break$1)
+    (local_label continue$1)
+  (label continue$1)
+    (if (not (assign member$1 (call syntax_enum_next (. itr$1))))
+      (goto break$1)
+    )
+    (block
+      (var m0$1 (.ptr (struct Match)) (call match (. m$1 (member (deref (plus _syntaxes 26)) syn) member$1)))
+      (var what$1 (.ptr (char :const)) (call syntax_to_string (. (cast (.ptr (struct UnmarkedSyntax)) (call match_var (. m0$1 (member (deref (plus _syntaxes 27)) syn)))))))
+      (if (eq (call strcmp (. what$1 (s "label"))) 0)
+        (goto continue$1)
+      )
+      (if (eq (call strcmp (. what$1 (s "var"))) 0)
+        (call parse_class_var (. member$1 m$1 mark$1 struct_b$1 module_b$1))
+        (if (eq (call strcmp (. what$1 (s "fun"))) 0)
+          (call parse_class_fun (. member$1 m$1 mark$1 struct_b$1 module_b$1 parent_vtable$1 vtable_b$1 vtable_i$1 lenv$1))
+          (call syntax_list_append (. module_p$1 (call pre_parse (. member$1 lenv$1))))
+        )
+      )
+      (call syntax_list_append (. exports$1 (call match_var (. m0$1 (member (deref (plus _syntaxes 28)) syn)))))
+    )
+    (goto continue$1)
+  (label break$1)
+  )
+  (var need_vtable$1 (bool :const) (not (call syntax_list_empty (. vtable_i$1))))
+  (if need_vtable$1
+    (block
+      (if (cast (int) parent_vtable$1)
+        (block
+          (assign vtable$1 (call replace (. (member (deref (plus _syntaxes 29)) syn) (call match_local (. m$1 parent_vtable_n$1 vtable_b$1 0)) mark$1)))
+        )
+        (block
+          (assign vtable$1 (call replace (. (member (deref (plus _syntaxes 30)) syn) (call match_local (. m$1 vtable_b$1 0)) mark$1)))
+        )
+      )
+      (call syntax_list_append (. module_b$1 (call replace (. (member (deref (plus _syntaxes 31)) syn) (call match_local (. m$1 vtable_i$1 0)) mark$1))))
+      (call syntax_list_append (. exports$1 (call replace (. (member (deref (plus _syntaxes 32)) syn) m$1 mark$1))))
+      (if (cast (int) parent_vtable$1)
+        (block
+          (call syntax_list_append (. module_b$1 (call replace (. (member (deref (plus _syntaxes 33)) syn) m$1 mark$1))))
+        )
+        (block
+          (call syntax_list_append (. module_b$1 (call replace (. (member (deref (plus _syntaxes 34)) syn) m$1 mark$1))))
+        )
+      )
+      (if (cast (int) parent_vtable$1)
+        (block
+          (call syntax_list_append (. module_b$1 (call replace (. (member (deref (plus _syntaxes 35)) syn) m$1 mark$1))))
+        )
+        (block
+          (var v$1 (.ptr (struct Syntax)) (call replace (. (member (deref (plus _syntaxes 36)) syn) m$1 mark$1)))
+          (call parse_class_var (. v$1 m$1 mark$1 struct_p$1 module_b$1))
+        )
+      )
+      (call syntax_list_append (. exports$1 (call replace (. (member (deref (plus _syntaxes 37)) syn) m$1 mark$1))))
+      (var f$1 (.ptr (struct Syntax)) (call partly_expand (. (call replace (. (member (deref (plus _syntaxes 38)) syn) m$1 mark$1)) FieldPos env)))
+      (call parse_class_fun (. f$1 m$1 mark$1 struct_p$1 module_p$1 0 vtable_b$1 vtable_i$1 env))
+      (call syntax_list_append (. exports$1 (call replace (. (member (deref (plus _syntaxes 39)) syn) m$1 mark$1))))
+    )
+  )
+  (if need_vtable$1
+    (block
+      (call syntax_list_append (. module_p$1 (call replace (. (member (deref (plus _syntaxes 40)) syn) m$1 mark$1))))
+      (call syntax_list_append (. exports$1 (call replace (. (member (deref (plus _syntaxes 41)) syn) m$1 mark$1))))
+      (call syntax_list_append (. exports$1 (call replace (. (member (deref (plus _syntaxes 42)) syn) m$1 mark$1))))
+    )
+  )
+  (call syntax_list_append (. module_p$1 (call replace (. (member (deref (plus _syntaxes 43)) syn) (call match_local (. m$1 struct_p$1 struct_b$1 0)) mark$1))))
+  (call syntax_list_append (. module_p$1 (call replace (. (member (deref (plus _syntaxes 44)) syn) m$1 mark$1))))
+  (if need_vtable$1
+    (block
+      (call syntax_list_append (. module_p$1 vtable$1))
+      (call syntax_list_append (. module_p$1 (call replace (. (member (deref (plus _syntaxes 45)) syn) m$1 mark$1))))
+    )
+  )
+  (call syntax_list_append (. module_b$1 (call replace (. (member (deref (plus _syntaxes 46)) syn) (call match_local (. m$1 exports$1 0)) mark$1))))
+  (var module_$1 (.ptr (struct Syntax)) (call replace (. (member (deref (plus _syntaxes 47)) syn) (call match_local (. m$1 module_p$1 module_b$1 0)) mark$1)))
+  (return module_$1)
+)
+)
+(fun parse_class_var (. ((.ptr (struct Syntax)) p) ((.ptr (struct Match)) m) ((.ptr (Mark)) mark) ((.ptr (struct SyntaxList)) struct_b) ((.ptr (struct SyntaxList)) module_b)) (void) (block
+  (assign m (call match_args (. m (member (deref (plus _syntaxes 48)) syn) p)))
+  (var is_static$1 (bool) (cast (bool) (call syntax_flag (. p (member (deref (plus _syntaxes 49)) syn)))))
+  (if is_static$1
+    (block
+      (call syntax_list_append (. module_b (call replace (. (member (deref (plus _syntaxes 50)) syn) m mark))))
+      (call syntax_list_append (. module_b (call replace (. (member (deref (plus _syntaxes 51)) syn) m mark))))
+    )
+    (block
+      (call syntax_list_append (. struct_b p))
+      (call syntax_list_append (. module_b (call replace (. (member (deref (plus _syntaxes 52)) syn) m mark))))
+    )
+  )
+)
+)
+(fun parse_class_fun (. ((.ptr (struct Syntax)) p) ((.ptr (struct Match)) m) ((.ptr (Mark)) mark) ((.ptr (struct SyntaxList)) struct_b) ((.ptr (struct SyntaxList)) module_b) ((.ptr (struct UserTypeInfo)) parent_vtable) ((.ptr (struct SyntaxList)) vtable_b) ((.ptr (struct SyntaxList)) vtable_i) ((.ptr (Environ)) env)) (void) (block
+  (assign m (call match_args (. m (member (deref (plus _syntaxes 53)) syn) p)))
+  (assign m (call match_args (. m (member (deref (plus _syntaxes 54)) syn) (call match_var (. m (member (deref (plus _syntaxes 55)) syn))))))
+  (var is_static$1 (bool) (cast (bool) (call syntax_flag (. p (member (deref (plus _syntaxes 56)) syn)))))
+  (var is_virtual$1 (bool) (cast (bool) (call syntax_flag (. p (member (deref (plus _syntaxes 57)) syn)))))
+  (if is_virtual$1
+    (assign m (call match (. m (member (deref (plus _syntaxes 58)) syn) (call replace (. (member (deref (plus _syntaxes 59)) syn) m mark)))))
+    (assign m (call match (. m (member (deref (plus _syntaxes 60)) syn) (call replace (. (member (deref (plus _syntaxes 61)) syn) m mark)))))
+  )
+  (var new_parms$1 (.ptr (struct SyntaxList)) (call new_syntax_list (.)))
+  (if (not is_static$1)
+    (call syntax_list_append (. new_parms$1 (call replace (. (member (deref (plus _syntaxes 62)) syn) m mark))))
+  )
+  (var macro_parms$1 (.ptr (struct SyntaxList)) (call new_syntax_list (.)))
+  (var call_parms$1 (.ptr (struct SyntaxList)) (call new_syntax_list (.)))
+  (if (not is_static$1)
+    (call syntax_list_append (. call_parms$1 (call replace (. (member (deref (plus _syntaxes 63)) syn) m mark))))
+  )
+  (var parms_enum$1 (.ptr (struct SyntaxEnum)) (call match_varl (. m (member (deref (plus _syntaxes 64)) syn))))
+  (var i$1 (unsigned-int) 0)
+  (var parm$1 (.ptr (struct Syntax)))
+  (block
+    (local_label break$1)
+    (local_label continue$1)
+  (label continue$1)
+    (if (not (assign parm$1 (call syntax_enum_next (. parms_enum$1))))
+      (goto break$1)
+    )
+    (block
+      (call syntax_list_append (. new_parms$1 parm$1))
+      (var sbuf$1 (.array (char) 8))
+      (call snprintf (. sbuf$1 (cast (size_t) 8) (s "arg%d") i$1))
+      (var arg$1 (.ptr (struct Syntax)) (call replace (. (call string_to_syntax (. sbuf$1)) 0 mark)))
+      (call syntax_list_append (. macro_parms$1 arg$1))
+      (call syntax_list_append (. call_parms$1 arg$1))
+      (c-assign plus i$1 (cast (unsigned-int) 1))
+    )
+    (goto continue$1)
+  (label break$1)
+  )
+  (if (not is_static$1)
+    (call syntax_list_append (. macro_parms$1 (call replace (. (member (deref (plus _syntaxes 65)) syn) m mark))))
+  )
+  (call syntax_list_append (. module_b (call replace (. (member (deref (plus _syntaxes 66)) syn) (call match_local (. m new_parms$1 0)) mark))))
+  (call syntax_list_append (. module_b (call replace (. (member (deref (plus _syntaxes 67)) syn) (call match_local (. m macro_parms$1 call_parms$1 0)) mark))))
+  (if is_virtual$1
+    (block
+      (call syntax_list_append (. module_b (call replace (. (member (deref (plus _syntaxes 68)) syn) (call match_local (. m macro_parms$1 call_parms$1 0)) mark))))
+      (assign m (call match (. m (member (deref (plus _syntaxes 69)) syn) (call replace (. (member (deref (plus _syntaxes 70)) syn) (call match_local (. m new_parms$1 0)) mark)))))
+      (if (not (eif (cast (int) parent_vtable) (call module_have_symbol (. (call user_type_module (. parent_vtable)) (call match_var (. m (member (deref (plus _syntaxes 71)) syn))))) 0))
+        (block
+          (call syntax_list_append (. vtable_b (call replace (. (member (deref (plus _syntaxes 72)) syn) m mark))))
+        )
+      )
+      (call syntax_list_append (. vtable_i (call replace (. (member (deref (plus _syntaxes 73)) syn) m mark))))
+    )
+  )
+)
+)
+# special
+# done
Index: gcc/zls/tests/test23.out.c
===================================================================
--- gcc/zls/tests/test23.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test23.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,64 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+struct X;
+struct Y;
+enum Z;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+struct X {
+  char x;
+  int y;
+};
+struct Y {
+  char x;
+};
+enum Z{
+  A = 0,
+  B = 1,
+  C = 2,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main();
+/* definitions */
+int main()
+{
+  int a$1[20];
+  4;
+  8;
+  8;
+  1;
+  4;
+  int b$1[20];
+  int c$1[20];
+  ((int *)a$1);
+  ((void *)((int *)a$1));
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test42.out.c
===================================================================
--- gcc/zls/tests/test42.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test42.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,43 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main();
+/* definitions */
+int main()
+{
+  int x$1 = 20;
+  int x$2 = 30;
+  (x$1 = x$2);
+  return x$1;
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test61.out.c
===================================================================
--- gcc/zls/tests/test61.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test61.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,86 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+struct _Data$$1;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+struct _Data$$1 {
+  int * data;
+  size_t sz;
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int * begin$$1(struct _Data$$1 * this$1);
+int * end$$1(struct _Data$$1 * this$1);
+int main();
+/* definitions */
+int * begin$$1(struct _Data$$1 * this$1)
+{
+  return (*this$1).data;
+}
+int * end$$1(struct _Data$$1 * this$1)
+{
+  return ((*this$1).data + (*this$1).sz);
+}
+int main()
+{
+  struct _Data$$1 x$1;
+  int d$1[4] = {
+    1,
+    5,
+    3,
+    2,
+  };
+  (x$1.data = d$1);
+  (x$1.sz = ((size_t)4));
+  struct _Data$$1 * what$1 = (&x$1);
+  int * i$1 = begin$$1((&(*what$1)));
+  int * e$1 = end$$1((&(*what$1)));
+  {
+    __label__ break$1;
+    __label__ continue$1;
+    ;
+  loop$$1:;
+    if ((!(i$1 != e$1)))
+      goto break$1;
+    {
+      int * el$1 = (&(*i$1));
+      {
+        printf("%d\n", (*el$1));
+      }
+    }
+  continue$1:;
+    ({
+      (i$1 += 1);
+    });
+    goto loop$$1;
+  break$1:;
+  }
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test27.out.c
===================================================================
--- gcc/zls/tests/test27.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test27.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,42 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main();
+/* definitions */
+int x = 10;
+int main()
+{
+  int x$1 = 20;
+  (x$1 = x);
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test69.out.c
===================================================================
--- gcc/zls/tests/test69.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test69.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,50 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main();
+/* definitions */
+int main()
+{
+  char c$1 = 1;
+  signed char sc$1 = 2;
+  unsigned char uc$1 = 3u;
+  short s$1 = 4;
+  unsigned short us$1 = 5u;
+  int i$1 = 6;
+  unsigned int u$1 = 7u;
+  long l$1 = 8;
+  unsigned long lu$1 = 9u;
+  long long ll$1 = 10ll;
+  unsigned long long ull$1 = 10ull;
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test3.out.c
===================================================================
--- gcc/zls/tests/test3.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test3.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,69 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+void foo();
+void foo2();
+int main();
+/* definitions */
+int main()
+{
+  int x$1 = 0;
+  {
+    __label__ break$1;
+    __label__ continue$1;
+  continue$1:;
+    if ((!((x$1 != 20) ? ((x$1 != 30) ? 1 : (x$1 != 40)) : 0)))
+      goto break$1;
+    (x$1 += 1);
+    goto continue$1;
+  break$1:;
+  }
+  {
+    __label__ break$1;
+    __label__ continue$1;
+    int i$1 = 9;
+    int j$1 = 11;
+  loop$$1:;
+    if ((!1))
+      goto break$1;
+    {
+      (x$1 = (i$1 + x$1));
+    }
+  continue$1:;
+    ;
+    goto loop$$1;
+  break$1:;
+  }
+  (x$1 |= 3);
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test7.out.c
===================================================================
--- gcc/zls/tests/test7.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test7.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,69 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main();
+/* definitions */
+int main()
+{
+  int x$1 = 0;
+  int z$1;
+  int z$2 = 0;
+  (z$2 = 20);
+  int y$1 = z$2;
+  (y$1 += 1);
+  (y$1 = ((y$1 *= 2) + 4));
+  {
+    __label__ break$1;
+    __label__ continue$1;
+    ;
+  loop$$1:;
+    if ((!1))
+      goto break$1;
+    (x$1 + 1);
+  continue$1:;
+    ;
+    goto loop$$1;
+  break$1:;
+  }
+  if (x$1)
+    {
+      (x$1 *= 20);
+      (y$1 *= 30);
+    }
+  else
+    (y$1 *= 2);
+  (z$1 = (5 + 5));
+  (z$1 = ((2 + 3) * (2 + 3)));
+  ((y$1 * y$1) + (y$1 * y$1));
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test11.out.zls
===================================================================
--- gcc/zls/tests/test11.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test11.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,55 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun f0 (.) (int))
+(fun f1 (. ((int) x)) (int))
+(fun f2 (. ((int) x) ((int) y)) (int))
+(fun main (.) (int))
+# definitions
+(fun f0 (.) (int) (block
+  (return 0)
+)
+)
+(fun f1 (. ((int) x)) (int) (block
+  (return (times x 2))
+)
+)
+(fun f2 (. ((int) x) ((int) y)) (int) (block
+  (return (plus x y))
+)
+)
+(fun main (.) (int) (block
+  (return (plus (plus (call f0 (.)) (call f1 (. 1))) (call f2 (. 2 3))))
+)
+)
+# special
+# done
Index: gcc/zls/tests/test12.out.zls
===================================================================
--- gcc/zls/tests/test12.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test12.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,42 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (.) (int))
+# definitions
+(fun main (.) (int) (block
+  (var z$1 (int) (eblock    (var x$1 (int) 0)
+    x$1
+  ))
+)
+)
+# special
+# done
Index: gcc/zls/tests/test13.out.zls
===================================================================
--- gcc/zls/tests/test13.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test13.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,43 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (.) (int))
+# definitions
+(fun main (.) (int) (block
+  (var x$1 (.ptr (int)))
+  (if (ne x$1 0)
+    (noop)
+  )
+)
+)
+# special
+# done
Index: gcc/zls/tests/test14.out.zls
===================================================================
--- gcc/zls/tests/test14.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test14.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,41 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (.) (int))
+# definitions
+(fun main (.) (int) (block
+  (var x$1 (.array (int) 20))
+  (return (deref (plus x$1 0)))
+)
+)
+# special
+# done
Index: gcc/zls/tests/test15.out.zls
===================================================================
--- gcc/zls/tests/test15.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test15.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,40 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (. ((int) argc) ((.array (.ptr (char :const)) 0) argv)) (int))
+# definitions
+(fun main (. ((int) argc) ((.array (.ptr (char :const)) 0) argv)) (int) (block
+  (return (cast (int) (deref (deref (plus argv 0)))))
+)
+)
+# special
+# done
Index: gcc/zls/tests/test16.out.zls
===================================================================
--- gcc/zls/tests/test16.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test16.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,42 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun f (. ((int) x) ((int) y) ...) (int))
+(fun main (.) (int))
+# definitions
+(fun main (.) (int) (block
+  (call f (. 1 2))
+  (call f (. 1 2 3 4))
+)
+)
+# special
+# done
Index: gcc/zls/tests/test17.out.zls
===================================================================
--- gcc/zls/tests/test17.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test17.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,52 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+(.struct X)
+(talias X (struct X))
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+(.struct X
+  ((int) x)
+  ((int) y)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (.) (int))
+(fun main2 (.) (int))
+# definitions
+(fun main (.) (int) (block
+  (var x$1 (.ptr (struct X)))
+)
+)
+(fun main2 (.) (int) (block
+  (var x$1 (.ptr (X)))
+  (var i$1 (int) (member (deref x$1) x))
+)
+)
+# special
+# done
Index: gcc/zls/tests/test18.out.zls
===================================================================
--- gcc/zls/tests/test18.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test18.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,49 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+(.enum E)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+(.enum E
+   (C0 0)
+   (C1 1)
+   (C3 3)
+   (C4 4)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (.) (int))
+# definitions
+(fun main (.) (int) (block
+  (var e$1 (enum E) 0)
+  (var e1$1 (enum E) 2)
+  (return (cast (int) e1$1))
+)
+)
+# special
+# done
Index: gcc/zls/tests/test19.out.zls
===================================================================
--- gcc/zls/tests/test19.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test19.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,43 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+(talias DOUBLE (double))
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (.) (int))
+# definitions
+(fun main (.) (int) (block
+  (var x$1 (double :const) (f 0x1.4p+4 (double)))
+  (var y$1 (DOUBLE) (f 0x1.5p+4 (double)))
+  (var z$1 (double) (plus (plus x$1 y$1) (cast (double) 1)))
+)
+)
+# special
+# done
Index: gcc/zls/tests/test13.out.c
===================================================================
--- gcc/zls/tests/test13.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test13.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,42 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main();
+/* definitions */
+int main()
+{
+  int * x$1;
+  if ((x$1 != 0))
+    ;
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test32.out.c
===================================================================
--- gcc/zls/tests/test32.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test32.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,55 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int f(int x);
+int g(int x);
+int h(int x);
+int main();
+/* definitions */
+int f(int x)
+{
+  int y$1;
+}
+int g(int x)
+{
+  int y$1;
+}
+int h(int x)
+{
+  int y$1;
+}
+int main()
+{
+  ;
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test51.out.c
===================================================================
--- gcc/zls/tests/test51.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test51.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,106 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+struct _Data$$1;
+struct _Data$$2;
+struct _Data$$3;
+struct _Data$$4;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+struct _Data$$1 {
+  struct _Data$$2 * _vptr;
+};
+struct _Data$$2 {
+  void (* foo)(struct _Data$$1 * this);
+};
+struct _Data$$3 {
+  struct _Data$$1 parent;
+};
+struct _Data$$4 {
+  struct _Data$$2 parent;
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+void _constructor$$1(struct _Data$$1 * this$1);
+void foo$$1(struct _Data$$1 * this$1);
+void _vtable_init$$1(struct _Data$$2 * _vt$1);
+void init$$1() __attribute__((constructor));
+void _constructor$$2(struct _Data$$3 * this$1);
+void foo$$2(struct _Data$$3 * this$1);
+void _vtable_init$$2(struct _Data$$4 * _vt$1);
+void init$$2() __attribute__((constructor));
+int main();
+/* definitions */
+struct _Data$$2 _vtable$$1;
+void _constructor$$1(struct _Data$$1 * this$1)
+{
+  ((*this$1)._vptr = (&_vtable$$1));
+}
+void foo$$1(struct _Data$$1 * this$1)
+{
+  printf("X\n");
+}
+void _vtable_init$$1(struct _Data$$2 * _vt$1)
+{
+  ((*_vt$1).foo = ((void (*)(struct _Data$$1 * this))((void (*)(struct _Data$$1 * this))foo$$1)));
+}
+void init$$1()
+{
+  _vtable_init$$1((&_vtable$$1));
+}
+struct _Data$$4 _vtable$$2;
+void _constructor$$2(struct _Data$$3 * this$1)
+{
+  ((*((struct _Data$$4 * *)(&(*((struct _Data$$1 *)this$1))._vptr))) = (&_vtable$$2));
+}
+void foo$$2(struct _Data$$3 * this$1)
+{
+  printf("Y\n");
+}
+void _vtable_init$$2(struct _Data$$4 * _vt$1)
+{
+  ((*((struct _Data$$2 *)_vt$1)).foo = ((void (*)(struct _Data$$1 * this))((void (*)(struct _Data$$3 * this))foo$$2)));
+}
+void init$$2()
+{
+  _vtable_init$$1((&_vtable$$2.parent));
+  _vtable_init$$2((&_vtable$$2));
+}
+int main()
+{
+  struct _Data$$1 x$1;
+  _constructor$$1((&x$1));
+  struct _Data$$3 y$1;
+  _constructor$$2((&y$1));
+  (*x$1._vptr).foo(((struct _Data$$1 *)(&x$1)));
+  (*((struct _Data$$2 *)(*((struct _Data$$4 * *)(&(*((struct _Data$$1 *)(&y$1)))._vptr))))).foo((&y$1.parent));
+  struct _Data$$1 * xp$1 = (&y$1.parent);
+  (*(*xp$1)._vptr).foo(xp$1);
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test70.out.c
===================================================================
--- gcc/zls/tests/test70.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test70.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,41 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+struct _data$$1;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main();
+/* definitions */
+int main()
+{
+  printf("%d\n", 12);
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test17.out.c
===================================================================
--- gcc/zls/tests/test17.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test17.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,52 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+struct X;
+typedef struct X X;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+struct X {
+  int x;
+  int y;
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main();
+int main2();
+/* definitions */
+int main()
+{
+  struct X * x$1;
+}
+int main2()
+{
+  X * x$1;
+  int i$1 = (*x$1).x;
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test36.out.c
===================================================================
--- gcc/zls/tests/test36.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test36.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,48 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main();
+/* definitions */
+int y = 30;
+int main()
+{
+  int x$1;
+  int y$1;
+  int z$1;
+  int x$2 = (x$1 + y);
+  (z$1 = (x$2 * x$2));
+  int x$3 = (z$1 + y);
+  (z$1 = (x$3 * x$3));
+  return z$1;
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test55.out.c
===================================================================
--- gcc/zls/tests/test55.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test55.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,45 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int f1(int);
+int f2(int, int);
+int f3(int, int, int);
+int main();
+/* definitions */
+int main()
+{
+  f1(1);
+  f2(1, 2);
+  f3(1, 2, 3);
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test74.out.c
===================================================================
--- gcc/zls/tests/test74.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test74.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,68 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+double fabs(double x);
+int main();
+/* definitions */
+double r = 0x1.9e3779beddcbdp+0;
+int main()
+{
+  double q$1 = 0x1.8p+1;
+  double r$1 = 0x1p+1;
+  {
+    __label__ break$1;
+    __label__ continue$1;
+    ;
+  loop$$1:;
+    if ((!1))
+      goto break$1;
+    {
+      double a$1 = q$1;
+      double b$1 = r$1;
+      double a$2 = ((a$1 - (r * b$1)) / (((double)1) + r));
+      if ((fabs((a$2 / (a$1 + b$1))) > 0x1.47ae147ae147bp-7))
+        {
+          (q$1 -= a$2);
+          (r$1 += a$2);
+        }
+      else
+        goto break$1;
+    }
+  continue$1:;
+    ;
+    goto loop$$1;
+  break$1:;
+  }
+  printf("%f %f\n", q$1, r$1);
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test59.out.c
===================================================================
--- gcc/zls/tests/test59.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test59.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,48 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main();
+/* definitions */
+int main()
+{
+  int x$1 = 20;
+  int * xr$1 = (&x$1);
+  int y$1 = 30;
+  int * yr$1 = (&y$1);
+  ((*xr$1) = 15);
+  ((*yr$1) ++);
+  ((*xr$1) += 3);
+  printf("%d\n", ((*xr$1) + (*yr$1)));
+  return 0;
+}
+/* special */
+/* done */
Index: gcc/zls/tests/README
===================================================================
--- gcc/zls/tests/README	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/README	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,7 @@
+This directory proves a snapshot of zl's generated output, both in "c"
+and "zls".  Both version should produce identical assembly output
+except for "prelude.c" which will only produce identical code with
+"-O".  Any discrepancies are likely a bug and need to be looked into.
+
+run-tests.sh is a quick and dirty shell script to compare the
+assembly output of both versions.
Index: gcc/zls/tests/test20.out.zls
===================================================================
--- gcc/zls/tests/test20.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test20.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,41 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (.) (int))
+# definitions
+(fun main (.) (int) (block
+  (n 4 (size_t))
+  (n 4 (size_t))
+)
+)
+# special
+# done
Index: gcc/zls/tests/test21.out.zls
===================================================================
--- gcc/zls/tests/test21.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test21.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,40 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (.) (int))
+# definitions
+(fun main (.) (int) (block
+  (var x$1 (int) 29)
+)
+)
+# special
+# done
Index: gcc/zls/tests/test22.out.zls
===================================================================
--- gcc/zls/tests/test22.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test22.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,48 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+(.enum X)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+(.enum X
+   (A 1)
+   (B 2)
+   (C 4)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (.) (int))
+# definitions
+(fun main (.) (int) (block
+  (var x$1 (.array (int) 3))
+  (var y$1 (.array (int) 0))
+  (var z$1 (.array (int) 2))
+)
+)
+# special
+# done
Index: gcc/zls/tests/test23.out.zls
===================================================================
--- gcc/zls/tests/test23.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test23.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,64 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+(.struct X)
+(.struct Y)
+(.enum Z)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+(.struct X
+  ((char) x)
+  ((int) y)
+)
+(.struct Y
+  ((char) x)
+)
+(.enum Z
+   (A 0)
+   (B 1)
+   (C 2)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (.) (int))
+# definitions
+(fun main (.) (int) (block
+  (var a$1 (.array (int) 20))
+  (n 4 (size_t))
+  (n 8 (size_t))
+  (n 8 (size_t))
+  (n 1 (size_t))
+  (n 4 (size_t))
+  (var b$1 (.array (int) 20))
+  (var c$1 (.array (int) 20))
+  (cast (.ptr (int)) a$1)
+  (cast (.ptr (void)) (cast (.ptr (int)) a$1))
+)
+)
+# special
+# done
Index: gcc/zls/tests/test25.out.zls
===================================================================
--- gcc/zls/tests/test25.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test25.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,61 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (.) (int))
+# definitions
+(fun main (.) (int) (block
+  (var x$1 (int))
+  (if 0
+    (goto inner$$1)
+    (goto outer$$1)
+  )
+  (block
+    (local_label loop$1)
+  (label loop$1)
+    (block
+      (local_label loop$2)
+    (label inner$$1)
+      (block
+        (assign x$1 20)
+        (goto loop$2)
+      )
+    (label loop$2)
+      (assign x$1 15)
+    )
+    (goto loop$1)
+  )
+(label outer$$1)
+  (assign x$1 30)
+)
+)
+# special
+# done
Index: gcc/zls/tests/test26.out.zls
===================================================================
--- gcc/zls/tests/test26.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test26.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,70 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+(.struct s1)
+(talias s1 (struct s1))
+(.struct s2$$1)
+(talias s2$$2 (struct s2$$1))
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+(.struct s1
+  ((int) x)
+  ((int) y)
+)
+(.struct s2$$1
+  ((int) x)
+  ((int) y)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun foo (. ((int) x) ((int) y)) (int))
+(fun main (.) (int))
+# definitions
+(var x (int) 20)
+(fun foo (. ((int) x) ((int) y)) (int) (block
+  (block
+    (var x$1 (int) 20)
+    (if 0
+      (return (plus x$1 y))
+      (goto x$$1)
+    )
+  )
+  (return (plus x y))
+  (var x$1 (int) 2)
+(label x$$1)
+  (return 10)
+)
+)
+(fun main (.) (int) (block
+  (var v1$1 (s1))
+  (var v2$1 (s2$$2))
+  (return (plus (plus (member v1$1 x) (member v2$1 y)) (call foo (. 2 3))))
+)
+)
+# special
+# done
Index: gcc/zls/tests/test27.out.zls
===================================================================
--- gcc/zls/tests/test27.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test27.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,42 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (.) (int))
+# definitions
+(var x (int) 10)
+(fun main (.) (int) (block
+  (var x$1 (int) 20)
+  (assign x$1 x)
+)
+)
+# special
+# done
Index: gcc/zls/tests/test28.out.zls
===================================================================
--- gcc/zls/tests/test28.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test28.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,47 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (.) (int))
+# definitions
+(var x (int) 10)
+(var y (int) 30)
+(var y$$1 (int))
+(fun main (.) (int) (block
+  (var x$1 (int) 20)
+  (assign x$1 (plus x y$$1))
+)
+)
+# special
+(fun init$s (.) (void) :static :__constructor__ (block
+  (assign y$$1 x)
+))
+# done
Index: gcc/zls/tests/test29.out.zls
===================================================================
--- gcc/zls/tests/test29.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test29.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,54 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+(.struct S)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+(.struct S
+  ((int) priv$1)
+  ((int) x)
+  ((int) y)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun init_s (. ((.ptr (struct S)) s$1)) (void))
+(fun main (.) (int))
+# definitions
+(fun init_s (. ((.ptr (struct S)) s$1)) (void) (block
+  (assign (member (deref s$1) priv$1) 0)
+  (assign (member (deref s$1) x) 1)
+  (assign (member (deref s$1) y) 2)
+)
+)
+(fun main (.) (int) (block
+  (var s$1 (struct S))
+  (call init_s (. (addrof s$1)))
+)
+)
+# special
+# done
Index: gcc/zls/tests/test22.out.c
===================================================================
--- gcc/zls/tests/test22.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test22.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,48 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+enum X;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+enum X{
+  A = 1,
+  B = 2,
+  C = 4,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main();
+/* definitions */
+int main()
+{
+  int x$1[3];
+  int y$1[0];
+  int z$1[2];
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test41.out.c
===================================================================
--- gcc/zls/tests/test41.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test41.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,45 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main();
+/* definitions */
+int z$$1 = 20;
+int x$$1 = 20;
+int priv$$1 = 30;
+int main()
+{
+  printf("%d %d %d %d\n", z$$1, x$$1, priv$$1, x$$1);
+  printf("%d %d %d\n", z$$1, x$$1, priv$$1);
+  return x$$1;
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test60.out.c
===================================================================
--- gcc/zls/tests/test60.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test60.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,54 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int * f();
+void g(int * x);
+int main();
+/* definitions */
+int global = 20;
+int * f()
+{
+  return (&global);
+}
+void g(int * x)
+{
+  ((*x) = 20);
+}
+int main()
+{
+  ((*f()) = 20);
+  int x$1;
+  g((&x$1));
+  return 0;
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test26.out.c
===================================================================
--- gcc/zls/tests/test26.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test26.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,70 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+struct s1;
+typedef struct s1 s1;
+struct s2$$1;
+typedef struct s2$$1 s2$$2;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+struct s1 {
+  int x;
+  int y;
+};
+struct s2$$1 {
+  int x;
+  int y;
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int foo(int x, int y);
+int main();
+/* definitions */
+int x = 20;
+int foo(int x, int y)
+{
+  {
+    int x$1 = 20;
+    if (0)
+      return (x$1 + y);
+    else
+      goto x$$1;
+  }
+  return (x + y);
+  int x$1 = 2;
+x$$1:;
+  return 10;
+}
+int main()
+{
+  s1 v1$1;
+  s2$$2 v2$1;
+  return ((v1$1.x + v2$1.y) + foo(2, 3));
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test45.out.c
===================================================================
--- gcc/zls/tests/test45.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test45.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,83 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+struct _Data$$1;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+struct _Data$$1 {
+  int x;
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int f$$1(struct _Data$$1 * this$1);
+int g$$1(struct _Data$$1 * this$1);
+int h0$$1(struct _Data$$1 * this$1, int j);
+int h1$$1(struct _Data$$1 * this$1, int j);
+int y$$1(struct _Data$$1 * this$1);
+int z$$1(struct _Data$$1 * this$1);
+int main();
+/* definitions */
+int f$$1(struct _Data$$1 * this$1)
+{
+  return 20;
+}
+int g$$1(struct _Data$$1 * this$1)
+{
+  return f$$1(this$1);
+}
+int h0$$1(struct _Data$$1 * this$1, int j)
+{
+  return 20;
+}
+int h1$$1(struct _Data$$1 * this$1, int j)
+{
+  return ((*this$1).x + j);
+}
+int y$$1(struct _Data$$1 * this$1)
+{
+  return (*this$1).x;
+}
+int z$$1(struct _Data$$1 * this$1)
+{
+  return g$$1(this$1);
+}
+int main()
+{
+  struct _Data$$1 v$1;
+  int x$1;
+  (x$1 += v$1.x);
+  (x$1 += f$$1((&v$1)));
+  (x$1 += g$$1((&v$1)));
+  (x$1 += h0$$1((&v$1), 20));
+  (x$1 += h1$$1((&v$1), 20));
+  (x$1 += y$$1((&v$1)));
+  (x$1 += z$$1((&v$1)));
+  return x$1;
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test64.out.c
===================================================================
--- gcc/zls/tests/test64.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test64.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,108 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+struct _Data$$1;
+struct _Data$$2;
+struct _Data$$3;
+struct _Data$$4;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+struct _Data$$1 {
+  struct _Data$$2 * _vptr;
+};
+struct _Data$$2 {
+  void (* foo)(struct _Data$$1 * this);
+};
+struct _Data$$3 {
+  struct _Data$$1 parent;
+};
+struct _Data$$4 {
+  struct _Data$$2 parent;
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+void _constructor$$1(struct _Data$$1 * this$1);
+void foo$$1(struct _Data$$1 * this$1);
+void _vtable_init$$1(struct _Data$$2 * _vt$1);
+void init$$1() __attribute__((constructor));
+void _constructor$$2(struct _Data$$3 * this$1);
+void foo$$2(struct _Data$$3 * this$1);
+void _vtable_init$$2(struct _Data$$4 * _vt$1);
+void init$$2() __attribute__((constructor));
+int main();
+/* definitions */
+struct _Data$$2 _vtable$$1;
+void _constructor$$1(struct _Data$$1 * this$1)
+{
+  ((*this$1)._vptr = (&_vtable$$1));
+}
+void foo$$1(struct _Data$$1 * this$1)
+{
+  printf("X\n");
+}
+void _vtable_init$$1(struct _Data$$2 * _vt$1)
+{
+  ((*_vt$1).foo = ((void (*)(struct _Data$$1 * this))((void (*)(struct _Data$$1 * this))foo$$1)));
+}
+void init$$1()
+{
+  _vtable_init$$1((&_vtable$$1));
+}
+struct _Data$$4 _vtable$$2;
+void _constructor$$2(struct _Data$$3 * this$1)
+{
+  ((*((struct _Data$$4 * *)(&(*((struct _Data$$1 *)this$1))._vptr))) = (&_vtable$$2));
+}
+void foo$$2(struct _Data$$3 * this$1)
+{
+  printf("Y\n");
+}
+void _vtable_init$$2(struct _Data$$4 * _vt$1)
+{
+  ((*((struct _Data$$2 *)_vt$1)).foo = ((void (*)(struct _Data$$1 * this))((void (*)(struct _Data$$3 * this))foo$$2)));
+}
+void init$$2()
+{
+  _vtable_init$$1((&_vtable$$2.parent));
+  _vtable_init$$2((&_vtable$$2));
+}
+int main()
+{
+  struct _Data$$1 xo$1;
+  _constructor$$1((&xo$1));
+  struct _Data$$1 * x$1 = (&xo$1);
+  struct _Data$$3 yo$1;
+  _constructor$$2((&yo$1));
+  struct _Data$$3 * y$1 = (&yo$1);
+  (*(*x$1)._vptr).foo(((struct _Data$$1 *)(&(*x$1))));
+  (*((struct _Data$$2 *)(*((struct _Data$$4 * *)(&(*((struct _Data$$1 *)(&(*y$1))))._vptr))))).foo((&(*y$1).parent));
+  struct _Data$$1 * xp$1 = (&(*y$1).parent);
+  (*(*xp$1)._vptr).foo(xp$1);
+}
+/* special */
+/* done */
Index: gcc/zls/tests/prelude.c
===================================================================
--- gcc/zls/tests/prelude.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/prelude.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,353 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* macro sep. c. stuff */
+unsigned _macro_funs_size = 1;
+const char * _macro_funs[1] = {
+  "parse_class"
+};
+unsigned _syntaxes_size = 74;
+struct {const char * str; struct UnmarkedSyntax * syn;} _syntaxes[74] = {
+  {"raw_syntax (name @ body :(public parent_n))", 0},
+  {"syntax name", 0},
+  {"syntax body", 0},
+  {"syntax parent_n", 0},
+  {"syntax {declare_user_type name;}", 0},
+  {"syntax _Data", 0},
+  {"syntax _Data", 0},
+  {"syntax parent", 0},
+  {"syntax parent", 0},
+  {"syntax _VTable", 0},
+  {"syntax _VTable", 0},
+  {"syntax _vtable", 0},
+  {"syntax _vtable", 0},
+  {"syntax _vptr", 0},
+  {"syntax _vptr", 0},
+  {"syntax _constructor", 0},
+  {"syntax _constructor", 0},
+  {"syntax _vtable_init", 0},
+  {"syntax _vtable_init", 0},
+  {"syntax parent_n::_VTable", 0},
+  {"syntax {parent_n parent;}", 0},
+  {"syntax {make_subtype parent_n class_cast_up;}", 0},
+  {"syntax {import parent_n;}", 0},
+  {"raw_syntax (declare_user_type (mid name))", 0},
+  {"raw_syntax ({...} @body)", 0},
+  {"syntax body", 0},
+  {"raw_syntax (what n @_)", 0},
+  {"syntax what", 0},
+  {"syntax n", 0},
+  {"syntax {class _VTable : public $1 {$2;};}", 0},
+  {"syntax {class _VTable {$1;};}", 0},
+  {"syntax {void _vtable_init(_VTable * _vt) {$1;} }", 0},
+  {"syntax _vtable_init", 0},
+  {"syntax {__static_constructor void init() {parent_n::_vtable_init(&_vtable); _vtable_init(&_vtable);}}", 0},
+  {"syntax {__static_constructor void init() {_vtable_init(&_vtable);}}", 0},
+  {"syntax {macro _vptr (:this this = this) {*(_VTable * *)&(((parent_n *)this)->_vptr);}}", 0},
+  {"raw_syntax (var (mid _vptr) (.ptr (mid _VTable)))", 0},
+  {"syntax _vptr", 0},
+  {"syntax {void _constructor() {_vptr = &_vtable;}}", 0},
+  {"syntax _constructor", 0},
+  {"syntax {class _VTable;}", 0},
+  {"syntax _VTable", 0},
+  {"syntax _VTable`outer", 0},
+  {"syntax {struct _Data {$1; $2;};}", 0},
+  {"syntax {finalize_user_type struct _Data;}", 0},
+  {"syntax {_VTable _vtable;}", 0},
+  {"syntax {export $1;}", 0},
+  {"syntax {user_type name {$1; $2;}}", 0},
+  {"raw_syntax (n @rest)", 0},
+  {"syntax static", 0},
+  {"raw_syntax(var (w/inner (mid n) internal) (mid rest))", 0},
+  {"syntax {macro n () {n`internal;}}", 0},
+  {"syntax {macro n (:this this = this) {(*(name *)this)..n;}}", 0},
+  {"raw_syntax (n parms ret body)", 0},
+  {"raw_syntax (@parms)", 0},
+  {"syntax parms", 0},
+  {"syntax static", 0},
+  {"syntax virtual", 0},
+  {"syntax nv", 0},
+  {"syntax n`non_virtual", 0},
+  {"syntax nv", 0},
+  {"syntax n", 0},
+  {"raw_syntax ((.ptr (mid name)) (fluid this))", 0},
+  {"syntax ((name  *)this)", 0},
+  {"syntax parms", 0},
+  {"syntax (:this this = this)", 0},
+  {"raw_syntax (fun (w/inner (mid n) internal) (.(mid $1)) (mid ret) (mid body))", 0},
+  {"syntax {macro nv ($1) {n`internal($2);}}", 0},
+  {"syntax {macro n ($1) {(this->_vptr->n)($2);}}", 0},
+  {"syntax pfun", 0},
+  {"raw_syntax (.ptr (.fun (.(mid $1)) (mid ret)))", 0},
+  {"syntax n", 0},
+  {"raw_syntax (var (mid n) (mid pfun))", 0},
+  {"raw_syntax (assign (-> (id _vt) (id (mid n))) \n                                         (cast (mid pfun) (id (w/inner (mid n) internal))))", 0}
+};
+
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+Mark * new_mark_f(EnvironSnapshot *);
+struct Syntax * syntax_flag(struct Syntax *, struct UnmarkedSyntax *);
+struct SyntaxList * new_syntax_list();
+int syntax_list_empty(struct SyntaxList const *);
+void syntax_list_append(struct SyntaxList *, struct Syntax *);
+struct Syntax * syntax_enum_next(struct SyntaxEnum *);
+struct Match * match(struct Match *, struct UnmarkedSyntax * pattern, struct Syntax * with);
+struct Match * match_args(struct Match *, struct UnmarkedSyntax * pattern, struct Syntax * with);
+struct Match * match_local(struct Match *, ...);
+struct Syntax * match_var(struct Match *, struct UnmarkedSyntax *);
+struct SyntaxEnum * match_varl(struct Match *, struct UnmarkedSyntax *);
+struct Syntax * replace(struct UnmarkedSyntax *, struct Match *, Mark *);
+Context * get_context(struct Syntax *);
+struct Syntax * replace_context(struct UnmarkedSyntax *, Context *);
+struct Syntax * partly_expand(struct Syntax *, Position pos, Environ *);
+struct SyntaxEnum * partly_expand_list(struct SyntaxEnum *, Position pos, Environ *);
+struct Syntax * pre_parse(struct Syntax *, Environ *);
+struct Syntax * reparse(struct Syntax *, char const *, Environ *);
+struct UnmarkedSyntax * string_to_syntax(char const * str);
+char const * syntax_to_string(struct UnmarkedSyntax *);
+void dump_syntax(struct UnmarkedSyntax *);
+struct UserTypeInfo * user_type_info(struct Syntax *, Environ *);
+struct ModuleInfo * user_type_module(struct UserTypeInfo *);
+struct ModuleInfo * module_info(struct Syntax *, Environ *);
+struct SyntaxEnum * module_symbols(struct ModuleInfo *);
+bool module_have_symbol(struct ModuleInfo *, struct Syntax *);
+Environ * temp_environ(Environ *);
+size_t ct_value(struct Syntax *, Environ *);
+struct Syntax * error(struct Syntax *, char const *, ...);
+struct Syntax * get_symbol_prop(struct Syntax * sym, struct Syntax * prop, Environ * env);
+int symbol_exists(struct UnmarkedSyntax * sym, struct Syntax * where, Mark *, Environ *);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+void parse_class_var(struct Syntax * p, struct Match * m, Mark * mark, struct SyntaxList * struct_b, struct SyntaxList * module_b);
+void parse_class_fun(struct Syntax * p, struct Match * m, Mark * mark, struct SyntaxList * struct_b, struct SyntaxList * module_b, struct UserTypeInfo * parent_vtable, struct SyntaxList * vtable_b, struct SyntaxList * vtable_i, Environ * env);
+/* definitions */
+struct EnvironSnapshot * parse_class$env_ss;
+struct Syntax * parse_class(struct Syntax * p, Environ * env)
+{
+  Mark * mark$1 = new_mark_f(parse_class$env_ss);
+  struct Match * m$1 = match_args(0, _syntaxes[0].syn, p);
+  struct Syntax * name$1 = match_var(m$1, _syntaxes[1].syn);
+  struct Syntax * body$1 = match_var(m$1, _syntaxes[2].syn);
+  struct Syntax * parent_s$1 = match_var(m$1, _syntaxes[3].syn);
+  if ((!body$1))
+    {
+      return replace(_syntaxes[4].syn, m$1, mark$1);
+    }
+  struct UserTypeInfo * parent$1 = (((int)parent_s$1) ? user_type_info(parent_s$1, env) : 0);
+  Context * context$1 = get_context(name$1);
+  struct ModuleInfo * parent_m$1 = 0;
+  struct UserTypeInfo * parent_vtable$1 = 0;
+  struct Syntax * parent_vtable_n$1 = 0;
+  struct Syntax * vtable$1 = 0;
+  struct SyntaxList * struct_p$1 = new_syntax_list();
+  struct SyntaxList * struct_b$1 = new_syntax_list();
+  struct SyntaxList * module_p$1 = new_syntax_list();
+  struct SyntaxList * module_b$1 = new_syntax_list();
+  struct SyntaxList * vtable_b$1 = new_syntax_list();
+  struct SyntaxList * vtable_i$1 = new_syntax_list();
+  struct SyntaxList * exports$1 = new_syntax_list();
+  (m$1 = match(m$1, _syntaxes[5].syn, replace_context(_syntaxes[6].syn, context$1)));
+  (m$1 = match(m$1, _syntaxes[7].syn, replace_context(_syntaxes[8].syn, context$1)));
+  (m$1 = match(m$1, _syntaxes[9].syn, replace_context(_syntaxes[10].syn, context$1)));
+  (m$1 = match(m$1, _syntaxes[11].syn, replace_context(_syntaxes[12].syn, context$1)));
+  (m$1 = match(m$1, _syntaxes[13].syn, replace_context(_syntaxes[14].syn, context$1)));
+  (m$1 = match(m$1, _syntaxes[15].syn, replace_context(_syntaxes[16].syn, context$1)));
+  (m$1 = match(m$1, _syntaxes[17].syn, replace_context(_syntaxes[18].syn, context$1)));
+  if (((int)parent$1))
+    {
+      (parent_m$1 = user_type_module(parent$1));
+      (parent_vtable_n$1 = replace(_syntaxes[19].syn, m$1, mark$1));
+      (parent_vtable$1 = user_type_info(parent_vtable_n$1, env));
+      syntax_list_append(struct_p$1, replace(_syntaxes[20].syn, m$1, mark$1));
+      syntax_list_append(module_p$1, replace(_syntaxes[21].syn, m$1, mark$1));
+      syntax_list_append(module_p$1, replace(_syntaxes[22].syn, m$1, mark$1));
+      struct SyntaxEnum * itr$1 = module_symbols(parent_m$1);
+      struct Syntax * syn$1;
+      {
+        __label__ break$1;
+        __label__ continue$1;
+      continue$1:;
+        if ((!(syn$1 = syntax_enum_next(itr$1))))
+          goto break$1;
+        {
+          syntax_list_append(exports$1, syn$1);
+        }
+        goto continue$1;
+      break$1:;
+      }
+    }
+  Environ * lenv$1 = temp_environ(env);
+  pre_parse(replace(_syntaxes[23].syn, m$1, mark$1), lenv$1);
+  struct SyntaxEnum * itr$1 = partly_expand_list(match_varl(match(0, _syntaxes[24].syn, body$1), _syntaxes[25].syn), FieldPos, lenv$1);
+  struct Syntax * member$1;
+  {
+    __label__ break$1;
+    __label__ continue$1;
+  continue$1:;
+    if ((!(member$1 = syntax_enum_next(itr$1))))
+      goto break$1;
+    {
+      struct Match * m0$1 = match(m$1, _syntaxes[26].syn, member$1);
+      char const * what$1 = syntax_to_string(((struct UnmarkedSyntax *)match_var(m0$1, _syntaxes[27].syn)));
+      if ((strcmp(what$1, "label") == 0))
+        goto continue$1;
+      if ((strcmp(what$1, "var") == 0))
+        parse_class_var(member$1, m$1, mark$1, struct_b$1, module_b$1);
+      else
+        if ((strcmp(what$1, "fun") == 0))
+          parse_class_fun(member$1, m$1, mark$1, struct_b$1, module_b$1, parent_vtable$1, vtable_b$1, vtable_i$1, lenv$1);
+        else
+          syntax_list_append(module_p$1, pre_parse(member$1, lenv$1));
+      syntax_list_append(exports$1, match_var(m0$1, _syntaxes[28].syn));
+    }
+    goto continue$1;
+  break$1:;
+  }
+  bool const need_vtable$1 = (!syntax_list_empty(vtable_i$1));
+  if (need_vtable$1)
+    {
+      if (((int)parent_vtable$1))
+        {
+          (vtable$1 = replace(_syntaxes[29].syn, match_local(m$1, parent_vtable_n$1, vtable_b$1, 0), mark$1));
+        }
+      else
+        {
+          (vtable$1 = replace(_syntaxes[30].syn, match_local(m$1, vtable_b$1, 0), mark$1));
+        }
+      syntax_list_append(module_b$1, replace(_syntaxes[31].syn, match_local(m$1, vtable_i$1, 0), mark$1));
+      syntax_list_append(exports$1, replace(_syntaxes[32].syn, m$1, mark$1));
+      if (((int)parent_vtable$1))
+        {
+          syntax_list_append(module_b$1, replace(_syntaxes[33].syn, m$1, mark$1));
+        }
+      else
+        {
+          syntax_list_append(module_b$1, replace(_syntaxes[34].syn, m$1, mark$1));
+        }
+      if (((int)parent_vtable$1))
+        {
+          syntax_list_append(module_b$1, replace(_syntaxes[35].syn, m$1, mark$1));
+        }
+      else
+        {
+          struct Syntax * v$1 = replace(_syntaxes[36].syn, m$1, mark$1);
+          parse_class_var(v$1, m$1, mark$1, struct_p$1, module_b$1);
+        }
+      syntax_list_append(exports$1, replace(_syntaxes[37].syn, m$1, mark$1));
+      struct Syntax * f$1 = partly_expand(replace(_syntaxes[38].syn, m$1, mark$1), FieldPos, env);
+      parse_class_fun(f$1, m$1, mark$1, struct_p$1, module_p$1, 0, vtable_b$1, vtable_i$1, env);
+      syntax_list_append(exports$1, replace(_syntaxes[39].syn, m$1, mark$1));
+    }
+  if (need_vtable$1)
+    {
+      syntax_list_append(module_p$1, replace(_syntaxes[40].syn, m$1, mark$1));
+      syntax_list_append(exports$1, replace(_syntaxes[41].syn, m$1, mark$1));
+      syntax_list_append(exports$1, replace(_syntaxes[42].syn, m$1, mark$1));
+    }
+  syntax_list_append(module_p$1, replace(_syntaxes[43].syn, match_local(m$1, struct_p$1, struct_b$1, 0), mark$1));
+  syntax_list_append(module_p$1, replace(_syntaxes[44].syn, m$1, mark$1));
+  if (need_vtable$1)
+    {
+      syntax_list_append(module_p$1, vtable$1);
+      syntax_list_append(module_p$1, replace(_syntaxes[45].syn, m$1, mark$1));
+    }
+  syntax_list_append(module_b$1, replace(_syntaxes[46].syn, match_local(m$1, exports$1, 0), mark$1));
+  struct Syntax * module_$1 = replace(_syntaxes[47].syn, match_local(m$1, module_p$1, module_b$1, 0), mark$1);
+  return module_$1;
+}
+void parse_class_var(struct Syntax * p, struct Match * m, Mark * mark, struct SyntaxList * struct_b, struct SyntaxList * module_b)
+{
+  (m = match_args(m, _syntaxes[48].syn, p));
+  bool is_static$1 = ((bool)syntax_flag(p, _syntaxes[49].syn));
+  if (is_static$1)
+    {
+      syntax_list_append(module_b, replace(_syntaxes[50].syn, m, mark));
+      syntax_list_append(module_b, replace(_syntaxes[51].syn, m, mark));
+    }
+  else
+    {
+      syntax_list_append(struct_b, p);
+      syntax_list_append(module_b, replace(_syntaxes[52].syn, m, mark));
+    }
+}
+void parse_class_fun(struct Syntax * p, struct Match * m, Mark * mark, struct SyntaxList * struct_b, struct SyntaxList * module_b, struct UserTypeInfo * parent_vtable, struct SyntaxList * vtable_b, struct SyntaxList * vtable_i, Environ * env)
+{
+  (m = match_args(m, _syntaxes[53].syn, p));
+  (m = match_args(m, _syntaxes[54].syn, match_var(m, _syntaxes[55].syn)));
+  bool is_static$1 = ((bool)syntax_flag(p, _syntaxes[56].syn));
+  bool is_virtual$1 = ((bool)syntax_flag(p, _syntaxes[57].syn));
+  if (is_virtual$1)
+    (m = match(m, _syntaxes[58].syn, replace(_syntaxes[59].syn, m, mark)));
+  else
+    (m = match(m, _syntaxes[60].syn, replace(_syntaxes[61].syn, m, mark)));
+  struct SyntaxList * new_parms$1 = new_syntax_list();
+  if ((!is_static$1))
+    syntax_list_append(new_parms$1, replace(_syntaxes[62].syn, m, mark));
+  struct SyntaxList * macro_parms$1 = new_syntax_list();
+  struct SyntaxList * call_parms$1 = new_syntax_list();
+  if ((!is_static$1))
+    syntax_list_append(call_parms$1, replace(_syntaxes[63].syn, m, mark));
+  struct SyntaxEnum * parms_enum$1 = match_varl(m, _syntaxes[64].syn);
+  unsigned int i$1 = 0u;
+  struct Syntax * parm$1;
+  {
+    __label__ break$1;
+    __label__ continue$1;
+  continue$1:;
+    if ((!(parm$1 = syntax_enum_next(parms_enum$1))))
+      goto break$1;
+    {
+      syntax_list_append(new_parms$1, parm$1);
+      char sbuf$1[8];
+      snprintf(sbuf$1, ((size_t)8), "arg%d", i$1);
+      struct Syntax * arg$1 = replace(string_to_syntax(sbuf$1), 0, mark);
+      syntax_list_append(macro_parms$1, arg$1);
+      syntax_list_append(call_parms$1, arg$1);
+      (i$1 += ((unsigned int)1));
+    }
+    goto continue$1;
+  break$1:;
+  }
+  if ((!is_static$1))
+    syntax_list_append(macro_parms$1, replace(_syntaxes[65].syn, m, mark));
+  syntax_list_append(module_b, replace(_syntaxes[66].syn, match_local(m, new_parms$1, 0), mark));
+  syntax_list_append(module_b, replace(_syntaxes[67].syn, match_local(m, macro_parms$1, call_parms$1, 0), mark));
+  if (is_virtual$1)
+    {
+      syntax_list_append(module_b, replace(_syntaxes[68].syn, match_local(m, macro_parms$1, call_parms$1, 0), mark));
+      (m = match(m, _syntaxes[69].syn, replace(_syntaxes[70].syn, match_local(m, new_parms$1, 0), mark)));
+      if ((!(((int)parent_vtable) ? module_have_symbol(user_type_module(parent_vtable), match_var(m, _syntaxes[71].syn)) : 0)))
+        {
+          syntax_list_append(vtable_b, replace(_syntaxes[72].syn, m, mark));
+        }
+      syntax_list_append(vtable_i, replace(_syntaxes[73].syn, m, mark));
+    }
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test49.out.c
===================================================================
--- gcc/zls/tests/test49.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test49.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,73 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+struct _Data$$1;
+struct _Data$$2;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+struct _Data$$1 {
+  int x_;
+};
+struct _Data$$2 {
+  struct _Data$$1 parent;
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int foo$$1();
+int bar$$1();
+int main();
+/* definitions */
+static int x$$1;
+int foo$$1()
+{
+  return x$$1;
+}
+static int y$$1;
+int bar$$1()
+{
+  return y$$1;
+}
+int main()
+{
+  x$$1;
+  x$$1;
+  y$$1;
+  foo$$1();
+  foo$$1();
+  bar$$1();
+  struct _Data$$1 x$1;
+  x$$1;
+  foo$$1();
+  struct _Data$$2 y$1;
+  x$$1;
+  y$$1;
+  foo$$1();
+  bar$$1();
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test68.out.c
===================================================================
--- gcc/zls/tests/test68.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test68.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,43 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main();
+/* definitions */
+static int const X$$1 = 2;
+static int const Y$$1 = 4;
+static int const SIZE$$1 = 6;
+int main()
+{
+  int x$1[6];
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test2.out.c
===================================================================
--- gcc/zls/tests/test2.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test2.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,45 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+typedef int const * const INTP;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main();
+/* definitions */
+int i;
+INTP const x = (&i);
+int y[9];
+int main()
+{
+  (*(x + 4));
+  (*(y + 3));
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test6.out.c
===================================================================
--- gcc/zls/tests/test6.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test6.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,43 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main();
+/* definitions */
+int main()
+{
+  int X$1;
+  (X$1 ++);
+  (X$1 += 1);
+  (X$1 -= 1);
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test30.out.zls
===================================================================
--- gcc/zls/tests/test30.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test30.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,70 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+(.struct S)
+(.struct T$$1)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+(.struct S
+  ((int) mine)
+  ((int) priv)
+  ((int) priv$1)
+)
+(.struct T$$1
+  ((int) mine)
+  ((int) priv)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun init_s (. ((.ptr (struct S)) s$1)) (void))
+(fun use_s (. ((struct S) s$1)) (void))
+(fun main (.) (int))
+# definitions
+(fun init_s (. ((.ptr (struct S)) s$1)) (void) (block
+  (assign (member (deref s$1) mine) 0)
+  (assign (member (deref s$1) priv) 0)
+  (assign (member (deref s$1) priv$1) 20)
+)
+)
+(fun use_s (. ((struct S) s$1)) (void) (block
+  (plus (plus (member s$1 mine) (member s$1 priv)) (member s$1 priv$1))
+)
+)
+(fun main (.) (int) (block
+  (var s$1 (struct S))
+  (call init_s (. (addrof s$1)))
+  (call use_s (. s$1))
+  (plus (member s$1 mine) (member s$1 priv$1))
+  (plus (member s$1 mine) (member s$1 priv))
+  (var t$1 (struct T$$1))
+  (plus (member t$1 mine) (member t$1 priv))
+  (plus (member t$1 mine) (member t$1 priv))
+)
+)
+# special
+# done
Index: gcc/zls/tests/test31.out.zls
===================================================================
--- gcc/zls/tests/test31.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test31.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,47 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun f (. ((int) x) ((int) y)) (int))
+(fun main (.) (int))
+# definitions
+(fun f (. ((int) x) ((int) y)) (int) (block
+  (return (plus x y))
+)
+)
+(fun main (.) (int) (block
+  (call f (. 1 2))
+  (plus 1 (call f (. 1 2)))
+  (plus (call f (. 1 2)) 1)
+)
+)
+# special
+# done
Index: gcc/zls/tests/test32.out.zls
===================================================================
--- gcc/zls/tests/test32.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test32.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,55 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun f (. ((int) x)) (int))
+(fun g (. ((int) x)) (int))
+(fun h (. ((int) x)) (int))
+(fun main (.) (int))
+# definitions
+(fun f (. ((int) x)) (int) (block
+  (var y$1 (int))
+)
+)
+(fun g (. ((int) x)) (int) (block
+  (var y$1 (int))
+)
+)
+(fun h (. ((int) x)) (int) (block
+  (var y$1 (int))
+)
+)
+(fun main (.) (int) (block
+  (noop)
+)
+)
+# special
+# done
Index: gcc/zls/tests/test33.out.zls
===================================================================
--- gcc/zls/tests/test33.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test33.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,56 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+(.enum E)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+(.enum E
+   (X$1 0)
+   (Y$1 1)
+   (Z 2)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun foo$$1 (.) (enum E))
+(fun f (.) (int))
+(fun main (.) (int))
+# definitions
+(fun foo$$1 (.) (enum E) (block
+  (return (plus (plus X$1 Y$1) Z))
+)
+)
+(fun f (.) (int) (block
+  (return (cast (int) (call foo$$1 (.))))
+)
+)
+(fun main (.) (int) (block
+  (return (plus (call f (.)) (cast (int) Z)))
+)
+)
+# special
+# done
Index: gcc/zls/tests/test34.out.zls
===================================================================
--- gcc/zls/tests/test34.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test34.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,43 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+(talias X (int))
+(talias Y (int))
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (.) (int))
+# definitions
+(fun main (.) (int) (block
+  (var y$1 (Y) 20)
+  (return y$1)
+)
+)
+# special
+# done
Index: gcc/zls/tests/test35.out.zls
===================================================================
--- gcc/zls/tests/test35.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test35.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,46 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (.) (int))
+# definitions
+(fun main (.) (int) (block
+(label label$$1)
+  (if 1
+    (goto label$$2)
+    (goto label$$1)
+  )
+(label label$$2)
+  (return 10)
+)
+)
+# special
+# done
Index: gcc/zls/tests/test36.out.zls
===================================================================
--- gcc/zls/tests/test36.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test36.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,48 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (.) (int))
+# definitions
+(var y (int) 30)
+(fun main (.) (int) (block
+  (var x$1 (int))
+  (var y$1 (int))
+  (var z$1 (int))
+  (var x$2 (int) (plus x$1 y))
+  (assign z$1 (times x$2 x$2))
+  (var x$3 (int) (plus z$1 y))
+  (assign z$1 (times x$3 x$3))
+  (return z$1)
+)
+)
+# special
+# done
Index: gcc/zls/tests/test37.out.zls
===================================================================
--- gcc/zls/tests/test37.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test37.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,62 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (.) (int))
+# definitions
+(fun main (.) (int) (block
+  (var z$1 (int) 20)
+  (block
+    (assign z$1 40)
+    (block
+      (call printf (. (s "%d") z$1))
+    )
+    (block
+      (var z$2 (int) 50)
+      (block
+        (call printf (. (s "%d") z$2))
+      )
+    )
+    (block
+      (var z$2 (int) 60)
+      (block
+        (call printf (. (s "%d") z$1))
+      )
+    )
+    (block
+      (call printf (. (s "%d") z$1))
+    )
+  )
+  (assign z$1 60)
+)
+)
+# special
+# done
Index: gcc/zls/tests/test38.out.zls
===================================================================
--- gcc/zls/tests/test38.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test38.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,46 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (.) (int))
+# definitions
+(fun main (.) (int) (block
+  30
+  30
+  30
+  20
+  20
+  (plus 10 20)
+  (plus 10 30)
+)
+)
+# special
+# done
Index: gcc/zls/tests/test39.out.zls
===================================================================
--- gcc/zls/tests/test39.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test39.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,56 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+(.struct X$$1)
+(.struct X$$2)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+(.struct X$$1
+  ((int) x)
+  ((int) y)
+)
+(.struct X$$2
+  ((int) x)
+  ((int) y)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (.) (int))
+(fun main2 (.) (int))
+# definitions
+(var x$$1 (int) :static 10)
+(var x$$2 (int) :static 20)
+(fun main (.) (int) (block
+)
+)
+(var x$$3 (int) :static 20)
+(fun main2 (.) (int) (block
+)
+)
+# special
+# done
Index: gcc/zls/tests/test12.out.c
===================================================================
--- gcc/zls/tests/test12.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test12.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,43 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main();
+/* definitions */
+int main()
+{
+  int z$1 = ({
+    int x$1 = 0;
+    x$1;
+  });
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test31.out.c
===================================================================
--- gcc/zls/tests/test31.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test31.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,47 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int f(int x, int y);
+int main();
+/* definitions */
+int f(int x, int y)
+{
+  return (x + y);
+}
+int main()
+{
+  f(1, 2);
+  (1 + f(1, 2));
+  (f(1, 2) + 1);
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test50.out.c
===================================================================
--- gcc/zls/tests/test50.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test50.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,109 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+struct _Data$$1;
+struct _Data$$2;
+struct _Data$$3;
+struct _Data$$4;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+struct _Data$$1 {
+  struct _Data$$2 * _vptr;
+  int x_;
+};
+struct _Data$$2 {
+  void (* foo)(struct _Data$$1 * this);
+};
+struct _Data$$3 {
+  struct _Data$$1 parent;
+  int y_;
+};
+struct _Data$$4 {
+  struct _Data$$2 parent;
+  void (* bar)(struct _Data$$3 * this);
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+void _constructor$$1(struct _Data$$1 * this$1);
+void foo$$1(struct _Data$$1 * this$1);
+void _vtable_init$$1(struct _Data$$2 * _vt$1);
+void init$$1() __attribute__((constructor));
+void _constructor$$2(struct _Data$$3 * this$1);
+void bar$$1(struct _Data$$3 * this$1);
+void _vtable_init$$2(struct _Data$$4 * _vt$1);
+void init$$2() __attribute__((constructor));
+int main();
+/* definitions */
+struct _Data$$2 _vtable$$1;
+void _constructor$$1(struct _Data$$1 * this$1)
+{
+  ((*this$1)._vptr = (&_vtable$$1));
+}
+void foo$$1(struct _Data$$1 * this$1)
+{
+  printf("foo\n");
+}
+void _vtable_init$$1(struct _Data$$2 * _vt$1)
+{
+  ((*_vt$1).foo = ((void (*)(struct _Data$$1 * this))((void (*)(struct _Data$$1 * this))foo$$1)));
+}
+void init$$1()
+{
+  _vtable_init$$1((&_vtable$$1));
+}
+struct _Data$$4 _vtable$$2;
+void _constructor$$2(struct _Data$$3 * this$1)
+{
+  ((*((struct _Data$$4 * *)(&(*((struct _Data$$1 *)this$1))._vptr))) = (&_vtable$$2));
+}
+void bar$$1(struct _Data$$3 * this$1)
+{
+  printf("bar\n");
+}
+void _vtable_init$$2(struct _Data$$4 * _vt$1)
+{
+  ((*_vt$1).bar = ((void (*)(struct _Data$$3 * this))((void (*)(struct _Data$$3 * this))bar$$1)));
+}
+void init$$2()
+{
+  _vtable_init$$1((&_vtable$$2.parent));
+  _vtable_init$$2((&_vtable$$2));
+}
+int main()
+{
+  struct _Data$$1 x$1;
+  _constructor$$1((&x$1));
+  x$1.x_;
+  (*x$1._vptr).foo(((struct _Data$$1 *)(&x$1)));
+  struct _Data$$3 y$1;
+  _constructor$$2((&y$1));
+  (*((struct _Data$$2 *)(*((struct _Data$$4 * *)(&(*((struct _Data$$1 *)(&y$1)))._vptr))))).foo(((struct _Data$$1 *)(&y$1)));
+  (*(*((struct _Data$$4 * *)(&(*((struct _Data$$1 *)(&y$1)))._vptr)))).bar((&y$1));
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test16.out.c
===================================================================
--- gcc/zls/tests/test16.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test16.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,42 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int f(int x, int y, ...);
+int main();
+/* definitions */
+int main()
+{
+  f(1, 2);
+  f(1, 2, 3, 4);
+}
+/* special */
+/* done */
Index: gcc/zls/tests/run-tests.sh
===================================================================
--- gcc/zls/tests/run-tests.sh	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/run-tests.sh	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,12 @@
+#!/bin/sh
+
+for zls in *.zls;
+do
+  b=`basename $zls .zls`
+  c=$b.c
+  zls -O -S $c
+  mv $b.s $c.s
+  zls -O -S $zls
+  mv $b.s $zls.s
+  diff -I "\.file" -u $c.s $zls.s
+done

Property changes on: gcc/zls/tests/run-tests.sh
___________________________________________________________________
Name: svn:executable
   + *

Index: gcc/zls/tests/test35.out.c
===================================================================
--- gcc/zls/tests/test35.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test35.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,46 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main();
+/* definitions */
+int main()
+{
+label$$1:;
+  if (1)
+    goto label$$2;
+  else
+    goto label$$1;
+label$$2:;
+  return 10;
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test54.out.c
===================================================================
--- gcc/zls/tests/test54.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test54.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,67 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+struct D$$1;
+struct _Data$$1;
+struct _Data$$2;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+struct D$$1 {
+  int x;
+};
+struct _Data$$1 {
+  int x;
+};
+struct _Data$$2 {
+  struct D$$1 d;
+  struct _Data$$1 c;
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+struct D$$1 get_d$$1(struct _Data$$2 * this$1);
+struct _Data$$1 get_c$$1(struct _Data$$2 * this$1);
+struct _Data$$2 make_x$$1(struct _Data$$2 * this$1);
+/* definitions */
+struct D$$1 get_d$$1(struct _Data$$2 * this$1)
+{
+  return (*this$1).d;
+}
+struct _Data$$1 get_c$$1(struct _Data$$2 * this$1)
+{
+  return (*this$1).c;
+}
+struct _Data$$2 make_x$$1(struct _Data$$2 * this$1)
+{
+  struct _Data$$2 x$1;
+  return x$1;
+}
+struct D$$1 d;
+struct _Data$$1 c;
+struct _Data$$2 x;
+/* special */
+/* done */
Index: gcc/zls/tests/test73.out.c
===================================================================
--- gcc/zls/tests/test73.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test73.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,41 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main();
+/* definitions */
+int main()
+{
+  int x$1 = 1;
+  return (x$1 + 2);
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test39.out.c
===================================================================
--- gcc/zls/tests/test39.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test39.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,56 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+struct X$$1;
+struct X$$2;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+struct X$$1 {
+  int x;
+  int y;
+};
+struct X$$2 {
+  int x;
+  int y;
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main();
+int main2();
+/* definitions */
+static int x$$1 = 10;
+static int x$$2 = 20;
+int main()
+{
+}
+static int x$$3 = 20;
+int main2()
+{
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test58.out.c
===================================================================
--- gcc/zls/tests/test58.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test58.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,44 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+struct X;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+struct X {
+  int x;
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main();
+/* definitions */
+int main()
+{
+  0;
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test77.out.c
===================================================================
--- gcc/zls/tests/test77.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test77.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,46 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+struct _Data$$1;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+struct _Data$$1 {
+  int x;
+  int y;
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main();
+/* definitions */
+int main()
+{
+  struct _Data$$1 c$1;
+  (c$1.x = 20);
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test40.out.zls
===================================================================
--- gcc/zls/tests/test40.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test40.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,56 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+(talias INT$$1 (int))
+(talias INT0$$1 (int))
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun foo$$1 (.) (int))
+(fun foo0$$1 (.) (int))
+(fun main (.) (int))
+# definitions
+(var x$$1 (int) 10)
+(fun foo$$1 (.) (int) (block
+  (return x$$1)
+)
+)
+(var y$$1 (INT$$1) :static)
+(var x0$$1 (int) 20)
+(fun foo0$$1 (.) (int) (block
+  (return y$$1)
+)
+)
+(fun main (.) (int) (block
+  (var z$1 (INT0$$1) x$$1)
+  (return (plus (plus (plus x0$$1 (call foo0$$1 (.))) x$$1) (call foo$$1 (.))))
+)
+)
+# special
+# done
Index: gcc/zls/tests/test41.out.zls
===================================================================
--- gcc/zls/tests/test41.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test41.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,45 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (.) (int))
+# definitions
+(var z$$1 (int) 20)
+(var x$$1 (int) 20)
+(var priv$$1 (int) 30)
+(fun main (.) (int) (block
+  (call printf (. (s "%d %d %d %d\n") z$$1 x$$1 priv$$1 x$$1))
+  (call printf (. (s "%d %d %d\n") z$$1 x$$1 priv$$1))
+  (return x$$1)
+)
+)
+# special
+# done
Index: gcc/zls/tests/test42.out.zls
===================================================================
--- gcc/zls/tests/test42.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test42.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,43 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (.) (int))
+# definitions
+(fun main (.) (int) (block
+  (var x$1 (int) 20)
+  (var x$2 (int) 30)
+  (assign x$1 x$2)
+  (return x$1)
+)
+)
+# special
+# done
Index: gcc/zls/tests/test43.out.zls
===================================================================
--- gcc/zls/tests/test43.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test43.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,46 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+(.struct Foo)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+(.struct Foo
+  ((int) x)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (.) (int))
+# definitions
+(fun main (.) (int) (block
+  (var foo$1 (struct Foo))
+  (member foo$1 x)
+  (member foo$1 x)
+)
+)
+# special
+# done
Index: gcc/zls/tests/test44.out.zls
===================================================================
--- gcc/zls/tests/test44.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test44.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,56 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun g$$1 (.) (void))
+(fun f$$1 (.) (void))
+(fun h$$1 (.) (void))
+(fun main (.) (int))
+# definitions
+(fun g$$1 (.) (void) (block
+  (call f$$1 (.))
+)
+)
+(fun f$$1 (.) (void) (block
+  (noop)
+)
+)
+(fun h$$1 (.) (void) (block
+  (call f$$1 (.))
+)
+)
+(fun main (.) (int) (block
+  (call g$$1 (.))
+  (call h$$1 (.))
+)
+)
+# special
+# done
Index: gcc/zls/tests/test45.out.zls
===================================================================
--- gcc/zls/tests/test45.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test45.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,83 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+(.struct _Data$$1)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+(.struct _Data$$1
+  ((int) x)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun f$$1 (. ((.ptr (struct _Data$$1)) this$1)) (int))
+(fun g$$1 (. ((.ptr (struct _Data$$1)) this$1)) (int))
+(fun h0$$1 (. ((.ptr (struct _Data$$1)) this$1) ((int) j)) (int))
+(fun h1$$1 (. ((.ptr (struct _Data$$1)) this$1) ((int) j)) (int))
+(fun y$$1 (. ((.ptr (struct _Data$$1)) this$1)) (int))
+(fun z$$1 (. ((.ptr (struct _Data$$1)) this$1)) (int))
+(fun main (.) (int))
+# definitions
+(fun f$$1 (. ((.ptr (struct _Data$$1)) this$1)) (int) (block
+  (return 20)
+)
+)
+(fun g$$1 (. ((.ptr (struct _Data$$1)) this$1)) (int) (block
+  (return (call f$$1 (. this$1)))
+)
+)
+(fun h0$$1 (. ((.ptr (struct _Data$$1)) this$1) ((int) j)) (int) (block
+  (return 20)
+)
+)
+(fun h1$$1 (. ((.ptr (struct _Data$$1)) this$1) ((int) j)) (int) (block
+  (return (plus (member (deref this$1) x) j))
+)
+)
+(fun y$$1 (. ((.ptr (struct _Data$$1)) this$1)) (int) (block
+  (return (member (deref this$1) x))
+)
+)
+(fun z$$1 (. ((.ptr (struct _Data$$1)) this$1)) (int) (block
+  (return (call g$$1 (. this$1)))
+)
+)
+(fun main (.) (int) (block
+  (var v$1 (struct _Data$$1))
+  (var x$1 (int))
+  (c-assign plus x$1 (member v$1 x))
+  (c-assign plus x$1 (call f$$1 (. (addrof v$1))))
+  (c-assign plus x$1 (call g$$1 (. (addrof v$1))))
+  (c-assign plus x$1 (call h0$$1 (. (addrof v$1) 20)))
+  (c-assign plus x$1 (call h1$$1 (. (addrof v$1) 20)))
+  (c-assign plus x$1 (call y$$1 (. (addrof v$1))))
+  (c-assign plus x$1 (call z$$1 (. (addrof v$1))))
+  (return x$1)
+)
+)
+# special
+# done
Index: gcc/zls/tests/test47.out.zls
===================================================================
--- gcc/zls/tests/test47.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test47.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,88 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+(.struct _Data$$1)
+(.struct _Data$$2)
+(.struct _Data$$3)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+(.struct _Data$$1
+  ((int) x)
+  ((int) y)
+)
+(.struct _Data$$2
+  ((struct _Data$$1) parent)
+  ((int) z)
+)
+(.struct _Data$$3
+  ((struct _Data$$2) parent)
+  ((int) z2)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun foo_p (. ((.ptr (struct _Data$$1)) p)) (void))
+(fun foo_c (. ((.ptr (struct _Data$$2)) p)) (void))
+(fun foo_s (. ((.ptr (struct _Data$$3)) p)) (void))
+(fun main (.) (int))
+# definitions
+(fun foo_p (. ((.ptr (struct _Data$$1)) p)) (void) (block
+  (noop)
+)
+)
+(fun foo_c (. ((.ptr (struct _Data$$2)) p)) (void) (block
+  (noop)
+)
+)
+(fun foo_s (. ((.ptr (struct _Data$$3)) p)) (void) (block
+  (noop)
+)
+)
+(fun main (.) (int) (block
+  (var p$1 (struct _Data$$1))
+  (call foo_p (. (addrof p$1)))
+  (var c$1 (struct _Data$$2))
+  (call foo_c (. (addrof c$1)))
+  (call foo_p (. (addrof (member c$1 parent))))
+  (var s$1 (struct _Data$$3))
+  (call foo_s (. (addrof s$1)))
+  (call foo_c (. (addrof (member s$1 parent))))
+  (call foo_p (. (addrof (member (member s$1 parent) parent))))
+  (member p$1 x)
+  (member p$1 y)
+  (member c$1 z)
+  (member (deref (cast (.ptr (struct _Data$$1)) (addrof c$1))) x)
+  (member (deref (cast (.ptr (struct _Data$$1)) (addrof c$1))) y)
+  (member s$1 z2)
+  (member (deref (cast (.ptr (struct _Data$$2)) (addrof s$1))) z)
+  (member (deref (cast (.ptr (struct _Data$$1)) (addrof s$1))) x)
+  (member (deref (cast (.ptr (struct _Data$$1)) (addrof s$1))) y)
+  (return 0)
+)
+)
+# special
+# done
Index: gcc/zls/tests/test48.out.zls
===================================================================
--- gcc/zls/tests/test48.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test48.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,135 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+(.struct _Data$$1)
+(.struct _Data$$2)
+(.struct _Data$$3)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+(.struct _Data$$1
+  ((int) x)
+  ((int) y)
+)
+(.struct _Data$$2
+  ((struct _Data$$1) parent)
+  ((int) z)
+)
+(.struct _Data$$3
+  ((struct _Data$$2) parent)
+  ((int) z2)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun f0$$1 (. ((.ptr (struct _Data$$1)) this$1)) (int))
+(fun f1$$1 (. ((.ptr (struct _Data$$2)) this$1)) (int))
+(fun f2$$1 (. ((.ptr (struct _Data$$2)) this$1)) (int))
+(fun f3$$1 (. ((.ptr (struct _Data$$2)) this$1)) (int))
+(fun f4$$1 (. ((.ptr (struct _Data$$3)) this$1)) (int))
+(fun f5$$1 (. ((.ptr (struct _Data$$3)) this$1)) (int))
+(fun f6$$1 (. ((.ptr (struct _Data$$3)) this$1)) (int))
+(fun foo_p (. ((.ptr (struct _Data$$1)) p)) (void))
+(fun foo_c (. ((.ptr (struct _Data$$2)) p)) (void))
+(fun foo_s (. ((.ptr (struct _Data$$3)) p)) (void))
+(fun main (.) (int))
+# definitions
+(fun f0$$1 (. ((.ptr (struct _Data$$1)) this$1)) (int) (block
+  (return (member (deref this$1) x))
+)
+)
+(fun f1$$1 (. ((.ptr (struct _Data$$2)) this$1)) (int) (block
+  (return (member (deref this$1) z))
+)
+)
+(fun f2$$1 (. ((.ptr (struct _Data$$2)) this$1)) (int) (block
+  (return (plus (member (deref this$1) z) (call f0$$1 (. (cast (.ptr (struct _Data$$1)) this$1)))))
+)
+)
+(fun f3$$1 (. ((.ptr (struct _Data$$2)) this$1)) (int) (block
+  (return (plus (member (deref this$1) z) (member (deref (cast (.ptr (struct _Data$$1)) this$1)) x)))
+)
+)
+(fun f4$$1 (. ((.ptr (struct _Data$$3)) this$1)) (int) (block
+  (return (member (deref this$1) z2))
+)
+)
+(fun f5$$1 (. ((.ptr (struct _Data$$3)) this$1)) (int) (block
+  (return (plus (plus (member (deref this$1) z2) (call f0$$1 (. (cast (.ptr (struct _Data$$1)) this$1)))) (call f1$$1 (. (cast (.ptr (struct _Data$$2)) this$1)))))
+)
+)
+(fun f6$$1 (. ((.ptr (struct _Data$$3)) this$1)) (int) (block
+  (return (plus (plus (member (deref this$1) z2) (member (deref (cast (.ptr (struct _Data$$2)) this$1)) z)) (member (deref (cast (.ptr (struct _Data$$1)) this$1)) x)))
+)
+)
+(fun foo_p (. ((.ptr (struct _Data$$1)) p)) (void) (block
+  (noop)
+)
+)
+(fun foo_c (. ((.ptr (struct _Data$$2)) p)) (void) (block
+  (noop)
+)
+)
+(fun foo_s (. ((.ptr (struct _Data$$3)) p)) (void) (block
+  (noop)
+)
+)
+(fun main (.) (int) (block
+  (var p$1 (struct _Data$$1))
+  (call foo_p (. (addrof p$1)))
+  (var c$1 (struct _Data$$2))
+  (call foo_c (. (addrof c$1)))
+  (call foo_p (. (addrof (member c$1 parent))))
+  (var s$1 (struct _Data$$3))
+  (call foo_s (. (addrof s$1)))
+  (call foo_c (. (addrof (member s$1 parent))))
+  (call foo_p (. (addrof (member (member s$1 parent) parent))))
+  (member p$1 x)
+  (member p$1 y)
+  (call f0$$1 (. (addrof p$1)))
+  (member c$1 z)
+  (member (deref (cast (.ptr (struct _Data$$1)) (addrof c$1))) x)
+  (member (deref (cast (.ptr (struct _Data$$1)) (addrof c$1))) y)
+  (call f0$$1 (. (cast (.ptr (struct _Data$$1)) (addrof c$1))))
+  (call f1$$1 (. (addrof c$1)))
+  (call f2$$1 (. (addrof c$1)))
+  (call f3$$1 (. (addrof c$1)))
+  (member s$1 z2)
+  (member (deref (cast (.ptr (struct _Data$$2)) (addrof s$1))) z)
+  (member (deref (cast (.ptr (struct _Data$$1)) (addrof s$1))) x)
+  (member (deref (cast (.ptr (struct _Data$$1)) (addrof s$1))) y)
+  (call f0$$1 (. (cast (.ptr (struct _Data$$1)) (addrof s$1))))
+  (call f1$$1 (. (cast (.ptr (struct _Data$$2)) (addrof s$1))))
+  (call f2$$1 (. (cast (.ptr (struct _Data$$2)) (addrof s$1))))
+  (call f3$$1 (. (cast (.ptr (struct _Data$$2)) (addrof s$1))))
+  (call f4$$1 (. (addrof s$1)))
+  (call f5$$1 (. (addrof s$1)))
+  (call f6$$1 (. (addrof s$1)))
+  (return 0)
+)
+)
+# special
+# done
Index: gcc/zls/tests/test49.out.zls
===================================================================
--- gcc/zls/tests/test49.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test49.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,73 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+(.struct _Data$$1)
+(.struct _Data$$2)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+(.struct _Data$$1
+  ((int) x_)
+)
+(.struct _Data$$2
+  ((struct _Data$$1) parent)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun foo$$1 (.) (int))
+(fun bar$$1 (.) (int))
+(fun main (.) (int))
+# definitions
+(var x$$1 (int) :static)
+(fun foo$$1 (.) (int) (block
+  (return x$$1)
+)
+)
+(var y$$1 (int) :static)
+(fun bar$$1 (.) (int) (block
+  (return y$$1)
+)
+)
+(fun main (.) (int) (block
+  x$$1
+  x$$1
+  y$$1
+  (call foo$$1 (.))
+  (call foo$$1 (.))
+  (call bar$$1 (.))
+  (var x$1 (struct _Data$$1))
+  x$$1
+  (call foo$$1 (.))
+  (var y$1 (struct _Data$$2))
+  x$$1
+  y$$1
+  (call foo$$1 (.))
+  (call bar$$1 (.))
+)
+)
+# special
+# done
Index: gcc/zls/tests/test21.out.c
===================================================================
--- gcc/zls/tests/test21.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test21.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,40 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main();
+/* definitions */
+int main()
+{
+  int x$1 = 29;
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test40.out.c
===================================================================
--- gcc/zls/tests/test40.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test40.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,56 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+typedef int INT$$1;
+typedef int INT0$$1;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int foo$$1();
+int foo0$$1();
+int main();
+/* definitions */
+int x$$1 = 10;
+int foo$$1()
+{
+  return x$$1;
+}
+static INT$$1 y$$1;
+int x0$$1 = 20;
+int foo0$$1()
+{
+  return y$$1;
+}
+int main()
+{
+  INT0$$1 z$1 = x$$1;
+  return (((x0$$1 + foo0$$1()) + x$$1) + foo$$1());
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test25.out.c
===================================================================
--- gcc/zls/tests/test25.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test25.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,61 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main();
+/* definitions */
+int main()
+{
+  int x$1;
+  if (0)
+    goto inner$$1;
+  else
+    goto outer$$1;
+  {
+    __label__ loop$1;
+  loop$1:;
+    {
+      __label__ loop$2;
+    inner$$1:;
+      {
+        (x$1 = 20);
+        goto loop$2;
+      }
+    loop$2:;
+      (x$1 = 15);
+    }
+    goto loop$1;
+  }
+outer$$1:;
+  (x$1 = 30);
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test44.out.c
===================================================================
--- gcc/zls/tests/test44.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test44.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,56 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+void g$$1();
+void f$$1();
+void h$$1();
+int main();
+/* definitions */
+void g$$1()
+{
+  f$$1();
+}
+void f$$1()
+{
+  ;
+}
+void h$$1()
+{
+  f$$1();
+}
+int main()
+{
+  g$$1();
+  h$$1();
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test63.out.c
===================================================================
--- gcc/zls/tests/test63.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test63.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,111 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+struct _Data$$1;
+struct _Data$$2;
+struct _Data$$3;
+struct _Data$$4;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+struct _Data$$1 {
+  struct _Data$$2 * _vptr;
+  int x_;
+};
+struct _Data$$2 {
+  void (* foo)(struct _Data$$1 * this);
+};
+struct _Data$$3 {
+  struct _Data$$1 parent;
+  int y_;
+};
+struct _Data$$4 {
+  struct _Data$$2 parent;
+  void (* bar)(struct _Data$$3 * this);
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+void _constructor$$1(struct _Data$$1 * this$1);
+void foo$$1(struct _Data$$1 * this$1);
+void _vtable_init$$1(struct _Data$$2 * _vt$1);
+void init$$1() __attribute__((constructor));
+void _constructor$$2(struct _Data$$3 * this$1);
+void bar$$1(struct _Data$$3 * this$1);
+void _vtable_init$$2(struct _Data$$4 * _vt$1);
+void init$$2() __attribute__((constructor));
+int main();
+/* definitions */
+struct _Data$$2 _vtable$$1;
+void _constructor$$1(struct _Data$$1 * this$1)
+{
+  ((*this$1)._vptr = (&_vtable$$1));
+}
+void foo$$1(struct _Data$$1 * this$1)
+{
+  printf("foo\n");
+}
+void _vtable_init$$1(struct _Data$$2 * _vt$1)
+{
+  ((*_vt$1).foo = ((void (*)(struct _Data$$1 * this))((void (*)(struct _Data$$1 * this))foo$$1)));
+}
+void init$$1()
+{
+  _vtable_init$$1((&_vtable$$1));
+}
+struct _Data$$4 _vtable$$2;
+void _constructor$$2(struct _Data$$3 * this$1)
+{
+  ((*((struct _Data$$4 * *)(&(*((struct _Data$$1 *)this$1))._vptr))) = (&_vtable$$2));
+}
+void bar$$1(struct _Data$$3 * this$1)
+{
+  printf("bar\n");
+}
+void _vtable_init$$2(struct _Data$$4 * _vt$1)
+{
+  ((*_vt$1).bar = ((void (*)(struct _Data$$3 * this))((void (*)(struct _Data$$3 * this))bar$$1)));
+}
+void init$$2()
+{
+  _vtable_init$$1((&_vtable$$2.parent));
+  _vtable_init$$2((&_vtable$$2));
+}
+int main()
+{
+  struct _Data$$1 xo$1;
+  _constructor$$1((&xo$1));
+  struct _Data$$1 * x$1 = (&xo$1);
+  (*x$1).x_;
+  (*(*x$1)._vptr).foo(((struct _Data$$1 *)(&(*x$1))));
+  struct _Data$$3 yo$1;
+  _constructor$$2((&yo$1));
+  struct _Data$$3 * y$1 = (&yo$1);
+  (*((struct _Data$$2 *)(*((struct _Data$$4 * *)(&(*((struct _Data$$1 *)(&(*y$1))))._vptr))))).foo(((struct _Data$$1 *)(&(*y$1))));
+  (*(*((struct _Data$$4 * *)(&(*((struct _Data$$1 *)(&(*y$1))))._vptr)))).bar((&(*y$1)));
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test29.out.c
===================================================================
--- gcc/zls/tests/test29.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test29.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,54 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+struct S;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+struct S {
+  int priv$1;
+  int x;
+  int y;
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+void init_s(struct S * s$1);
+int main();
+/* definitions */
+void init_s(struct S * s$1)
+{
+  ((*s$1).priv$1 = 0);
+  ((*s$1).x = 1);
+  ((*s$1).y = 2);
+}
+int main()
+{
+  struct S s$1;
+  init_s((&s$1));
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test48.out.c
===================================================================
--- gcc/zls/tests/test48.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test48.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,135 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+struct _Data$$1;
+struct _Data$$2;
+struct _Data$$3;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+struct _Data$$1 {
+  int x;
+  int y;
+};
+struct _Data$$2 {
+  struct _Data$$1 parent;
+  int z;
+};
+struct _Data$$3 {
+  struct _Data$$2 parent;
+  int z2;
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int f0$$1(struct _Data$$1 * this$1);
+int f1$$1(struct _Data$$2 * this$1);
+int f2$$1(struct _Data$$2 * this$1);
+int f3$$1(struct _Data$$2 * this$1);
+int f4$$1(struct _Data$$3 * this$1);
+int f5$$1(struct _Data$$3 * this$1);
+int f6$$1(struct _Data$$3 * this$1);
+void foo_p(struct _Data$$1 * p);
+void foo_c(struct _Data$$2 * p);
+void foo_s(struct _Data$$3 * p);
+int main();
+/* definitions */
+int f0$$1(struct _Data$$1 * this$1)
+{
+  return (*this$1).x;
+}
+int f1$$1(struct _Data$$2 * this$1)
+{
+  return (*this$1).z;
+}
+int f2$$1(struct _Data$$2 * this$1)
+{
+  return ((*this$1).z + f0$$1(((struct _Data$$1 *)this$1)));
+}
+int f3$$1(struct _Data$$2 * this$1)
+{
+  return ((*this$1).z + (*((struct _Data$$1 *)this$1)).x);
+}
+int f4$$1(struct _Data$$3 * this$1)
+{
+  return (*this$1).z2;
+}
+int f5$$1(struct _Data$$3 * this$1)
+{
+  return (((*this$1).z2 + f0$$1(((struct _Data$$1 *)this$1))) + f1$$1(((struct _Data$$2 *)this$1)));
+}
+int f6$$1(struct _Data$$3 * this$1)
+{
+  return (((*this$1).z2 + (*((struct _Data$$2 *)this$1)).z) + (*((struct _Data$$1 *)this$1)).x);
+}
+void foo_p(struct _Data$$1 * p)
+{
+  ;
+}
+void foo_c(struct _Data$$2 * p)
+{
+  ;
+}
+void foo_s(struct _Data$$3 * p)
+{
+  ;
+}
+int main()
+{
+  struct _Data$$1 p$1;
+  foo_p((&p$1));
+  struct _Data$$2 c$1;
+  foo_c((&c$1));
+  foo_p((&c$1.parent));
+  struct _Data$$3 s$1;
+  foo_s((&s$1));
+  foo_c((&s$1.parent));
+  foo_p((&s$1.parent.parent));
+  p$1.x;
+  p$1.y;
+  f0$$1((&p$1));
+  c$1.z;
+  (*((struct _Data$$1 *)(&c$1))).x;
+  (*((struct _Data$$1 *)(&c$1))).y;
+  f0$$1(((struct _Data$$1 *)(&c$1)));
+  f1$$1((&c$1));
+  f2$$1((&c$1));
+  f3$$1((&c$1));
+  s$1.z2;
+  (*((struct _Data$$2 *)(&s$1))).z;
+  (*((struct _Data$$1 *)(&s$1))).x;
+  (*((struct _Data$$1 *)(&s$1))).y;
+  f0$$1(((struct _Data$$1 *)(&s$1)));
+  f1$$1(((struct _Data$$2 *)(&s$1)));
+  f2$$1(((struct _Data$$2 *)(&s$1)));
+  f3$$1(((struct _Data$$2 *)(&s$1)));
+  f4$$1((&s$1));
+  f5$$1((&s$1));
+  f6$$1((&s$1));
+  return 0;
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test67.out.c
===================================================================
--- gcc/zls/tests/test67.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test67.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,55 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+struct _Data$$1;
+struct _Data$$2;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+struct _Data$$1 {
+  int x;
+  char c;
+  char dummy$1[11];
+};
+struct _Data$$2 {
+  struct _Data$$1 parent;
+  int j;
+  char dummy$1[12];
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main();
+/* definitions */
+int main()
+{
+  printf("%d\n", 16);
+  struct _Data$$2 y$1;
+  (*((struct _Data$$1 *)(&y$1))).x;
+  printf("%d\n", 32);
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test1.out.c
===================================================================
--- gcc/zls/tests/test1.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test1.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,37 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+/* definitions */
+int x = 139;
+int a[3];
+/* special */
+/* done */
Index: gcc/zls/tests/test5.out.c
===================================================================
--- gcc/zls/tests/test5.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test5.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,55 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main();
+/* definitions */
+int main()
+{
+  __label__ bla$1;
+  int x$1 = 20;
+bla$1:;
+  {
+    __label__ break$1;
+    switch (x$1)
+      {
+      case 1:;
+        (x$1 = 10);
+        goto break$1;
+      default:;
+        goto break$1;
+      }
+  break$1:;
+  }
+  goto bla$1;
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test9.out.c
===================================================================
--- gcc/zls/tests/test9.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test9.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,46 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main();
+/* definitions */
+int main()
+{
+  int x$1;
+  int y$1;
+  (x$1 ++);
+  (x$1 += 1);
+  (y$1 ++);
+  (y$1 += 1);
+  (x$1 = (y$1 = 5));
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test50.out.zls
===================================================================
--- gcc/zls/tests/test50.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test50.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,109 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+(.struct _Data$$1)
+(.struct _Data$$2)
+(.struct _Data$$3)
+(.struct _Data$$4)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+(.struct _Data$$1
+  ((.ptr (struct _Data$$2)) _vptr)
+  ((int) x_)
+)
+(.struct _Data$$2
+  ((.ptr (.fun (. ((.ptr (struct _Data$$1)) this)) (void))) foo)
+)
+(.struct _Data$$3
+  ((struct _Data$$1) parent)
+  ((int) y_)
+)
+(.struct _Data$$4
+  ((struct _Data$$2) parent)
+  ((.ptr (.fun (. ((.ptr (struct _Data$$3)) this)) (void))) bar)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun _constructor$$1 (. ((.ptr (struct _Data$$1)) this$1)) (void))
+(fun foo$$1 (. ((.ptr (struct _Data$$1)) this$1)) (void))
+(fun _vtable_init$$1 (. ((.ptr (struct _Data$$2)) _vt$1)) (void))
+(fun init$$1 (.) (void) :__constructor__)
+(fun _constructor$$2 (. ((.ptr (struct _Data$$3)) this$1)) (void))
+(fun bar$$1 (. ((.ptr (struct _Data$$3)) this$1)) (void))
+(fun _vtable_init$$2 (. ((.ptr (struct _Data$$4)) _vt$1)) (void))
+(fun init$$2 (.) (void) :__constructor__)
+(fun main (.) (int))
+# definitions
+(var _vtable$$1 (struct _Data$$2))
+(fun _constructor$$1 (. ((.ptr (struct _Data$$1)) this$1)) (void) (block
+  (assign (member (deref this$1) _vptr) (addrof _vtable$$1))
+)
+)
+(fun foo$$1 (. ((.ptr (struct _Data$$1)) this$1)) (void) (block
+  (call printf (. (s "foo\n")))
+)
+)
+(fun _vtable_init$$1 (. ((.ptr (struct _Data$$2)) _vt$1)) (void) (block
+  (assign (member (deref _vt$1) foo) (cast (.ptr (.fun (. ((.ptr (struct _Data$$1)) this)) (void))) (cast (.ptr (.fun (. ((.ptr (struct _Data$$1)) this)) (void))) foo$$1)))
+)
+)
+(fun init$$1 (.) (void) :__constructor__ (block
+  (call _vtable_init$$1 (. (addrof _vtable$$1)))
+)
+)
+(var _vtable$$2 (struct _Data$$4))
+(fun _constructor$$2 (. ((.ptr (struct _Data$$3)) this$1)) (void) (block
+  (assign (deref (cast (.ptr (.ptr (struct _Data$$4))) (addrof (member (deref (cast (.ptr (struct _Data$$1)) this$1)) _vptr)))) (addrof _vtable$$2))
+)
+)
+(fun bar$$1 (. ((.ptr (struct _Data$$3)) this$1)) (void) (block
+  (call printf (. (s "bar\n")))
+)
+)
+(fun _vtable_init$$2 (. ((.ptr (struct _Data$$4)) _vt$1)) (void) (block
+  (assign (member (deref _vt$1) bar) (cast (.ptr (.fun (. ((.ptr (struct _Data$$3)) this)) (void))) (cast (.ptr (.fun (. ((.ptr (struct _Data$$3)) this)) (void))) bar$$1)))
+)
+)
+(fun init$$2 (.) (void) :__constructor__ (block
+  (call _vtable_init$$1 (. (addrof (member _vtable$$2 parent))))
+  (call _vtable_init$$2 (. (addrof _vtable$$2)))
+)
+)
+(fun main (.) (int) (block
+  (var x$1 (struct _Data$$1))
+  (call _constructor$$1 (. (addrof x$1)))
+  (member x$1 x_)
+  (call (member (deref (member x$1 _vptr)) foo) (. (cast (.ptr (struct _Data$$1)) (addrof x$1))))
+  (var y$1 (struct _Data$$3))
+  (call _constructor$$2 (. (addrof y$1)))
+  (call (member (deref (cast (.ptr (struct _Data$$2)) (deref (cast (.ptr (.ptr (struct _Data$$4))) (addrof (member (deref (cast (.ptr (struct _Data$$1)) (addrof y$1))) _vptr)))))) foo) (. (cast (.ptr (struct _Data$$1)) (addrof y$1))))
+  (call (member (deref (deref (cast (.ptr (.ptr (struct _Data$$4))) (addrof (member (deref (cast (.ptr (struct _Data$$1)) (addrof y$1))) _vptr))))) bar) (. (addrof y$1)))
+)
+)
+# special
+# done
Index: gcc/zls/tests/test51.out.zls
===================================================================
--- gcc/zls/tests/test51.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test51.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,106 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+(.struct _Data$$1)
+(.struct _Data$$2)
+(.struct _Data$$3)
+(.struct _Data$$4)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+(.struct _Data$$1
+  ((.ptr (struct _Data$$2)) _vptr)
+)
+(.struct _Data$$2
+  ((.ptr (.fun (. ((.ptr (struct _Data$$1)) this)) (void))) foo)
+)
+(.struct _Data$$3
+  ((struct _Data$$1) parent)
+)
+(.struct _Data$$4
+  ((struct _Data$$2) parent)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun _constructor$$1 (. ((.ptr (struct _Data$$1)) this$1)) (void))
+(fun foo$$1 (. ((.ptr (struct _Data$$1)) this$1)) (void))
+(fun _vtable_init$$1 (. ((.ptr (struct _Data$$2)) _vt$1)) (void))
+(fun init$$1 (.) (void) :__constructor__)
+(fun _constructor$$2 (. ((.ptr (struct _Data$$3)) this$1)) (void))
+(fun foo$$2 (. ((.ptr (struct _Data$$3)) this$1)) (void))
+(fun _vtable_init$$2 (. ((.ptr (struct _Data$$4)) _vt$1)) (void))
+(fun init$$2 (.) (void) :__constructor__)
+(fun main (.) (int))
+# definitions
+(var _vtable$$1 (struct _Data$$2))
+(fun _constructor$$1 (. ((.ptr (struct _Data$$1)) this$1)) (void) (block
+  (assign (member (deref this$1) _vptr) (addrof _vtable$$1))
+)
+)
+(fun foo$$1 (. ((.ptr (struct _Data$$1)) this$1)) (void) (block
+  (call printf (. (s "X\n")))
+)
+)
+(fun _vtable_init$$1 (. ((.ptr (struct _Data$$2)) _vt$1)) (void) (block
+  (assign (member (deref _vt$1) foo) (cast (.ptr (.fun (. ((.ptr (struct _Data$$1)) this)) (void))) (cast (.ptr (.fun (. ((.ptr (struct _Data$$1)) this)) (void))) foo$$1)))
+)
+)
+(fun init$$1 (.) (void) :__constructor__ (block
+  (call _vtable_init$$1 (. (addrof _vtable$$1)))
+)
+)
+(var _vtable$$2 (struct _Data$$4))
+(fun _constructor$$2 (. ((.ptr (struct _Data$$3)) this$1)) (void) (block
+  (assign (deref (cast (.ptr (.ptr (struct _Data$$4))) (addrof (member (deref (cast (.ptr (struct _Data$$1)) this$1)) _vptr)))) (addrof _vtable$$2))
+)
+)
+(fun foo$$2 (. ((.ptr (struct _Data$$3)) this$1)) (void) (block
+  (call printf (. (s "Y\n")))
+)
+)
+(fun _vtable_init$$2 (. ((.ptr (struct _Data$$4)) _vt$1)) (void) (block
+  (assign (member (deref (cast (.ptr (struct _Data$$2)) _vt$1)) foo) (cast (.ptr (.fun (. ((.ptr (struct _Data$$1)) this)) (void))) (cast (.ptr (.fun (. ((.ptr (struct _Data$$3)) this)) (void))) foo$$2)))
+)
+)
+(fun init$$2 (.) (void) :__constructor__ (block
+  (call _vtable_init$$1 (. (addrof (member _vtable$$2 parent))))
+  (call _vtable_init$$2 (. (addrof _vtable$$2)))
+)
+)
+(fun main (.) (int) (block
+  (var x$1 (struct _Data$$1))
+  (call _constructor$$1 (. (addrof x$1)))
+  (var y$1 (struct _Data$$3))
+  (call _constructor$$2 (. (addrof y$1)))
+  (call (member (deref (member x$1 _vptr)) foo) (. (cast (.ptr (struct _Data$$1)) (addrof x$1))))
+  (call (member (deref (cast (.ptr (struct _Data$$2)) (deref (cast (.ptr (.ptr (struct _Data$$4))) (addrof (member (deref (cast (.ptr (struct _Data$$1)) (addrof y$1))) _vptr)))))) foo) (. (addrof (member y$1 parent))))
+  (var xp$1 (.ptr (struct _Data$$1)) (addrof (member y$1 parent)))
+  (call (member (deref (member (deref xp$1) _vptr)) foo) (. xp$1))
+)
+)
+# special
+# done
Index: gcc/zls/tests/test52.out.zls
===================================================================
--- gcc/zls/tests/test52.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test52.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,63 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+(.struct S$$1)
+(talias S$$2 (struct S$$1))
+(.struct S0$$1)
+(talias S0$$2 (struct S0$$1))
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+(.struct S$$1
+  ((int) x)
+)
+(.struct S0$$1
+  ((int) y)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (.) (int))
+# definitions
+(var x$$1 (S0$$2))
+(var y$$1 (struct S0$$1))
+(var x0 (S$$2))
+(var s0 (struct S$$1))
+(var x1 (S0$$2))
+(var s1 (struct S0$$1))
+(fun main (.) (int) (block
+  (member x0 x)
+  (member s1 y)
+  (member s0 x)
+  (member s1 y)
+  (var x$1 (S0$$2))
+  (var m$1 (struct S0$$1))
+  (member x$1 y)
+  (member m$1 y)
+)
+)
+# special
+# done
Index: gcc/zls/tests/test53.out.zls
===================================================================
--- gcc/zls/tests/test53.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test53.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,63 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+(.struct S$$1)
+(talias S$$2 (struct S$$1))
+(.struct S$$3)
+(talias S$$4 (struct S$$3))
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+(.struct S$$1
+  ((int) x)
+)
+(.struct S$$3
+  ((int) y)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (.) (int))
+# definitions
+(var x$$1 (S$$4))
+(var y$$1 (struct S$$3))
+(var x0 (S$$2))
+(var s0 (struct S$$1))
+(var x1 (S$$4))
+(var s1 (struct S$$3))
+(fun main (.) (int) (block
+  (member x0 x)
+  (member s1 y)
+  (member s0 x)
+  (member s1 y)
+  (var x$1 (S$$4))
+  (var m$1 (struct S$$3))
+  (member x$1 y)
+  (member m$1 y)
+)
+)
+# special
+# done
Index: gcc/zls/tests/test54.out.zls
===================================================================
--- gcc/zls/tests/test54.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test54.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,67 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+(.struct D$$1)
+(.struct _Data$$1)
+(.struct _Data$$2)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+(.struct D$$1
+  ((int) x)
+)
+(.struct _Data$$1
+  ((int) x)
+)
+(.struct _Data$$2
+  ((struct D$$1) d)
+  ((struct _Data$$1) c)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun get_d$$1 (. ((.ptr (struct _Data$$2)) this$1)) (struct D$$1))
+(fun get_c$$1 (. ((.ptr (struct _Data$$2)) this$1)) (struct _Data$$1))
+(fun make_x$$1 (. ((.ptr (struct _Data$$2)) this$1)) (struct _Data$$2))
+# definitions
+(fun get_d$$1 (. ((.ptr (struct _Data$$2)) this$1)) (struct D$$1) (block
+  (return (member (deref this$1) d))
+)
+)
+(fun get_c$$1 (. ((.ptr (struct _Data$$2)) this$1)) (struct _Data$$1) (block
+  (return (member (deref this$1) c))
+)
+)
+(fun make_x$$1 (. ((.ptr (struct _Data$$2)) this$1)) (struct _Data$$2) (block
+  (var x$1 (struct _Data$$2))
+  (return x$1)
+)
+)
+(var d (struct D$$1))
+(var c (struct _Data$$1))
+(var x (struct _Data$$2))
+# special
+# done
Index: gcc/zls/tests/test55.out.zls
===================================================================
--- gcc/zls/tests/test55.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test55.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,45 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun f1 (. ((int) )) (int))
+(fun f2 (. ((int) ) ((int) )) (int))
+(fun f3 (. ((int) ) ((int) ) ((int) )) (int))
+(fun main (.) (int))
+# definitions
+(fun main (.) (int) (block
+  (call f1 (. 1))
+  (call f2 (. 1 2))
+  (call f3 (. 1 2 3))
+)
+)
+# special
+# done
Index: gcc/zls/tests/test56.out.zls
===================================================================
--- gcc/zls/tests/test56.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test56.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,46 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun f (.) (int))
+(fun main (.) (int))
+# definitions
+(var x (int))
+(fun f (.) (int) (block
+  (return 0)
+)
+)
+(fun main (.) (int) (block
+  (assign x (call f (.)))
+)
+)
+# special
+# done
Index: gcc/zls/tests/test57.out.zls
===================================================================
--- gcc/zls/tests/test57.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test57.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,45 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (.) (int))
+(fun f (.) (int))
+# definitions
+(fun main (.) (int) (block
+  (return (call f (.)))
+)
+)
+(fun f (.) (int) (block
+  (return 3)
+)
+)
+# special
+# done
Index: gcc/zls/tests/test11.out.c
===================================================================
--- gcc/zls/tests/test11.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test11.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,55 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int f0();
+int f1(int x);
+int f2(int x, int y);
+int main();
+/* definitions */
+int f0()
+{
+  return 0;
+}
+int f1(int x)
+{
+  return (x * 2);
+}
+int f2(int x, int y)
+{
+  return (x + y);
+}
+int main()
+{
+  return ((f0() + f1(1)) + f2(2, 3));
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test58.out.zls
===================================================================
--- gcc/zls/tests/test58.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test58.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,44 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+(.struct X)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+(.struct X
+  ((int) x)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (.) (int))
+# definitions
+(fun main (.) (int) (block
+  0
+)
+)
+# special
+# done
Index: gcc/zls/tests/test30.out.c
===================================================================
--- gcc/zls/tests/test30.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test30.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,70 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+struct S;
+struct T$$1;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+struct S {
+  int mine;
+  int priv;
+  int priv$1;
+};
+struct T$$1 {
+  int mine;
+  int priv;
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+void init_s(struct S * s$1);
+void use_s(struct S s$1);
+int main();
+/* definitions */
+void init_s(struct S * s$1)
+{
+  ((*s$1).mine = 0);
+  ((*s$1).priv = 0);
+  ((*s$1).priv$1 = 20);
+}
+void use_s(struct S s$1)
+{
+  ((s$1.mine + s$1.priv) + s$1.priv$1);
+}
+int main()
+{
+  struct S s$1;
+  init_s((&s$1));
+  use_s(s$1);
+  (s$1.mine + s$1.priv$1);
+  (s$1.mine + s$1.priv);
+  struct T$$1 t$1;
+  (t$1.mine + t$1.priv);
+  (t$1.mine + t$1.priv);
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test59.out.zls
===================================================================
--- gcc/zls/tests/test59.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test59.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,48 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (.) (int))
+# definitions
+(fun main (.) (int) (block
+  (var x$1 (int) 20)
+  (var xr$1 (.ptr (int)) (addrof x$1))
+  (var y$1 (int) 30)
+  (var yr$1 (.ptr (int)) (addrof y$1))
+  (assign (deref xr$1) 15)
+  (postinc (deref yr$1))
+  (c-assign plus (deref xr$1) 3)
+  (call printf (. (s "%d\n") (plus (deref xr$1) (deref yr$1))))
+  (return 0)
+)
+)
+# special
+# done
Index: gcc/zls/tests/test15.out.c
===================================================================
--- gcc/zls/tests/test15.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test15.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,40 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main(int argc, char const * argv[0]);
+/* definitions */
+int main(int argc, char const * argv[0])
+{
+  return ((int)(*(*(argv + 0))));
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test34.out.c
===================================================================
--- gcc/zls/tests/test34.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test34.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,43 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+typedef int X;
+typedef int Y;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main();
+/* definitions */
+int main()
+{
+  Y y$1 = 20;
+  return y$1;
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test53.out.c
===================================================================
--- gcc/zls/tests/test53.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test53.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,63 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+struct S$$1;
+typedef struct S$$1 S$$2;
+struct S$$3;
+typedef struct S$$3 S$$4;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+struct S$$1 {
+  int x;
+};
+struct S$$3 {
+  int y;
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main();
+/* definitions */
+S$$4 x$$1;
+struct S$$3 y$$1;
+S$$2 x0;
+struct S$$1 s0;
+S$$4 x1;
+struct S$$3 s1;
+int main()
+{
+  x0.x;
+  s1.y;
+  s0.x;
+  s1.y;
+  S$$4 x$1;
+  struct S$$3 m$1;
+  x$1.y;
+  m$1.y;
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test72.out.c
===================================================================
--- gcc/zls/tests/test72.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test72.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,56 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+void f();
+void g();
+int main();
+/* definitions */
+void f()
+{
+  float x$1 = ((float)({
+    double t$1 = 0x0p+0;
+    (((int)t$1) ? t$1 : 0x1.b333333333333p+2);
+  }));
+  printf("%f\n", x$1);
+}
+void g()
+{
+  float x$1 = 0x1.8p+2f;
+  printf("%f\n", x$1);
+}
+int main()
+{
+  f();
+  g();
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test19.out.c
===================================================================
--- gcc/zls/tests/test19.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test19.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,43 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+typedef double DOUBLE;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main();
+/* definitions */
+int main()
+{
+  double const x$1 = 0x1.4p+4;
+  DOUBLE y$1 = 0x1.5p+4;
+  double z$1 = ((x$1 + y$1) + ((double)1));
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test38.out.c
===================================================================
--- gcc/zls/tests/test38.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test38.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,46 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main();
+/* definitions */
+int main()
+{
+  30;
+  30;
+  30;
+  20;
+  20;
+  (10 + 20);
+  (10 + 30);
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test57.out.c
===================================================================
--- gcc/zls/tests/test57.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test57.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,45 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main();
+int f();
+/* definitions */
+int main()
+{
+  return f();
+}
+int f()
+{
+  return 3;
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test60.out.zls
===================================================================
--- gcc/zls/tests/test60.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test60.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,54 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun f (.) (.ptr (int)))
+(fun g (. ((.ptr (int)) x)) (void))
+(fun main (.) (int))
+# definitions
+(var global (int) 20)
+(fun f (.) (.ptr (int)) (block
+  (return (addrof global))
+)
+)
+(fun g (. ((.ptr (int)) x)) (void) (block
+  (assign (deref x) 20)
+)
+)
+(fun main (.) (int) (block
+  (assign (deref (call f (.))) 20)
+  (var x$1 (int))
+  (call g (. (addrof x$1)))
+  (return 0)
+)
+)
+# special
+# done
Index: gcc/zls/tests/test61.out.zls
===================================================================
--- gcc/zls/tests/test61.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test61.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,86 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+(.struct _Data$$1)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+(.struct _Data$$1
+  ((.ptr (int)) data)
+  ((size_t) sz)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun begin$$1 (. ((.ptr (struct _Data$$1)) this$1)) (.ptr (int)))
+(fun end$$1 (. ((.ptr (struct _Data$$1)) this$1)) (.ptr (int)))
+(fun main (.) (int))
+# definitions
+(fun begin$$1 (. ((.ptr (struct _Data$$1)) this$1)) (.ptr (int)) (block
+  (return (member (deref this$1) data))
+)
+)
+(fun end$$1 (. ((.ptr (struct _Data$$1)) this$1)) (.ptr (int)) (block
+  (return (plus (member (deref this$1) data) (member (deref this$1) sz)))
+)
+)
+(fun main (.) (int) (block
+  (var x$1 (struct _Data$$1))
+  (var d$1 (.array (int) 4) (.
+    1
+    5
+    3
+    2
+  ))
+  (assign (member x$1 data) d$1)
+  (assign (member x$1 sz) (cast (size_t) 4))
+  (var what$1 (.ptr (struct _Data$$1)) (addrof x$1))
+  (var i$1 (.ptr (int)) (call begin$$1 (. (addrof (deref what$1)))))
+  (var e$1 (.ptr (int)) (call end$$1 (. (addrof (deref what$1)))))
+  (block
+    (local_label break$1)
+    (local_label continue$1)
+    (noop)
+  (label loop$$1)
+    (if (not (ne i$1 e$1))
+      (goto break$1)
+    )
+    (block
+      (var el$1 (.ptr (int)) (addrof (deref i$1)))
+      (block
+        (call printf (. (s "%d\n") (deref el$1)))
+      )
+    )
+  (label continue$1)
+    (eblock      (c-assign plus i$1 1)
+    )
+    (goto loop$$1)
+  (label break$1)
+  )
+)
+)
+# special
+# done
Index: gcc/zls/tests/test62.out.zls
===================================================================
--- gcc/zls/tests/test62.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test62.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,45 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (.) (int))
+# definitions
+(fun main (.) (int) (block
+  (var x$1 (int) 20)
+  (var p$1 (.ptr (int)) (addrof x$1))
+  (var pr$1 (.ptr (.ptr (int))) (addrof p$1))
+  (assign (deref (deref pr$1)) 30)
+  (postinc (deref pr$1))
+  (return 30)
+)
+)
+# special
+# done
Index: gcc/zls/tests/test63.out.zls
===================================================================
--- gcc/zls/tests/test63.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test63.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,111 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+(.struct _Data$$1)
+(.struct _Data$$2)
+(.struct _Data$$3)
+(.struct _Data$$4)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+(.struct _Data$$1
+  ((.ptr (struct _Data$$2)) _vptr)
+  ((int) x_)
+)
+(.struct _Data$$2
+  ((.ptr (.fun (. ((.ptr (struct _Data$$1)) this)) (void))) foo)
+)
+(.struct _Data$$3
+  ((struct _Data$$1) parent)
+  ((int) y_)
+)
+(.struct _Data$$4
+  ((struct _Data$$2) parent)
+  ((.ptr (.fun (. ((.ptr (struct _Data$$3)) this)) (void))) bar)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun _constructor$$1 (. ((.ptr (struct _Data$$1)) this$1)) (void))
+(fun foo$$1 (. ((.ptr (struct _Data$$1)) this$1)) (void))
+(fun _vtable_init$$1 (. ((.ptr (struct _Data$$2)) _vt$1)) (void))
+(fun init$$1 (.) (void) :__constructor__)
+(fun _constructor$$2 (. ((.ptr (struct _Data$$3)) this$1)) (void))
+(fun bar$$1 (. ((.ptr (struct _Data$$3)) this$1)) (void))
+(fun _vtable_init$$2 (. ((.ptr (struct _Data$$4)) _vt$1)) (void))
+(fun init$$2 (.) (void) :__constructor__)
+(fun main (.) (int))
+# definitions
+(var _vtable$$1 (struct _Data$$2))
+(fun _constructor$$1 (. ((.ptr (struct _Data$$1)) this$1)) (void) (block
+  (assign (member (deref this$1) _vptr) (addrof _vtable$$1))
+)
+)
+(fun foo$$1 (. ((.ptr (struct _Data$$1)) this$1)) (void) (block
+  (call printf (. (s "foo\n")))
+)
+)
+(fun _vtable_init$$1 (. ((.ptr (struct _Data$$2)) _vt$1)) (void) (block
+  (assign (member (deref _vt$1) foo) (cast (.ptr (.fun (. ((.ptr (struct _Data$$1)) this)) (void))) (cast (.ptr (.fun (. ((.ptr (struct _Data$$1)) this)) (void))) foo$$1)))
+)
+)
+(fun init$$1 (.) (void) :__constructor__ (block
+  (call _vtable_init$$1 (. (addrof _vtable$$1)))
+)
+)
+(var _vtable$$2 (struct _Data$$4))
+(fun _constructor$$2 (. ((.ptr (struct _Data$$3)) this$1)) (void) (block
+  (assign (deref (cast (.ptr (.ptr (struct _Data$$4))) (addrof (member (deref (cast (.ptr (struct _Data$$1)) this$1)) _vptr)))) (addrof _vtable$$2))
+)
+)
+(fun bar$$1 (. ((.ptr (struct _Data$$3)) this$1)) (void) (block
+  (call printf (. (s "bar\n")))
+)
+)
+(fun _vtable_init$$2 (. ((.ptr (struct _Data$$4)) _vt$1)) (void) (block
+  (assign (member (deref _vt$1) bar) (cast (.ptr (.fun (. ((.ptr (struct _Data$$3)) this)) (void))) (cast (.ptr (.fun (. ((.ptr (struct _Data$$3)) this)) (void))) bar$$1)))
+)
+)
+(fun init$$2 (.) (void) :__constructor__ (block
+  (call _vtable_init$$1 (. (addrof (member _vtable$$2 parent))))
+  (call _vtable_init$$2 (. (addrof _vtable$$2)))
+)
+)
+(fun main (.) (int) (block
+  (var xo$1 (struct _Data$$1))
+  (call _constructor$$1 (. (addrof xo$1)))
+  (var x$1 (.ptr (struct _Data$$1)) (addrof xo$1))
+  (member (deref x$1) x_)
+  (call (member (deref (member (deref x$1) _vptr)) foo) (. (cast (.ptr (struct _Data$$1)) (addrof (deref x$1)))))
+  (var yo$1 (struct _Data$$3))
+  (call _constructor$$2 (. (addrof yo$1)))
+  (var y$1 (.ptr (struct _Data$$3)) (addrof yo$1))
+  (call (member (deref (cast (.ptr (struct _Data$$2)) (deref (cast (.ptr (.ptr (struct _Data$$4))) (addrof (member (deref (cast (.ptr (struct _Data$$1)) (addrof (deref y$1)))) _vptr)))))) foo) (. (cast (.ptr (struct _Data$$1)) (addrof (deref y$1)))))
+  (call (member (deref (deref (cast (.ptr (.ptr (struct _Data$$4))) (addrof (member (deref (cast (.ptr (struct _Data$$1)) (addrof (deref y$1)))) _vptr))))) bar) (. (addrof (deref y$1))))
+)
+)
+# special
+# done
Index: gcc/zls/tests/test64.out.zls
===================================================================
--- gcc/zls/tests/test64.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test64.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,108 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+(.struct _Data$$1)
+(.struct _Data$$2)
+(.struct _Data$$3)
+(.struct _Data$$4)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+(.struct _Data$$1
+  ((.ptr (struct _Data$$2)) _vptr)
+)
+(.struct _Data$$2
+  ((.ptr (.fun (. ((.ptr (struct _Data$$1)) this)) (void))) foo)
+)
+(.struct _Data$$3
+  ((struct _Data$$1) parent)
+)
+(.struct _Data$$4
+  ((struct _Data$$2) parent)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun _constructor$$1 (. ((.ptr (struct _Data$$1)) this$1)) (void))
+(fun foo$$1 (. ((.ptr (struct _Data$$1)) this$1)) (void))
+(fun _vtable_init$$1 (. ((.ptr (struct _Data$$2)) _vt$1)) (void))
+(fun init$$1 (.) (void) :__constructor__)
+(fun _constructor$$2 (. ((.ptr (struct _Data$$3)) this$1)) (void))
+(fun foo$$2 (. ((.ptr (struct _Data$$3)) this$1)) (void))
+(fun _vtable_init$$2 (. ((.ptr (struct _Data$$4)) _vt$1)) (void))
+(fun init$$2 (.) (void) :__constructor__)
+(fun main (.) (int))
+# definitions
+(var _vtable$$1 (struct _Data$$2))
+(fun _constructor$$1 (. ((.ptr (struct _Data$$1)) this$1)) (void) (block
+  (assign (member (deref this$1) _vptr) (addrof _vtable$$1))
+)
+)
+(fun foo$$1 (. ((.ptr (struct _Data$$1)) this$1)) (void) (block
+  (call printf (. (s "X\n")))
+)
+)
+(fun _vtable_init$$1 (. ((.ptr (struct _Data$$2)) _vt$1)) (void) (block
+  (assign (member (deref _vt$1) foo) (cast (.ptr (.fun (. ((.ptr (struct _Data$$1)) this)) (void))) (cast (.ptr (.fun (. ((.ptr (struct _Data$$1)) this)) (void))) foo$$1)))
+)
+)
+(fun init$$1 (.) (void) :__constructor__ (block
+  (call _vtable_init$$1 (. (addrof _vtable$$1)))
+)
+)
+(var _vtable$$2 (struct _Data$$4))
+(fun _constructor$$2 (. ((.ptr (struct _Data$$3)) this$1)) (void) (block
+  (assign (deref (cast (.ptr (.ptr (struct _Data$$4))) (addrof (member (deref (cast (.ptr (struct _Data$$1)) this$1)) _vptr)))) (addrof _vtable$$2))
+)
+)
+(fun foo$$2 (. ((.ptr (struct _Data$$3)) this$1)) (void) (block
+  (call printf (. (s "Y\n")))
+)
+)
+(fun _vtable_init$$2 (. ((.ptr (struct _Data$$4)) _vt$1)) (void) (block
+  (assign (member (deref (cast (.ptr (struct _Data$$2)) _vt$1)) foo) (cast (.ptr (.fun (. ((.ptr (struct _Data$$1)) this)) (void))) (cast (.ptr (.fun (. ((.ptr (struct _Data$$3)) this)) (void))) foo$$2)))
+)
+)
+(fun init$$2 (.) (void) :__constructor__ (block
+  (call _vtable_init$$1 (. (addrof (member _vtable$$2 parent))))
+  (call _vtable_init$$2 (. (addrof _vtable$$2)))
+)
+)
+(fun main (.) (int) (block
+  (var xo$1 (struct _Data$$1))
+  (call _constructor$$1 (. (addrof xo$1)))
+  (var x$1 (.ptr (struct _Data$$1)) (addrof xo$1))
+  (var yo$1 (struct _Data$$3))
+  (call _constructor$$2 (. (addrof yo$1)))
+  (var y$1 (.ptr (struct _Data$$3)) (addrof yo$1))
+  (call (member (deref (member (deref x$1) _vptr)) foo) (. (cast (.ptr (struct _Data$$1)) (addrof (deref x$1)))))
+  (call (member (deref (cast (.ptr (struct _Data$$2)) (deref (cast (.ptr (.ptr (struct _Data$$4))) (addrof (member (deref (cast (.ptr (struct _Data$$1)) (addrof (deref y$1)))) _vptr)))))) foo) (. (addrof (member (deref y$1) parent))))
+  (var xp$1 (.ptr (struct _Data$$1)) (addrof (member (deref y$1) parent)))
+  (call (member (deref (member (deref xp$1) _vptr)) foo) (. xp$1))
+)
+)
+# special
+# done
Index: gcc/zls/tests/test66.out.zls
===================================================================
--- gcc/zls/tests/test66.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test66.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,53 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+(.struct X)
+(.struct _Data$$1)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+(.struct X
+  ((int) x)
+  ((int) y)
+  ((.array (char) 10) a)
+)
+(.struct _Data$$1
+  ((int) x)
+  ((int) y)
+  ((.array (char) 10) a)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (.) (int))
+# definitions
+(fun main (.) (int) (block
+  (var str$1 (.ptr (char :const)) (s "4 8 0  4 8 0"))
+  (call printf (. (s "%s\n") str$1))
+)
+)
+# special
+# done
Index: gcc/zls/tests/test20.out.c
===================================================================
--- gcc/zls/tests/test20.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test20.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,41 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main();
+/* definitions */
+int main()
+{
+  4;
+  4;
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test67.out.zls
===================================================================
--- gcc/zls/tests/test67.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test67.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,55 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+(.struct _Data$$1)
+(.struct _Data$$2)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+(.struct _Data$$1
+  ((int) x)
+  ((char) c)
+  ((.array (char) 11) dummy$1)
+)
+(.struct _Data$$2
+  ((struct _Data$$1) parent)
+  ((int) j)
+  ((.array (char) 12) dummy$1)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (.) (int))
+# definitions
+(fun main (.) (int) (block
+  (call printf (. (s "%d\n") (n 16 (size_t))))
+  (var y$1 (struct _Data$$2))
+  (member (deref (cast (.ptr (struct _Data$$1)) (addrof y$1))) x)
+  (call printf (. (s "%d\n") (n 32 (size_t))))
+)
+)
+# special
+# done
Index: gcc/zls/tests/test68.out.zls
===================================================================
--- gcc/zls/tests/test68.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test68.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,43 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (.) (int))
+# definitions
+(var X$$1 (int :const) :static 2)
+(var Y$$1 (int :const) :static 4)
+(var SIZE$$1 (int :const) :static 6)
+(fun main (.) (int) (block
+  (var x$1 (.array (int) 6))
+)
+)
+# special
+# done
Index: gcc/zls/tests/test69.out.zls
===================================================================
--- gcc/zls/tests/test69.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test69.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,50 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (.) (int))
+# definitions
+(fun main (.) (int) (block
+  (var c$1 (char) 1)
+  (var sc$1 (signed-char) 2)
+  (var uc$1 (unsigned-char) 3)
+  (var s$1 (short) 4)
+  (var us$1 (unsigned-short) 5)
+  (var i$1 (int) 6)
+  (var u$1 (unsigned-int) 7)
+  (var l$1 (long) 8)
+  (var lu$1 (unsigned-long) 9)
+  (var ll$1 (long-long) (n 10 (long-long)))
+  (var ull$1 (unsigned-long-long) (n 10 (unsigned-long-long)))
+)
+)
+# special
+# done
Index: gcc/zls/tests/test43.out.c
===================================================================
--- gcc/zls/tests/test43.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test43.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,46 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+struct Foo;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+struct Foo {
+  int x;
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main();
+/* definitions */
+int main()
+{
+  struct Foo foo$1;
+  foo$1.x;
+  foo$1.x;
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test1.out.zls
===================================================================
--- gcc/zls/tests/test1.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test1.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,37 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+# definitions
+(var x (int) 139)
+(var a (.array (int) 3))
+# special
+# done
Index: gcc/zls/tests/test62.out.c
===================================================================
--- gcc/zls/tests/test62.out.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test62.out.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,45 @@
+/* type decls */
+typedef struct _IO_FILE FILE;
+typedef unsigned int size_t;
+typedef int bool;
+typedef struct EnvironSnapshot EnvironSnapshot;
+typedef struct Mark Mark;
+struct UnmarkedSyntax;
+struct Syntax;
+struct SyntaxList;
+struct SyntaxEnum;
+struct Match;
+typedef struct Context Context;
+typedef struct Environ Environ;
+enum _s_0_;
+typedef enum _s_0_ Position;
+struct UserTypeInfo;
+struct ModuleInfo;
+/* type definitions */
+enum _s_0_{
+  NoPos = 0,
+  OtherPos = 1,
+  TopLevel = 2,
+  FieldPos = 4,
+  StmtDeclPos = 8,
+  StmtPos = 16,
+  ExpPos = 32,
+};
+/* function decls */
+int printf(char const *, ...);
+int snprintf(char const * str, size_t size, char const * format, ...);
+int strcmp(char const * s1, char const * s2);
+struct Syntax * parse_class(struct Syntax * p, Environ * env);
+int main();
+/* definitions */
+int main()
+{
+  int x$1 = 20;
+  int * p$1 = (&x$1);
+  int * * pr$1 = (&p$1);
+  ((*(*pr$1)) = 30);
+  ((*pr$1) ++);
+  return 30;
+}
+/* special */
+/* done */
Index: gcc/zls/tests/test2.out.zls
===================================================================
--- gcc/zls/tests/test2.out.zls	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/tests/test2.out.zls	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,45 @@
+# type decls
+(talias FILE (struct _IO_FILE))
+(talias size_t (unsigned-int))
+(talias bool (int))
+(talias EnvironSnapshot (struct EnvironSnapshot))
+(talias Mark (struct Mark))
+(.struct UnmarkedSyntax)
+(.struct Syntax)
+(.struct SyntaxList)
+(.struct SyntaxEnum)
+(.struct Match)
+(talias Context (struct Context))
+(talias Environ (struct Environ))
+(.enum _s_0_)
+(talias Position (enum _s_0_))
+(.struct UserTypeInfo)
+(.struct ModuleInfo)
+(talias INTP (.ptr (int :const) :const))
+# type definitions
+(.enum _s_0_
+   (NoPos 0)
+   (OtherPos 1)
+   (TopLevel 2)
+   (FieldPos 4)
+   (StmtDeclPos 8)
+   (StmtPos 16)
+   (ExpPos 32)
+)
+# function decls
+(fun printf (. ((.ptr (char :const)) ) ...) (int))
+(fun snprintf (. ((.ptr (char :const)) str) ((size_t) size) ((.ptr (char :const)) format) ...) (int))
+(fun strcmp (. ((.ptr (char :const)) s1) ((.ptr (char :const)) s2)) (int))
+(fun parse_class (. ((.ptr (struct Syntax)) p) ((.ptr (Environ)) env)) (.ptr (struct Syntax)))
+(fun main (.) (int))
+# definitions
+(var i (int))
+(var x (INTP :const) (addrof i))
+(var y (.array (int) 9))
+(fun main (.) (int) (block
+  (deref (plus x 4))
+  (deref (plus y 3))
+)
+)
+# special
+# done

Property changes on: gcc/zls/tests
___________________________________________________________________
Name: svn:ignore
   + *.s



Index: gcc/zls/opts.c
===================================================================
--- gcc/zls/opts.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/opts.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,3 @@
+#define NO_CPP 1
+
+#include "c-opts.c"
Index: gcc/zls/config-lang.in
===================================================================
--- gcc/zls/config-lang.in	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/config-lang.in	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,38 @@
+# Top level configure fragment for GNU Objective-C
+#   Copyright (C) 1997, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2007
+#   Free Software Foundation, Inc.
+
+#This file is part of GCC.
+
+#GCC is free software; you can redistribute it and/or modify
+#it under the terms of the GNU General Public License as published by
+#the Free Software Foundation; either version 3, or (at your option)
+#any later version.
+
+#GCC is distributed in the hope that it will be useful,
+#but WITHOUT ANY WARRANTY; without even the implied warranty of
+#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+# Configure looks for the existence of this file to auto-config each language.
+# We define several parameters used by configure:
+#
+# language	- name of language as it would appear in $(LANGUAGES)
+# compilers	- value to add to $(COMPILERS)
+
+language="zls"
+
+compilers="zls0\$(exeext)"
+
+## target_libs=target-libobjc
+
+# Most of the object files for cc1obj actually come from C.
+lang_requires="c"
+
+#gtfiles="\$(srcdir)/c-parser.c \$(srcdir)/c-tree.h \$(srcdir)/c-decl.c \$(srcdir)/c-objc-common.c \$(srcdir)/c-common.c \$(srcdir)/c-common.h \$(srcdir)/c-pragma.h \$(srcdir)/c-pragma.c"
+
+gtfiles="\$(srcdir)/c-tree.h \$(srcdir)/c-decl.c \$(srcdir)/c-objc-common.c \$(srcdir)/c-common.c \$(srcdir)/c-common.h"
Index: gcc/zls/parser.c
===================================================================
--- gcc/zls/parser.c	(.../vender/gcc/4.4.0)	(revision 0)
+++ gcc/zls/parser.c	(.../trunk/gcc)	(revision 449)
@@ -0,0 +1,1297 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <setjmp.h>
+#include <assert.h>
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "tree.h"
+#include "c-tree.h"
+#include "c-common.h"
+#include "real.h"
+#include "function.h"
+
+//
+//
+//
+
+#define CHAR_SPECIAL 0
+#define CHAR_ID      1
+#define CHAR_NUM     2
+#define CHAR_EOL     4
+#define CHAR_SPACE   8
+
+static signed char chartype_[256];
+#define chartype(x) chartype_[(unsigned char)x]
+
+typedef struct token {
+  const char * str; // NOT null terminated
+  unsigned len;
+  location_t loc;
+} token;
+
+static inline tree token_to_tree(token t) {
+  return get_identifier_with_length(t.str, t.len);
+}
+
+#define NULL_TOKEN (struct token){NULL, 0, 0}
+
+#define token_eq(tok, s) \
+  (__builtin_constant_p(s) \
+   ? ((tok).len == sizeof(s)-1 && memcmp((tok).str, s, sizeof(s)-1) == 0) \
+   : ((tok).len == strlen(s) && memcmp((tok).str, s, (tok).len) == 0))
+#define token_prefix(tok, s) \
+  (__builtin_constant_p(s) \
+   ? ((tok).len >= sizeof(s)-1 && memcmp((tok).str, s, sizeof(s)-1) == 0) \
+   : ((tok).len >= strlen(s) && memcmp((tok).str, s, (tok).len) == 0))
+
+extern const char *this_input_filename;
+static char * data = NULL;
+static unsigned data_size = 0;
+static unsigned line_num = 0;
+static const char * line_start;
+static const char * str;
+
+static inline struct c_expr 
+default_function_array_conversion_on_c_expr(struct c_expr t) {
+  return default_function_array_conversion(t);
+}
+
+static inline tree default_function_array_conversion_on_tree(tree t) {
+  struct c_expr e = {t, TREE_CODE(t)};
+  return default_function_array_conversion(e).value;
+}
+
+#define default_function_array_conversion \
+  default_function_array_conversion_on_tree
+
+//
+//
+//
+
+void c_parse_init (void)
+{
+  /* The only initialization required is of the reserved word
+     identifiers.  */
+  /* Used by c-decl.c, thus must be still be init. */
+  unsigned int i;
+  tree id;
+  int mask = 0;
+
+  mask |= D_CXXONLY;
+  if (!flag_isoc99)
+    mask |= D_C99;
+  if (flag_no_asm)
+    {
+      mask |= D_ASM | D_EXT;
+      if (!flag_isoc99)
+	mask |= D_EXT89;
+    }
+  if (!c_dialect_objc ())
+    mask |= D_OBJC | D_CXX_OBJC;
+
+  ridpointers = GGC_CNEWVEC (tree, (int) RID_MAX);
+  for (i = 0; i < num_c_common_reswords; i++)
+    {
+      /* If a keyword is disabled, do not enter it into the table
+	 and so create a canonical spelling that isn't a keyword.  */
+      if (c_common_reswords[i].disable & mask)
+	{
+	  if (warn_cxx_compat
+	      && (c_common_reswords[i].disable & D_CXXWARN))
+	    {
+	      id = get_identifier (c_common_reswords[i].word);
+	      C_SET_RID_CODE (id, RID_CXX_COMPAT_WARN);
+	      C_IS_RESERVED_WORD (id) = 1;
+	    }
+	  continue;
+	}
+
+      id = get_identifier (c_common_reswords[i].word);
+      C_SET_RID_CODE (id, c_common_reswords[i].rid);
+      C_IS_RESERVED_WORD (id) = 1;
+      ridpointers [(int) c_common_reswords[i].rid] = id;
+    }
+
+  // Also init chartype
+  memset(chartype_, 1, 256);
+  chartype('(') = CHAR_SPECIAL;
+  chartype(')') = CHAR_SPECIAL;
+  chartype('[') = CHAR_SPECIAL;
+  chartype(')') = CHAR_SPECIAL;
+  chartype('{') = CHAR_SPECIAL;
+  chartype('}') = CHAR_SPECIAL;
+  chartype(':') = CHAR_SPECIAL;
+  chartype('"') = CHAR_SPECIAL;
+  chartype('#') = CHAR_SPECIAL;
+  chartype('\0') = CHAR_EOL;
+  chartype('\n') = CHAR_EOL;
+  chartype('\r') = CHAR_EOL;
+  chartype(' ') = CHAR_SPACE;
+  chartype('\t') = CHAR_SPACE;
+  chartype('\f') = CHAR_SPACE;
+  chartype('\v') = CHAR_SPACE;
+  chartype('0') = CHAR_ID | CHAR_NUM;
+  chartype('1') = CHAR_ID | CHAR_NUM;
+  chartype('2') = CHAR_ID | CHAR_NUM;
+  chartype('3') = CHAR_ID | CHAR_NUM;
+  chartype('4') = CHAR_ID | CHAR_NUM;
+  chartype('5') = CHAR_ID | CHAR_NUM;
+  chartype('6') = CHAR_ID | CHAR_NUM;
+  chartype('7') = CHAR_ID | CHAR_NUM;
+  chartype('8') = CHAR_ID | CHAR_NUM;
+  chartype('9') = CHAR_ID | CHAR_NUM;
+  // force show_column
+  flag_show_column = true;
+}
+
+//
+//
+//
+
+#define BLOCK_SIZE (1024*16)
+
+static void read_soure_file(void) {
+  int fd = STDIN_FILENO;
+  if (this_input_filename[0] != '\0')
+    fd = open(this_input_filename, O_RDONLY);
+
+  char * d = (char *)xmalloc(BLOCK_SIZE);
+  unsigned capacity = BLOCK_SIZE;
+  data_size = 0;
+  ssize_t s;
+  while (s = read(fd, d + data_size, BLOCK_SIZE), s) {
+    data_size += s;
+    if (data_size + BLOCK_SIZE > capacity) {
+        capacity *= 2;
+        d = (char *)xrealloc(d, capacity);
+    }
+  }
+  d = (char *)xrealloc(d, data_size+1);
+  d[data_size] = '\0';
+  line_num = 1;
+  data = d;
+  str = d;
+  line_start = d;
+  linemap_add(line_table, LC_ENTER, false, this_input_filename, 1);
+  input_location = linemap_line_start(line_table, 1, 127);
+}
+
+#undef BLOCK_SIZE
+
+static jmp_buf parse_error;
+
+__attribute__ ((noreturn, format (printf, 2, 3)))
+static void throw_error (location_t loc, const char * msg, ...) 
+{
+  diagnostic_info diagnostic;
+  va_list ap;
+
+  va_start (ap, msg);
+  diagnostic_set_info (&diagnostic, msg, &ap, loc, DK_ERROR);
+  report_diagnostic (&diagnostic);
+  va_end (ap);
+  
+  longjmp(parse_error, 1);
+}
+
+static location_t make_loc(const char * str) {
+  location_t res;
+  LINEMAP_POSITION_FOR_COLUMN(res, line_table, str - line_start + 1);
+  return res;
+}
+
+//
+// 
+//
+
+static void spacing(void) {
+  char chr;
+  for (;;) {
+    while (chartype(*str) == CHAR_SPACE) ++str;
+    chr = *str;
+    if (chr == '\0') {
+      break;
+    } else if (chartype(chr) == CHAR_EOL) {
+      ++line_num; 
+      input_location = linemap_line_start(line_table, line_num, 127);
+      if (chr == '\n') 
+        ++str;
+      else if (chr == '\r') {
+        ++str; 
+        if (*str == '\n') ++str;
+      }
+      line_start = str;
+    } else if (chr == '#') {
+      ++str; 
+      while (chartype(*str) != CHAR_EOL) ++str;
+    }
+    else break;
+  }
+}
+
+static void expect_debug(char what, const char * func, const char * file, unsigned line) {
+  if (*str != what)
+    throw_error (make_loc(str), "Expected '%c'. (in %s at %s:%u)", what, func, file, line);
+  ++str;
+  spacing();
+}
+
+#define expect(what) expect_debug(what, __FUNCTION__, __FILE__, __LINE__)
+
+static token parse_quote(void) {
+  token res;
+  res.loc = make_loc(str);
+  const char * start = str;
+  ++str;
+  res.str = str;
+  while (*str != '"' && chartype(*str) != CHAR_EOL) {
+    if (*str == '\\') {
+      ++str;
+      if (chartype(*str) == CHAR_EOL)
+        throw_error(make_loc(str), "Unexpected end of string.");
+    }
+    ++str;
+  }
+  res.len = str - res.str;
+  if (*str != '"')
+    throw_error(make_loc(start), "Unterminated '\"'.");
+  ++str;
+  spacing();
+  return res;
+}
+
+static token try_token(void) {
+  token res;
+  if (*str == '"')
+    return parse_quote();
+  res.loc = make_loc(str);
+  res.str = str;
+  while (chartype(*str) & CHAR_ID)
+    ++str;
+  res.len = str - res.str;
+  if (res.len == 0)
+    return NULL_TOKEN;
+  spacing();
+  return res;
+}
+
+static token parse_token(void) {
+  token res = try_token();
+  if (res.len == 0)
+    throw_error(make_loc(str), "Expected token.");
+  return res;
+}
+
+static token parse_id(void) {
+  if (chartype(*str) == CHAR_ID) {
+    return parse_token();
+  } else if (*str == '(') {
+    expect('(');
+    token what = parse_token();
+    if (!token_eq(what, "id"))
+      throw_error(what.loc, "Expected \"id\".");
+    token res = parse_token();
+    expect(')');
+    return res;
+  } else {
+    throw_error(make_loc(str), "Expected identifier.");
+  }
+}
+
+static bool more_args(void) {
+  return *str != ')' && *str != ':';
+}
+
+//
+//
+//
+
+static tree parse_type(void);
+static tree parse_exp(void);
+
+// return 0 if no option found
+//        1 if option has no args
+//        2 if it has args that need to be parsed
+
+static int get_opt(token * opt) {
+  if (*str == ':') {
+    ++str;
+    if (*str == '(') {
+      ++str;
+      *opt = parse_token();
+      if (*str == ')') {
+        ++str;
+        spacing();
+        return 1;
+      } else {
+        return 2;
+      }
+    } else {
+      *opt = parse_token();
+      return 1;
+    }
+  } else {
+    return 0;
+  }
+}
+
+//
+// Make an attirib (to be processed latter) and add it to the front
+// of the list
+//
+
+static tree parse_attrib(token * opt, bool w_args, tree tail) {
+  tree name = token_to_tree(*opt);
+  tree args = NULL;
+  if (w_args) {
+    if (*str != '(') {
+      tree arg = token_to_tree(parse_token());
+      args = tree_cons(NULL, arg, args);
+    }
+    while (*str != ')') {
+      tree arg = parse_exp();
+      args = tree_cons(NULL, arg, args);
+    }
+    args = nreverse(args);
+    expect(')');
+  }
+  return tree_cons(name, args, tail);
+}
+
+//
+//
+//
+
+struct parms {
+  tree type;
+  size_t size;   // not including "...";
+  struct parm * parms; // not including "...";
+};
+static struct parms parse_fun_parms(void);
+
+static tree parse_array_type(void) {
+  tree type = parse_type();
+  tree size = build_binary_op(0, MINUS_EXPR, parse_exp(), integer_one_node, 1);
+  return build_array_type(type, build_index_type(size));
+}
+
+static tree parse_fun_type(void) {
+  struct parms parms = parse_fun_parms();
+  free(parms.parms);
+  parms.parms = NULL;
+
+  tree ret_type = parse_type();
+
+  return build_function_type(ret_type, parms.type);
+}
+
+static tree parse_tagged_type(enum tree_code tag) {
+  token id = parse_token();
+  //tree type = lookup_tag(tag, get_identifier_with_length(id.str, id.len), false);
+  //if (!type)
+  //  throw_error(id.loc, "Tagged type \"%.*s\" not found.", id.len, id.str);
+  tree type = xref_tag(tag, get_identifier_with_length(id.str, id.len));
+  return type;
+}
+
+static tree parse_type(void) {
+  expect('(');
+  token name = parse_token();
+  tree type;
+  if (token_eq(name, "int"))
+    type = integer_type_node;
+  else if (token_eq(name, "unsigned"))
+    type = unsigned_type_node;
+  else if (token_eq(name, "char"))
+    type = char_type_node;
+  else if (token_eq(name, "void"))
+    type = void_type_node;
+  else if (token_eq(name, "short"))
+    type = short_integer_type_node;
+  else if (token_eq(name, "long"))
+    type = long_integer_type_node;
+  else if (token_eq(name, "long-long"))
+    type = long_long_integer_type_node;
+  else if (token_eq(name, "signed-char"))
+    type = signed_char_type_node;
+  else if (token_eq(name, "unsigned-char"))
+    type = unsigned_char_type_node;
+  else if (token_eq(name, "unsigned-short"))
+    type = short_unsigned_type_node;
+  else if (token_eq(name, "unsigned-int"))
+    type = unsigned_type_node;
+  else if (token_eq(name, "unsigned-long"))
+    type = long_unsigned_type_node;
+  else if (token_eq(name, "unsigned-long-long"))
+    type = long_long_unsigned_type_node;
+  else if (token_eq(name, "float"))
+    type = float_type_node;
+  else if (token_eq(name, "double"))
+    type = double_type_node;
+  else if (token_eq(name, "long-double"))
+    type = long_double_type_node;
+  else if (token_eq(name, ".ptr")) 
+    type = build_pointer_type(parse_type());
+  else if (token_eq(name, ".array"))
+    type = parse_array_type();
+  else if (token_eq(name, ".fun"))
+    type = parse_fun_type();
+  else if (token_eq(name, "struct"))
+    type = parse_tagged_type(RECORD_TYPE);
+  else if (token_eq(name, "enum"))
+    type = parse_tagged_type(ENUMERAL_TYPE);
+  else if (token_eq(name, "union"))
+    type = parse_tagged_type(UNION_TYPE);
+  else {
+    tree decl = lookup_name(token_to_tree(name));
+    if (decl && TREE_CODE (decl) == TYPE_DECL)
+      type = TREE_TYPE(decl);
+    else
+      throw_error(name.loc, "Unknown type: %.*s", name.len, name.str);
+  }
+
+  int quals = 0;
+  while (*str == ':') {
+    ++str;
+    token q = parse_token();
+    if (token_eq(q, "const"))         quals |= TYPE_QUAL_CONST;
+    else if (token_eq(q, "volatile")) quals |= TYPE_QUAL_VOLATILE;
+    else if (token_eq(q, "restrict")) quals |= TYPE_QUAL_RESTRICT;
+    else throw_error(q.loc, "Unknown qualifier: %.*s", q.len, q.str);
+  }
+  if (quals != 0)
+    type = c_build_qualified_type(type, quals);
+  expect(')');
+  return type;
+}
+
+static tree parse_id_exp(location_t loc) {
+  token id = parse_token();
+  return build_external_ref(get_identifier_with_length(id.str, id.len), 0, loc);
+}
+
+static tree parse_literal(bool bare) {
+  token val = parse_token();
+  char tmp[val.len + 1];
+  memcpy(tmp, val.str, val.len);
+  tmp[val.len] = '\0';
+  char * endptr = NULL;
+  long long ival = strtoll(tmp, &endptr, 0);
+  if (endptr != tmp + val.len)
+    throw_error(val.loc, "Expected integer.");
+  tree type = integer_type_node;
+  if (!bare && more_args())
+    type = parse_type();
+  return build_int_cst(type, ival);
+}
+
+static tree parse_float(void) {
+  token val = parse_token();
+  char tmp[val.len + 1];
+  memcpy(tmp, val.str, val.len);
+  tmp[val.len] = '\0';
+  REAL_VALUE_TYPE fval;
+  // fixme: real_from_string does not syntax check
+  real_from_string(&fval, tmp);
+  tree type = parse_type();
+  return build_real(type, fval);
+}
+
+static char * unescape(const char * s, const char * end, char * res) {
+  for (; s != end; ++s)
+no_inc:
+    if (*s == '\\') {
+      ++s;
+      assert(s != end);
+      switch (*s) {
+      case 'a': *res++ = '\a'; break;
+      case 'b': *res++ = '\b'; break;
+      case 'f': *res++ = '\f'; break;
+      case 'n': *res++ = '\n'; break;
+      case 'r': *res++ = '\r'; break;
+      case 't': *res++ = '\t'; break;
+      case 'v': *res++ = '\v'; break;
+      case 'x': {
+        // hex 
+        ++s;
+        char * e = CONST_CAST(char *, s);
+        unsigned val = strtol(s, &e, 16);
+        if (s == e) abort(); // FIXME: Error
+        s = e;
+        if (val > 255) abort(); // FIXME: Error message, out of range 
+        *res++ = (char)val;
+        goto no_inc;
+      } case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': {
+        // oct
+        unsigned val = *s - '0'; ++s;
+        if (s != end && '0' <= *s && *s <= '7') {val *= 8; val += *s - '0'; ++s;}
+        if (s != end && '0' <= *s && *s <= '7') {val *= 8; val += *s - '0'; ++s;}
+        if (val > 255) abort(); // FIXME: Error message, out of range
+        *res++ = (char)val;
+        goto no_inc;
+      } default:
+        *res++ = *s;
+      }
+    } else if (*s != '"') {
+      *res++ = *s;
+    }
+  return res;
+}
+
+static tree parse_char(void) {
+  token val = parse_token();
+  char tmp[val.len + 1];
+  char * end = unescape(val.str, val.str + val.len, tmp);
+  size_t len = end - tmp;
+  if (len > 1)
+    throw_error(val.loc, "Expected token of length one.");
+  return build_int_cst(char_type_node, *tmp);
+}
+
+static tree parse_string(void) {
+  token val = parse_token();
+  char tmp[val.len + 1];
+  char * end = unescape(val.str, val.str + val.len, tmp);
+  *end = '\0';
+  size_t len = end - tmp;
+  tree res = build_string(len+1, tmp);
+  TREE_TYPE(res) = char_array_type_node;
+  res = fix_string_type(res);
+  return res;
+}
+
+static tree parse_exp(void);
+static struct c_expr parse_exp_init(tree type, bool nested);
+
+static tree parse_exp_conv(void) {
+  tree exp = parse_exp();
+  return default_function_array_conversion (exp);
+}
+
+static tree parse_binop(location_t loc, enum tree_code code) {
+  tree lhs = parse_exp_conv();
+  tree rhs = parse_exp_conv();
+  return build_binary_op(loc, code, lhs, rhs, 1);
+}
+
+static tree parse_assign(location_t loc, enum tree_code code) {
+  tree lhs = parse_exp();
+  tree rhs = parse_exp_conv();
+  rhs = default_function_array_conversion(rhs);
+  return build_modify_expr(loc, lhs, code, rhs);
+}
+
+static tree parse_addrof(location_t loc) {
+  tree exp = parse_exp();
+  return build_unary_op(loc, ADDR_EXPR, exp, 1);
+}
+
+static tree parse_deref(location_t loc) {
+  tree exp = parse_exp_conv();
+  return build_indirect_ref(loc, exp, "deref");
+}
+
+static tree parse_cast(location_t loc) {
+  tree type = parse_type();
+  tree exp = parse_exp_conv();
+  tree cast = build_c_cast(type, exp);
+  protected_set_expr_location(cast, loc);
+  return cast;
+}
+
+static tree parse_unop(location_t loc, enum tree_code code) {
+  tree exp = parse_exp_conv();
+  return build_unary_op(loc, code, exp, 0);
+}
+
+static tree parse_list(void) {
+  tree list = NULL;
+  while (*str != ')') {
+    tree exp = parse_exp_conv();
+    list = tree_cons(NULL, exp, list);
+  }
+  return nreverse(list);
+}
+
+static tree parse_call(location_t loc) {
+  tree fun = parse_exp();
+
+  expect('(');
+  parse_token(); // expect "."
+  tree parms = parse_list();
+  expect(')');
+
+  tree call = build_function_call(fun, parms);
+  protected_set_expr_location(call, loc);
+  //if (call == error_mark_node) longjmp(parse_error, 1);
+  return call;
+}
+
+static tree parse_member(location_t loc) {
+  tree datum = parse_exp_conv();
+  token name = parse_id();
+  tree id = get_identifier_with_length(name.str, name.len);
+  tree exp = build_component_ref(datum, id);
+  protected_set_expr_location(exp, loc);
+  return exp;
+}
+
+static tree parse_eif(location_t loc) {
+  tree cond = parse_exp_conv();
+  cond = c_objc_common_truthvalue_conversion(EXPR_LOCATION(cond), cond);
+  tree if_true = parse_exp_conv();
+  tree if_false = parse_exp_conv();
+  tree exp = build_conditional_expr (cond, if_true, if_false);
+  protected_set_expr_location(exp, loc);
+  return exp;
+}
+
+static tree parse_seq(location_t loc) {
+  tree exp = parse_exp();
+  if (*str == ')') return exp;
+  tree res = parse_seq(loc);
+  return build_compound_expr(exp, res);
+}
+
+static void parse_stmts(void);
+
+static tree parse_eblock(location_t loc) {
+  tree stmt = c_begin_stmt_expr ();
+  parse_stmts();
+  tree exp = c_finish_stmt_expr (stmt);
+  SET_EXPR_LOCATION(exp, loc);
+  return exp;
+}
+ 
+static tree try_exp_bare(location_t loc) {
+  if (chartype(*str) == CHAR_ID) return parse_id_exp(loc);
+  if (chartype(*str) & CHAR_NUM) return parse_literal(true);
+  return NULL;
+}
+
+static enum tree_code to_binop_code(const token * what) {
+  if (token_eq(*what, "plus"))   return PLUS_EXPR;
+  if (token_eq(*what, "minus"))  return MINUS_EXPR;
+  if (token_eq(*what, "times"))  return MULT_EXPR;
+  if (token_eq(*what, "div"))    return TRUNC_DIV_EXPR;
+  if (token_eq(*what, "lshift")) return LSHIFT_EXPR;
+  if (token_eq(*what, "rshift")) return RSHIFT_EXPR;
+  if (token_eq(*what, "mod"))    return TRUNC_MOD_EXPR;
+  if (token_eq(*what, "bor"))    return BIT_IOR_EXPR;
+  if (token_eq(*what, "xor"))    return BIT_XOR_EXPR;
+  if (token_eq(*what, "band"))   return BIT_AND_EXPR;
+  return NOP_EXPR;
+}
+
+static tree try_exp(location_t loc, const token * what) {
+
+  if (token_eq(*what, "id")) return parse_id_exp(loc);
+  if (token_eq(*what, "n"))  return parse_literal(false);
+  if (token_eq(*what, "f"))  return parse_float();
+  if (token_eq(*what, "c"))  return parse_char();
+  if (token_eq(*what, "s"))  return parse_string();
+
+  enum tree_code code = to_binop_code(what);
+  if (code != NOP_EXPR) return parse_binop(loc, code);
+
+  if (token_eq(*what, "assign"))
+    return parse_assign(loc, NOP_EXPR);
+  if (token_eq(*what, "c-assign")) {
+    token op = parse_token();
+    code = to_binop_code(&op);
+    if (code == NOP_EXPR)
+      throw_error(op.loc, "Expected binary operator after c-assign.");
+    return parse_assign(loc, code);
+  }
+  
+  if (token_eq(*what, "eq")) return parse_binop(loc, EQ_EXPR);
+  if (token_eq(*what, "ne")) return parse_binop(loc, NE_EXPR);
+  if (token_eq(*what, "lt")) return parse_binop(loc, LT_EXPR);
+  if (token_eq(*what, "gt")) return parse_binop(loc, GT_EXPR);
+  if (token_eq(*what, "le")) return parse_binop(loc, LE_EXPR);
+  if (token_eq(*what, "ge")) return parse_binop(loc, GE_EXPR);
+  if (token_eq(*what, "postinc"))  return parse_unop(loc, POSTINCREMENT_EXPR);
+  if (token_eq(*what, "postdec"))  return parse_unop(loc, POSTDECREMENT_EXPR);
+  if (token_eq(*what, "neg"))      return parse_unop(loc, NEGATE_EXPR);
+  if (token_eq(*what, "not"))      return parse_unop(loc, TRUTH_NOT_EXPR);
+  if (token_eq(*what, "bnot"))     return parse_unop(loc, BIT_NOT_EXPR);
+  if (token_eq(*what, "addrof")) return parse_addrof(loc);
+  if (token_eq(*what, "deref"))  return parse_deref(loc);
+  if (token_eq(*what, "cast")) return parse_cast(loc);
+  if (token_eq(*what, "call")) return parse_call(loc);
+  if (token_eq(*what, "member")) return parse_member(loc);
+  if (token_eq(*what, "eif")) return parse_eif(loc);
+  if (token_eq(*what, "seq")) return parse_seq(loc);
+  if (token_eq(*what, "eblock")) return parse_eblock(loc);
+  return NULL;
+}
+
+static tree parse_exp(void) {
+  location_t loc = make_loc(str);
+  tree res = try_exp_bare(loc);
+  if (res) 
+    return res;
+  expect('(');
+  token what = parse_token();
+  res = try_exp(loc, &what);
+  if (!res)
+    throw_error(loc, "Expected expression.");
+  expect(')');
+  return res;
+}
+
+static struct c_expr parse_init(location_t loc, tree type, bool nested) {
+  if (nested)
+    push_init_level(0);
+  else
+    really_start_incremental_init (type);
+  while (*str != ')') {
+    struct c_expr init = parse_exp_init(NULL, true);
+    process_init_element (init, false);
+  }
+  return pop_init_level (0);
+}
+
+static struct c_expr parse_exp_init(tree type, bool nested) {
+  location_t loc = make_loc(str);
+  struct c_expr init;
+  init.value = try_exp_bare(loc);
+  if (init.value) {
+    init.original_code = TREE_CODE(init.value);
+    return init;
+  }
+  expect('(');
+  token what = parse_token();
+  if (token_eq(what, ".")) {
+    init = parse_init(loc, type, nested);
+  } else {
+    init.value = try_exp(loc, &what);
+    if (init.value)
+      init.original_code = TREE_CODE(init.value);
+    if (init.value
+        && TREE_CODE (init.value) != STRING_CST 
+        && TREE_CODE (init.value) != COMPOUND_LITERAL_EXPR)
+      init = default_function_array_conversion_on_c_expr(init);
+  }
+  if (!init.value)
+    throw_error(loc, "Expected initializer expression.");
+  expect(')');
+  return init;
+}
+
+// parse the fun parameters
+
+struct parm {
+  location_t loc;
+  tree type;
+  token name;
+};
+
+static struct parms parse_fun_parms(void) {
+  struct parms r = {NULL, 0, NULL};
+  expect('(');
+  parse_token(); // should be ".t"
+  size_t alloc_size = 8;
+  r.parms = xmalloc(sizeof(struct parm) * alloc_size);
+  unsigned i = 0;
+  bool w_dots = false;
+  for (;;) {
+    if (i >= alloc_size) {
+      alloc_size = alloc_size * 3 / 2;
+      r.parms = xrealloc(r.parms, sizeof(struct parm) * alloc_size);
+    }
+    if (*str == '(') {
+      r.parms[i].loc = make_loc(str);
+      expect('(');
+      tree type = parse_type();
+      r.type = tree_cons (NULL, type, r.type);
+      r.parms[i].type = type;
+      if (*str != ')') {
+        r.parms[i].name = parse_token();
+      } else {
+        r.parms[i].name = NULL_TOKEN;
+      }
+      expect(')');
+    } else if (*str != ')') {
+      parse_token(); // expect "...";
+      w_dots = true;
+      break;
+    } else {
+      break;
+    }
+    ++i;
+  }
+  r.size = i;
+  if (!w_dots) 
+    r.type = tree_cons (NULL, void_type_node, r.type);
+  r.type = nreverse(r.type);
+  expect(')');
+  return r;
+}
+
+static tree parse_var_init(tree decl, bool top_level) {
+  start_init (decl, NULL, top_level);
+  tree init = parse_exp_init(NULL, false).value;
+  finish_init();
+  return init;
+}
+
+static void parse_top_level_var(location_t loc) {
+  token name = parse_token();
+  tree id = get_identifier_with_length(name.str, name.len);
+  tree type = parse_type();
+  tree decl = build_decl(VAR_DECL, id, type);
+  DECL_SOURCE_LOCATION(decl) = loc;
+
+  int r;
+  token opt;
+  tree attrs = NULL;
+  bool have_static = false, have_extern = false;
+  while ((r = get_opt(&opt))) {
+    if (token_eq(opt, "static")) {
+      have_static = true;
+    } else if (token_eq(opt, "extern")) {
+      have_extern = true;
+    } else if (token_prefix(opt, "__")) {
+      attrs = parse_attrib(&opt, r > 1, attrs);
+    } else {
+      throw_error(opt.loc, "Invalid flag for top-level \"var\" declaration: %.*s", opt.len, opt.str);
+    }
+  }
+  bool need_init = more_args();
+  bool extern_ref = !need_init && have_extern;
+  
+  TREE_PUBLIC(decl) = !have_static;
+  TREE_STATIC(decl) = !extern_ref;
+  DECL_EXTERNAL(decl) = have_extern;
+
+  decl_attributes(&decl, attrs, 0);
+
+  tree init = NULL;
+
+  decl = prep_decl(decl, need_init);
+
+  if (need_init)
+    init = parse_var_init(decl, true);
+
+  finish_decl(decl, init, NULL);
+}
+
+static void parse_struct_union(location_t loc, enum tree_code what) {
+  token name = parse_token();
+  tree id = get_identifier_with_length(name.str, name.len);
+  if (*str == ')') { // just a forward-reference
+    xref_tag(what, id);
+    return;
+  }
+  tree decl = start_struct(what, id);
+  tree fields = NULL;
+  while (*str == '(') {
+    expect('(');
+    tree ftype = parse_type();
+    token fname = try_token();
+    tree fid = fname.str ? get_identifier_with_length(fname.str, fname.len) : NULL;
+    tree bitsize = more_args() ? parse_exp() : NULL;
+    // FIXME: handle bitfields, see grokfield and grokdeclarator (width arg)
+    tree fdecl = build_decl(FIELD_DECL, fid, ftype);
+    TREE_CHAIN(fdecl) = fields;
+    fields = fdecl;
+    expect(')');
+  }
+  fields = nreverse(fields);
+  finish_struct(decl, fields, NULL);
+}
+
+static void parse_enum(location_t loc) {
+  token name = parse_token();
+  tree id = get_identifier_with_length(name.str, name.len);
+  if (*str == ')') { // just a forward-reference
+    xref_tag(ENUMERAL_TYPE, id);
+    return;
+  }
+  tree values = NULL;
+  struct c_enum_contents the_enum;
+  tree type = start_enum (&the_enum, id);
+
+  while (*str == '(') {
+    location_t value_loc = make_loc(str);
+    token n;
+    tree enum_id;
+    tree enum_value = NULL;
+    tree enum_decl;
+
+    expect('(');
+    n = parse_token();
+    enum_id = get_identifier_with_length(n.str, n.len);
+    if (more_args())
+      enum_value = parse_exp();
+    expect(')');
+
+    enum_decl = build_enumerator (&the_enum, enum_id, enum_value, 
+                                  value_loc);
+    TREE_CHAIN (enum_decl) = values;
+    values = enum_decl;
+  }
+
+  values = nreverse (values);
+  finish_enum (type, values, NULL);
+}
+
+static void parse_var(location_t loc) {
+  token name = parse_token();
+  tree id = get_identifier_with_length(name.str, name.len);
+  tree type = parse_type();
+  tree decl = build_decl(VAR_DECL, id, type);
+  DECL_SOURCE_LOCATION(decl) = loc;
+
+  int r;
+  token opt;
+  tree attrs = NULL;
+  while ((r = get_opt(&opt))) {
+    if (token_eq(opt, "register")) {
+      DECL_REGISTER(decl) = true;
+    } else if (token_prefix(opt, "__")) {
+      attrs = parse_attrib(&opt, r > 1, attrs);
+    } else {
+      throw_error(opt.loc, "Invalid flag for \"var\" declaration: %.*s", opt.len, opt.str);
+    }
+  }
+  decl_attributes(&decl, attrs, 0);
+
+  bool need_init = more_args();
+  tree init = NULL;
+
+  decl = prep_decl(decl, need_init);
+
+  if (need_init)
+    init = parse_var_init(decl, false);
+
+  finish_decl(decl, init, NULL);
+}
+
+static void parse_local_label(location_t loc) {
+  token name = parse_token();
+  tree id = token_to_tree(name);
+  tree label = declare_label(id);
+  C_DECLARED_LABEL_FLAG (label) = 1;
+  add_stmt (build_stmt (DECL_EXPR, label));
+}
+
+static void parse_block(location_t loc);
+//static void parse_slist(location_t loc);
+static void parse_stmt(void);
+
+// parse a statement which needs a block around it, for if, switch, etc.
+static tree parse_block_stmt(void) {
+  tree stmt = c_begin_compound_stmt (false);
+  parse_stmt();
+  return c_end_compound_stmt (stmt, false);
+}
+
+static void parse_if(location_t loc) {
+  tree block = c_begin_compound_stmt (false);
+  tree cond = parse_exp_conv();
+  cond = c_objc_common_truthvalue_conversion(EXPR_LOCATION(cond), cond);
+  tree if_true = parse_block_stmt();
+  tree if_false = NULL;
+  if (more_args()) 
+    if_false = parse_block_stmt();
+  c_finish_if_stmt (loc, cond, if_true, if_false, false);
+  tree if_ = add_stmt(c_end_compound_stmt (block, false));
+  SET_EXPR_LOCATION(if_, loc);
+}
+
+static void parse_switch(location_t loc) {
+  tree block = c_begin_compound_stmt (false);
+  tree exp = parse_exp_conv();
+  c_start_case(exp);
+  tree body = parse_block_stmt();
+  c_finish_case(body);
+  tree switch_ = add_stmt(c_end_compound_stmt (block, false));
+  SET_EXPR_LOCATION(switch_, loc);
+}
+
+static void parse_goto(location_t loc) {
+  token id = parse_id();
+  tree goto_ = c_finish_goto_label(get_identifier_with_length(id.str, id.len));
+  SET_EXPR_LOCATION(goto_, loc);
+}
+
+static void parse_label(location_t loc) {
+  token id = parse_token();
+  tree tlab = define_label(id.loc, get_identifier_with_length(id.str, id.len));
+  tree label = add_stmt(build_stmt (LABEL_EXPR, tlab));
+  SET_EXPR_LOCATION(label, loc);
+}
+
+static void parse_case(location_t loc) {
+  tree exp = NULL;
+  if (more_args())
+    exp = parse_exp();
+  tree label = do_case (exp, NULL);
+  SET_EXPR_LOCATION(label, loc);
+}
+
+static bool try_decl(location_t loc, token * what) {
+  if (token_eq(*what, "var"))
+    parse_var(loc);
+  else if (token_eq(*what, "local_label"))
+    parse_local_label(loc);
+  else
+    return false;
+  return true;
+}
+
+static void add_exp_stmt(location_t loc, tree exp) {
+  exp = default_function_array_conversion(exp);
+  exp = c_process_expr_stmt (exp);
+  exp = add_stmt(exp);
+  SET_EXPR_LOCATION(exp, loc);
+}
+
+static bool try_stmt(location_t loc, token * what) {
+  tree exp;
+  if (token_eq(*what, "if"))
+    parse_if(loc);
+  else if (token_eq(*what, ".switch"))
+    parse_switch(loc);
+  else if (token_eq(*what, "goto"))
+    parse_goto(loc);
+  else if (token_eq(*what, "return"))
+    c_finish_return(parse_exp_conv());
+  else if (token_eq(*what, "block"))
+    parse_block(loc);
+  //else if (token_eq(*what, "slist"))
+  //  parse_slist(loc);
+  else if (token_eq(*what, "label"))
+    parse_label(loc);
+  else if (token_eq(*what, "case"))
+    parse_case(loc);
+  else if (token_eq(*what, "noop"))
+    add_stmt(build_empty_stmt());
+  else if ((exp = try_exp(loc, what)))
+    add_exp_stmt(loc, exp);
+  else 
+    return false;
+  return true;
+}
+
+static void parse_stmt(void) {
+  location_t loc = make_loc(str);
+  tree exp = try_exp_bare(loc);
+  if (exp) {
+    add_exp_stmt(loc, exp);
+    return;
+  }
+  expect('(');
+  token what = parse_token();
+  bool res = try_stmt(loc, &what);
+  if (!res)
+    throw_error(loc, "Expected statement.");
+  expect(')');
+}
+
+static void parse_stmts(void) {
+  while (*str != ')') {
+    location_t loc = make_loc(str);
+    tree exp = try_exp_bare(loc);
+    if (exp) {
+      add_exp_stmt(loc, exp);
+      continue;
+    }
+    expect('(');
+    token what = parse_token();
+    if (token_eq(what, "cleanup")) {
+      // first parse cleanup part
+      tree cleanup = parse_block_stmt();
+      expect(')');
+      // now parse rest of block, note that we are _not_ nested inside
+      // another stmt, hence we need to break out when we are done
+      tree rest = c_begin_compound_stmt (false);
+      parse_stmts();
+      rest = c_end_compound_stmt (rest, false);
+      tree stmt = build_stmt(TRY_FINALLY_EXPR, rest, cleanup);
+      SET_EXPR_LOCATION(stmt, loc);
+      add_stmt(stmt);
+      return;
+    }
+    bool res;
+    res = try_decl(loc, &what);
+    if (!res)
+      res = try_stmt(loc, &what);
+    if (!res)
+      throw_error(loc, "Expected declaration or statement.");
+    expect(')');
+  }
+}
+
+static void parse_block(location_t loc) {
+  tree stmt = c_begin_compound_stmt (true);
+  parse_stmts();
+  add_stmt(build_empty_stmt()); 
+  // ^^FIXME: Hack, apparently gcc doesn't like empty blocks, but the
+  //     C front end seams to produce them just fine, need to figure out
+  //     what I am doing differently
+  tree block = add_stmt(c_end_compound_stmt (stmt, true));
+  SET_EXPR_LOCATION(block, loc);
+}
+
+//static void parse_slist(location_t loc) {
+//  tree stmt = c_begin_compound_stmt (false);
+//  parse_stmts();
+//  tree slist = add_stmt(c_end_compound_stmt (stmt, false));
+//  SET_EXPR_LOCATION(slist, loc);
+//}
+
+static void parse_fun(location_t loc) {
+
+  token name = parse_token();
+  tree id = get_identifier_with_length(name.str, name.len);
+  struct parms parms = parse_fun_parms();
+  tree ret_type = parse_type();
+
+  tree fun_type = build_function_type(ret_type, parms.type);
+  
+  tree fn_decl =  build_decl (FUNCTION_DECL, id, fun_type);
+  TREE_PUBLIC (fn_decl) = true;
+  //DECL_EXTERNAL (fn_decl) = true;
+  //DECL_ARTIFICIAL (fn_decl) = false;
+  //DECL_CONTEXT (fn_decl) = NULL;
+  DECL_SOURCE_LOCATION (fn_decl) = loc;
+  //TREE_STATIC (fn_decl) = true;
+
+  // now handle flags, if any
+
+  int r;
+  token opt;
+  tree attrs = NULL;
+  while ((r = get_opt(&opt))) {
+    if (token_eq(opt, "static")) {
+      TREE_PUBLIC(fn_decl) = 0;
+    } else if (token_eq(opt, "extern")) {
+      DECL_EXTERNAL(fn_decl) = 1;
+    } else if (token_prefix(opt, "__")) {
+      attrs = parse_attrib(&opt, r > 1, attrs);
+    } else {
+      throw_error(opt.loc, "Invalid flag for \"fun\" declaration: %.*s", opt.len, opt.str);
+    }
+  }
+  decl_attributes(&fn_decl, attrs, 0);
+
+  if (more_args()) {
+    prep_function(fn_decl);
+
+    struct c_arg_info arg_info = {NULL, NULL, parms.type, NULL, NULL, 0};
+    
+    /* Build the decl. list */
+    unsigned i;
+    tree parm_list = NULL;
+    for (i = 0; i != parms.size; ++i) {
+      struct parm * p = &parms.parms[i];
+      tree type = p->type; 
+      tree id = get_identifier_with_length(p->name.str, p->name.len);
+      if (TREE_CODE(type) == ARRAY_TYPE)
+        type = build_pointer_type (TREE_TYPE(type));
+      else if (TREE_CODE (type) == FUNCTION_TYPE)
+        type = build_pointer_type (TREE_TYPE(type));
+      tree parm_decl = build_decl(PARM_DECL, id, type);
+      // FIXME: Is this always correct
+      DECL_ARG_TYPE (parm_decl) = TREE_TYPE (parm_decl);
+      DECL_SOURCE_LOCATION (parm_decl) = p->loc;
+      TREE_CHAIN(parm_decl) = parm_list;
+      parm_list = parm_decl;
+    }
+    parm_list = nreverse (parm_list);
+    arg_info.parms = parm_list;
+    
+    store_parm_decls_from(&arg_info);
+    
+    location_t loc = make_loc(str);
+    expect('(');
+    parse_token(); // expect "block"
+    parse_block(loc);
+    expect(')');
+
+    finish_function();
+
+  } else {
+    
+    fn_decl = prep_decl(fn_decl, false);
+    finish_decl(fn_decl, NULL, NULL);
+
+  }
+
+  free(parms.parms);
+  parms.parms = NULL;
+
+}
+
+static void parse_talias(location_t loc) {
+  token name = parse_token();
+  tree id = get_identifier_with_length(name.str, name.len);
+  tree type = parse_type();
+  tree decl  = build_decl (TYPE_DECL, id, type);
+  DECL_SOURCE_LOCATION(decl) = loc;
+  decl = prep_decl(decl, false);
+  finish_decl(decl, NULL, NULL);
+}
+
+static void parse_top_level(void) {
+  location_t loc = make_loc(str);
+  expect('(');
+  token what = parse_token();
+  if (token_eq(what, "var"))
+    parse_top_level_var(loc);
+  else if (token_eq(what, "fun"))
+    parse_fun(loc);
+  else if (token_eq(what, "talias"))
+    parse_talias(loc);
+  else if (token_eq(what, ".struct"))
+    parse_struct_union(loc, RECORD_TYPE);
+  else if (token_eq(what, ".union"))
+    parse_struct_union(loc, UNION_TYPE);
+  else if (token_eq(what, ".enum"))
+    parse_enum(loc);
+  else
+    throw_error(loc, "Expected top-level form.");
+  expect(')');
+}
+
+static void parse_translation_unit(void) {
+  spacing();
+  while (*str) {
+    parse_top_level();
+  }
+}
+
+void c_parse_file (void) {
+  read_soure_file();
+  if (!setjmp(parse_error)) {
+    parse_translation_unit();
+  } else /* error */ {
+    // nothing to do
+  }
+}
+
+#if 0
+
+static tree try_stmt(const token * what) {
+  
+}
+
+/*
+
+  COMPOUND_EXPR "," expr
+  COMPOUND_LITERAL_EXPR
+  
+  build_empty_stmt
+
+
+  ?CLEANUP_POINT_EXPR -- full expressions
+ */
+
+#endif
+
Index: gcc/c-tree.h
===================================================================
--- gcc/c-tree.h	(.../vender/gcc/4.4.0)	(revision 449)
+++ gcc/c-tree.h	(.../trunk/gcc)	(revision 449)
@@ -494,8 +494,10 @@
 extern void shadow_tag_warned (const struct c_declspecs *, int);
 extern tree start_enum (struct c_enum_contents *, tree);
 extern int  start_function (struct c_declspecs *, struct c_declarator *, tree);
+extern void prep_function (tree);
 extern tree start_decl (struct c_declarator *, struct c_declspecs *, bool,
 			tree);
+extern tree prep_decl (tree, bool);
 extern tree start_struct (enum tree_code, tree);
 extern void store_parm_decls (void);
 extern void store_parm_decls_from (struct c_arg_info *);
@@ -519,6 +521,8 @@
 extern struct c_declspecs *declspecs_add_attrs (struct c_declspecs *, tree);
 extern struct c_declspecs *finish_declspecs (struct c_declspecs *);
 
+extern tree lookup_tag (enum tree_code, tree, int thislevel_only);
+
 /* in c-objc-common.c */
 extern bool c_objc_common_init (void);
 extern bool c_missing_noreturn_ok_p (tree);
Index: gcc/c-decl.c
===================================================================
--- gcc/c-decl.c	(.../vender/gcc/4.4.0)	(revision 449)
+++ gcc/c-decl.c	(.../trunk/gcc)	(revision 449)
@@ -2632,7 +2632,7 @@
    it is RECORD_TYPE or UNION_TYPE or ENUMERAL_TYPE.
    If the wrong kind of type is found, an error is reported.  */
 
-static tree
+tree
 lookup_tag (enum tree_code code, tree name, int thislevel_only)
 {
   struct c_binding *b = I_TAG_BINDING (name);
@@ -3167,7 +3167,6 @@
 	    bool initialized, tree attributes)
 {
   tree decl;
-  tree tem;
   enum deprecated_states deprecated_state = DEPRECATED_NORMAL;
 
   /* An object declared as __attribute__((deprecated)) suppresses
@@ -3241,41 +3240,6 @@
 	  }
       }
 
-  if (initialized)
-    {
-      if (current_scope == file_scope)
-	TREE_STATIC (decl) = 1;
-
-      /* Tell 'pushdecl' this is an initialized decl
-	 even though we don't yet have the initializer expression.
-	 Also tell 'finish_decl' it may store the real initializer.  */
-      DECL_INITIAL (decl) = error_mark_node;
-    }
-
-  /* If this is a function declaration, write a record describing it to the
-     prototypes file (if requested).  */
-
-  if (TREE_CODE (decl) == FUNCTION_DECL)
-    gen_aux_info_record (decl, 0, 0, TYPE_ARG_TYPES (TREE_TYPE (decl)) != 0);
-
-  /* ANSI specifies that a tentative definition which is not merged with
-     a non-tentative definition behaves exactly like a definition with an
-     initializer equal to zero.  (Section 3.7.2)
-
-     -fno-common gives strict ANSI behavior, though this tends to break
-     a large body of code that grew up without this rule.
-
-     Thread-local variables are never common, since there's no entrenched
-     body of code to break, and it allows more efficient variable references
-     in the presence of dynamic linking.  */
-
-  if (TREE_CODE (decl) == VAR_DECL
-      && !initialized
-      && TREE_PUBLIC (decl)
-      && !DECL_THREAD_LOCAL_P (decl)
-      && !flag_no_common)
-    DECL_COMMON (decl) = 1;
-
   /* Set attributes here so if duplicate decl, will have proper attributes.  */
   decl_attributes (&decl, attributes, 0);
 
@@ -3319,6 +3283,74 @@
     warning (OPT_Wattributes, "inline function %q+D given attribute noinline",
 	     decl);
 
+  return prep_decl (decl, initialized);
+}
+
+tree
+prep_decl (tree decl, bool initialized)
+{
+  tree tem;
+
+  /* Record constancy and volatility.  */
+  c_apply_type_quals_to_decl (TYPE_QUALS(TREE_TYPE(decl)), decl);
+  
+  /* If a type has volatile components, it should be stored in memory.
+     Otherwise, the fact that those components are volatile
+     will be ignored, and would even crash the compiler.
+     Of course, this only makes sense on  VAR,PARM, and RESULT decl's.   */
+  if (C_TYPE_FIELDS_VOLATILE (TREE_TYPE (decl))
+      && (TREE_CODE (decl) == VAR_DECL ||  TREE_CODE (decl) == PARM_DECL
+	  || TREE_CODE (decl) == RESULT_DECL))
+    {
+      /* It is not an error for a structure with volatile fields to
+         be declared register, but reset DECL_REGISTER since it
+         cannot actually go in a register.  */
+      int was_reg = C_DECL_REGISTER (decl);
+      C_DECL_REGISTER (decl) = 0;
+      DECL_REGISTER (decl) = 0;
+      c_mark_addressable (decl);
+      C_DECL_REGISTER (decl) = was_reg;
+    }
+  
+  /* This is the earliest point at which we might know the assembler
+     name of a variable.  Thus, if it's known before this, die horribly.  */
+  gcc_assert (!DECL_ASSEMBLER_NAME_SET_P (decl));
+  
+  if (initialized)
+    {
+      if (current_scope == file_scope)
+        TREE_STATIC (decl) = 1;
+      
+      /* Tell 'pushdecl' this is an initialized decl
+         even though we don't yet have the initializer expression.
+         Also tell 'finish_decl' it may store the real initializer.  */
+      DECL_INITIAL (decl) = error_mark_node;
+    }
+
+  /* If this is a function declaration, write a record describing it to the
+     prototypes file (if requested).  */
+
+  if (TREE_CODE (decl) == FUNCTION_DECL)
+    gen_aux_info_record (decl, 0, 0, TYPE_ARG_TYPES (TREE_TYPE (decl)) != 0);
+
+  /* ANSI specifies that a tentative definition which is not merged with
+     a non-tentative definition behaves exactly like a definition with an
+     initializer equal to zero.  (Section 3.7.2)
+
+     -fno-common gives strict ANSI behavior, though this tends to break
+     a large body of code that grew up without this rule.
+
+     Thread-local variables are never common, since there's no entrenched
+     body of code to break, and it allows more efficient variable references
+     in the presence of dynamic linking.  */
+
+  if (TREE_CODE (decl) == VAR_DECL
+      && !initialized
+      && TREE_PUBLIC (decl)
+      && !DECL_THREAD_LOCAL_P (decl)
+      && !flag_no_common)
+    DECL_COMMON (decl) = 1;
+
   /* C99 6.7.4p3: An inline definition of a function with external
      linkage shall not contain a definition of a modifiable object
      with static storage duration...  */
@@ -4969,31 +5001,6 @@
 	DECL_REGISTER (decl) = 1;
       }
 
-    /* Record constancy and volatility.  */
-    c_apply_type_quals_to_decl (type_quals, decl);
-
-    /* If a type has volatile components, it should be stored in memory.
-       Otherwise, the fact that those components are volatile
-       will be ignored, and would even crash the compiler.
-       Of course, this only makes sense on  VAR,PARM, and RESULT decl's.   */
-    if (C_TYPE_FIELDS_VOLATILE (TREE_TYPE (decl))
-	&& (TREE_CODE (decl) == VAR_DECL ||  TREE_CODE (decl) == PARM_DECL
-	  || TREE_CODE (decl) == RESULT_DECL))
-      {
-	/* It is not an error for a structure with volatile fields to
-	   be declared register, but reset DECL_REGISTER since it
-	   cannot actually go in a register.  */
-	int was_reg = C_DECL_REGISTER (decl);
-	C_DECL_REGISTER (decl) = 0;
-	DECL_REGISTER (decl) = 0;
-	c_mark_addressable (decl);
-	C_DECL_REGISTER (decl) = was_reg;
-      }
-
-  /* This is the earliest point at which we might know the assembler
-     name of a variable.  Thus, if it's known before this, die horribly.  */
-    gcc_assert (!DECL_ASSEMBLER_NAME_SET_P (decl));
-
     return decl;
   }
 }
@@ -6089,35 +6096,8 @@
 start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,
 		tree attributes)
 {
-  tree decl1, old_decl;
-  tree restype, resdecl;
-  struct c_label_context_se *nstack_se;
-  struct c_label_context_vm *nstack_vm;
+  tree decl1;
 
-  current_function_returns_value = 0;  /* Assume, until we see it does.  */
-  current_function_returns_null = 0;
-  current_function_returns_abnormally = 0;
-  warn_about_return_type = 0;
-  c_switch_stack = NULL;
-
-  nstack_se = XOBNEW (&parser_obstack, struct c_label_context_se);
-  nstack_se->labels_def = NULL;
-  nstack_se->labels_used = NULL;
-  nstack_se->next = label_context_stack_se;
-  label_context_stack_se = nstack_se;
-
-  nstack_vm = XOBNEW (&parser_obstack, struct c_label_context_vm);
-  nstack_vm->labels_def = NULL;
-  nstack_vm->labels_used = NULL;
-  nstack_vm->scope = 0;
-  nstack_vm->next = label_context_stack_vm;
-  label_context_stack_vm = nstack_vm;
-
-  /* Indicate no valid break/continue context by setting these variables
-     to some non-null, non-label value.  We'll notice and emit the proper
-     error message in c_finish_bc_stmt.  */
-  c_break_label = c_cont_label = size_zero_node;
-
   decl1 = grokdeclarator (declarator, declspecs, FUNCDEF, true, NULL,
 			  &attributes, DEPRECATED_NORMAL);
 
@@ -6149,6 +6129,43 @@
 	DECL_EXTERNAL (decl1) = !DECL_EXTERNAL (decl1);
     }
 
+  prep_function(decl1);
+
+  return 1;
+}
+
+void 
+prep_function (tree decl1) 
+{
+  tree old_decl;
+  tree restype, resdecl;
+  struct c_label_context_se *nstack_se;
+  struct c_label_context_vm *nstack_vm;
+
+  current_function_returns_value = 0;  /* Assume, until we see it does.  */
+  current_function_returns_null = 0;
+  current_function_returns_abnormally = 0;
+  warn_about_return_type = 0;
+  c_switch_stack = NULL;
+
+  nstack_se = XOBNEW (&parser_obstack, struct c_label_context_se);
+  nstack_se->labels_def = NULL;
+  nstack_se->labels_used = NULL;
+  nstack_se->next = label_context_stack_se;
+  label_context_stack_se = nstack_se;
+
+  nstack_vm = XOBNEW (&parser_obstack, struct c_label_context_vm);
+  nstack_vm->labels_def = NULL;
+  nstack_vm->labels_used = NULL;
+  nstack_vm->scope = 0;
+  nstack_vm->next = label_context_stack_vm;
+  label_context_stack_vm = nstack_vm;
+
+  /* Indicate no valid break/continue context by setting these variables
+     to some non-null, non-label value.  We'll notice and emit the proper
+     error message in c_finish_bc_stmt.  */
+  c_break_label = c_cont_label = size_zero_node;
+
   announce_function (decl1);
 
   if (!COMPLETE_OR_VOID_TYPE_P (TREE_TYPE (TREE_TYPE (decl1))))
@@ -6308,8 +6325,6 @@
   DECL_RESULT (current_function_decl) = resdecl;
 
   start_fname_decls ();
-
-  return 1;
 }
 
 /* Subroutine of store_parm_decls which handles new-style function
Index: gcc/c-opts.c
===================================================================
--- gcc/c-opts.c	(.../vender/gcc/4.4.0)	(revision 449)
+++ gcc/c-opts.c	(.../trunk/gcc)	(revision 449)
@@ -57,7 +57,7 @@
 cpp_options *cpp_opts;
 
 /* Input filename.  */
-static const char *this_input_filename;
+const char *this_input_filename;
 
 /* Filename and stream for preprocessed output.  */
 static const char *out_fname;
@@ -1163,6 +1163,7 @@
      immediately.  */
   errorcount += cpp_errors (parse_in);
 
+#ifndef NO_CPP
   *pfilename = this_input_filename
     = cpp_read_main_file (parse_in, in_fnames[0]);
   /* Don't do any compilation or preprocessing if there is no input file.  */
@@ -1171,6 +1172,9 @@
       errorcount++;
       return false;
     }
+#else
+  this_input_filename = in_fnames[0];
+#endif
 
   if (flag_working_directory
       && flag_preprocess_only && !flag_no_line_commands)
@@ -1257,6 +1261,7 @@
 	(*debug_hooks->end_source_file) (0);
       if (++i >= num_in_fnames)
 	break;
+#ifndef NO_CPP
       cpp_undef_all (parse_in);
       cpp_clear_file_cache (parse_in);
       this_input_filename
@@ -1265,6 +1270,9 @@
 	 cpplib has issued a diagnostic.  */
       if (!this_input_filename)
 	break;
+#else
+      this_input_filename = in_fnames[i];
+#endif
     }
 }
 

Property changes on: gcc
___________________________________________________________________
Name: svn:ignore
   + testsuite
cp




Property changes on: .
___________________________________________________________________
Name: svn:ignore
   + mpfr
gmp
libstdc++-v3



