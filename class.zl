import_file "class-simple.zlh";

/* 
 * Example class definition 
 * (slightly out of date)
 *

  class Y : public X {
    struct D {
      ...
    };
    D d;
    virtual Y make_y();
    virtual D foo();
  }

  user_type Y {
    make_subtype X; // this must come first otherwise X may be redefined by import
    import X;
    struct D {
    };
    class _VTable;
    struct _Data {
      _VTable * _vptr;
      ...
    };
    finalize user_type _Data;
    class _VTable { / must come after _Data and finalize user_type;
      Y (*make_y)();
      D (*foo());
    }
    static _VTable _vtable;
    ...
    now come access macros and functions in the order they appear
    ...
    init() : static_constructor ...;
    map _vptr ...;
    void _constructor() ..;
  }
 */

typedef struct Collect {
  bool virtual_override;
  Syntax * this_type;
} Collect;

.class ParseClass {
public:
  Mark * mark;

  Match * m;

  Syntax * class_s;
  Environ * env;

  Syntax * name;
  Syntax * body;
  Syntax * parent_s;

  UserType * parent;

  Context * context;

  Environ * lenv;
  
  Module * parent_m;
  UserType * parent_vtable;
  Syntax * parent_vtable_n;
  Syntax * vtable;
  SyntaxList * struct_p;
  SyntaxList * struct_b;
  UserTypeBuilder * builder;
  //SyntaxList * module_p;
  //SyntaxList * module_b;
  SyntaxList * vtable_b;
  SyntaxList * vtable_i;
  SyntaxList * exports;
  SyntaxList * fields[2];

  bool need_constructor;
  SyntaxList * constructor_code[2];
  Syntax * constructor;

  bool need_copy_constructor;
  SyntaxList * copy_constructor_code[2];
  Syntax * copy_constructor;

  bool need_assign;
  SyntaxList * assign_code;
  Syntax * assign;

  bool need_destructor;
  SyntaxList * destructor_code;
  Syntax * destructor;
  Collect destructor_collect;

  virtual Syntax * parse(Syntax * p_, Environ * e_, Mark * mark_) {

    class_s = p_;
    env = e_;
    mark = mark_;
    
    init_match();
    
    if (!body) {
      //printf("DONE (declare only) %s\n", syntax_to_string(name));
      return replace(syntax {declare_user_type name;}, m, mark);
    }

    init();

    if (parent) {
      import_parent();
      init_parent_info();
      add_parent_info();
    }

    add_other_info();

    Syntax * err = parse_body();
    if (err) return err;

    parse_special_forward();

    if (!vtable_i->empty())
      create_vtable();

    builder->add(replace(
                   syntax {struct _Data {$1; $2;};},
                   match_local(m, struct_p, struct_b, 0),
                   mark));
    builder->add(replace(
                   syntax {finalize_user_type struct _Data;},
                   m,
                   mark));
    builder->add(replace(
                   raw_syntax (add_prop fields (. @$1 @$2)),
                   match_local(m, fields[0], fields[1], 0),
                   mark));

    //module_b->append(replace(
    //                   syntax {export $1;},
    //                   match_local(m, exports, 0),
    //                   mark));

    create_special();

    builder->finalize();
    //printf("DONE %s\n", syntax_to_string(name));
    //dump_syntax(module_);
    //printf("---\n");
    return replace(raw_syntax(@), NULL, mark);
  }

  virtual void init_match() {
    m = match_args(0, raw_syntax (name @ body :(public parent_n) :(vtable_class (reparse vtable_class class))), class_s, mark);
    name = m->var(syntax name);
    body = m->var(syntax body);
  }

  virtual void init() {
    parent_s = m->var(syntax parent_n);
    parent = parent_s ? user_type_info(parent_s, env) : NULL;

    context = empty_context();

    //printf("parse_class %s %s\n", syntax_to_string(name));
    
    parent_m = NULL;
    parent_vtable = NULL;
    parent_vtable_n = NULL;
    vtable = NULL;
    struct_p = new_syntax_list();
    struct_b = new_syntax_list();
    //module_p = new_syntax_list();
    //module_b = new_syntax_list();
    builder = new_user_type_builder(name, env);
    printf("USER TYPE BUILDER = %p\n", builder);
    lenv = builder->env;
    vtable_b = new_syntax_list();
    vtable_i = new_syntax_list();
    exports  = new_syntax_list();
    fields[0] = new_syntax_list();
    fields[1] = new_syntax_list();

    m = match(m, syntax _Data, replace_context(syntax _Data, context));
    m = match(m, syntax _parent, replace_context(syntax _parent, context));
    m = match(m, syntax _VTable, replace_context(syntax _VTable, context));
    m = match(m, syntax _vtable, replace_context(syntax _vtable, context));
    m = match(m, syntax _vptr, replace_context(syntax _vptr, context));
    m = match(m, syntax _set_vptr, replace_context(syntax _set_vptr, context));
    m = match(m, syntax _constructor, replace_context(syntax _constructor, context));
    m = match(m, syntax _destructor, replace_context(syntax _destructor, context));
    m = match(m, syntax _copy_constructor, replace_context(syntax _copy_constructor, context));
    m = match(m, syntax _assign, replace_context(syntax _assign, context));
    m = match(m, syntax _vtable_init, replace_context(syntax _vtable_init, context));
    m = match(m, syntax fields, replace_context(syntax fields, context));
    m = match(m, syntax this_type, replace_context(syntax this_type, context));
    
    init_special_funs();
  }

  virtual void add_other_info() {
  }

  virtual void init_parent_info() {
    parent_m = parent->module;
    parent_vtable_n = replace(syntax parent_n::_VTable, m, mark);
    parent_vtable = user_type_info(parent_vtable_n, env);
  }

  virtual void import_parent() {
    builder->add(replace(syntax {import parent_n;}, m, mark));

    //SyntaxEnum * itr = parent_m->symbols();
    //Syntax * syn;
    //while ((syn = itr->next())) {
    //  exports->append(syn);
    //}
  }

  virtual void add_parent_info() {
    parse_class_var(partly_expand(replace(syntax {parent_n _parent;}, m, mark), FieldPos, lenv),
                    struct_p);
    register_field(m->var(syntax _parent), 
                   replace(raw_syntax (parent_n), m, mark), 0);
    
    builder->add(replace(syntax {macro cast_up(p) {&(*p).._parent;}}, m, mark));
    builder->add(replace(syntax {macro cast_down(p) {reinterpret_cast<name *>(p);}}, m, mark));
    builder->add(replace(syntax {make_subtype parent_n cast_up cast_down;}, m, mark));
  }

  Syntax * parse_body() {
    SyntaxEnum * itr = partly_expand_list(match(NULL, raw_syntax ({...} @body), body)->varl(syntax body),
                                          FieldPos, lenv);
    Syntax * member;
    while ((member = itr->next)) {
      Match * m0 = match(m, raw_syntax (what n @ type @_), member);
      const char * what = syntax_to_string(m0->var(syntax what));

      // ignore access control labels for now
      if (strcmp(what, "label")==0) continue;

      Syntax * err = NULL;
      if (strcmp(what, "var")==0) {
        parse_class_var(member, struct_b);
        register_field(m0->var(syntax n), m0->var(syntax type), 1);
      } else if (strcmp(what, "alias")==0) {
        Match * m0 = match(m, raw_syntax (what n type value @_), member);
        //builder->add(replace(raw_syntax (macro n (:(this (reparse this this))) value), m0, mark));
        builder->add(replace(syntax {macro n (:this ths = this) {({__shadow typeof(ths) fluid this = ths; value;});}}, m0, mark));
        if (member->flag(syntax need_constructor))
          register_field(m0->var(syntax n), m0->var(syntax type), 1);
      } else if (strcmp(what, "fun")==0) {
        err = parse_class_fun(member, NULL);      
      } else if (strcmp(what, "add_prop")==0) {
        builder->add(member);
      } else {
        builder->add(member);
      }
      if (err) return err;
      exports->append(m0->var(syntax n));
    }
    return NULL;
  }

  virtual void parse_special_forward() {
    // Parse special functions as forward declarations in order to build
    // necessary vptr and related info, for now only handle the _destructor

    Syntax * destrtr = NULL;

    if (destructor) {
      destrtr = destructor;
    } else if (need_destructor) {
      destrtr = partly_expand(replace(syntax{void * _destructor();}, m, mark), FieldPos, lenv);
    }
    if (destrtr)
      parse_class_fun(destrtr, &destructor_collect);
  }

  void create_vtable() {

    SyntaxList * flags = new_syntax_list();
    if (parent_vtable) // inherit parent vtable if one
      flags->append_flag(replace(raw_syntax(public $1), 
                                 match_local(m, parent_vtable_n, NULL), mark));
    if (m->var(syntax vtable_flag))
      flags->append_flag(m->var(syntax vtable_flag));
    
    // create new vtable class, 
    vtable = replace (raw_syntax(vtable_class _VTable @$1 ({...} $2)),
                      match_local(m, flags, vtable_b, 0),
                      mark);
    
    // create static vtable obj
    // create init function
    //   and add init code
    builder->add(replace(raw_syntax (vtable_class _VTable), m, mark));
    builder->add(replace(
                       syntax {void _vtable_init(_VTable * _vt) {$1;} },
                       match_local(m, vtable_i, 0),
                       mark));
    exports->append(replace(syntax _vtable_init, m, mark));
    
    if (parent_vtable) {
      builder->add(replace(
                     syntax {__static_constructor void init() {parent_n::_vtable_init(&_vtable); _vtable_init(&_vtable);}},
                     m, mark));
    } else {
      builder->add(replace(
                     syntax {__static_constructor void init() {_vtable_init(&_vtable);}},
                     m, mark));
    }
    
    //printf("Adding _vptr\n");
    if (parent_vtable) {
      builder->add(replace(
                     syntax {macro _vptr (:this ths = this) 
                       {(_VTable *)(implicit_cast<parent_n *>(ths)->_vptr);}},
                     m, mark));
    } else {
      Syntax * v = replace(raw_syntax (var (mid _vptr) (.ptr (mid _VTable))), m, mark);
      parse_class_var(v, struct_p); // Note: beginning of structure but end of module
      builder->add(replace(
                     syntax {macro _set_vptr (:this ths = this, other) 
                       {(*implicit_cast<name *>(ths)).._vptr = other;}}, 
                     m, mark));
    }
    exports->append(replace(syntax _vptr, m, mark));
    Syntax * assign = replace(syntax (_set_vptr(&_vtable)), m, mark);
    need_constructor = true;
    constructor_code[0]->append(assign);
    need_copy_constructor = true;
    copy_constructor_code[0]->append(assign);
    
    exports->append(replace(syntax _VTable, m, mark));
    exports->append(replace(syntax _VTable`outer, m, mark));
    
    builder->add(vtable);
    builder->add(replace(syntax {_VTable _vtable;}, m, mark));
  }

  virtual void create_special() {
    destructor_code->reverse();

    if (constructor) {
      Match * m0 = match(m, raw_syntax (_ _ _ _ $body @_), constructor);
      constructor =
        partly_expand(
          replace(syntax{void _constructor() {$1; $2; $body;}}, 
                  match_local(m0, constructor_code[0], constructor_code[1], 0), mark), 
          FieldPos, lenv);
    } else if (need_constructor) {
      constructor =
        partly_expand(
          replace(syntax{void _constructor() {$1; $2;}}, 
                  match_local(m, constructor_code[0], constructor_code[1], 0), mark), 
          FieldPos, lenv);
    }
    if (constructor)
      parse_class_fun(constructor, NULL);

    if (copy_constructor) {
      Match * m0 = match(m, raw_syntax (w n parms ret body @_), copy_constructor);
      copy_constructor =
        replace(raw_syntax(w n parms ret (block $1 $2 body)),
                match_local(m0, constructor_code[0], constructor_code[1], 0), mark);
      // yes constructor_code, not copy_constructor_code
    } else if (need_copy_constructor) {
      copy_constructor =
        partly_expand(
          replace(syntax{void _copy_constructor(const name & other) {$1; $2; }}, 
                  match_local(m, copy_constructor_code[0], copy_constructor_code[1], 0), mark), 
          FieldPos, lenv);
    }
    if (copy_constructor)
      parse_class_fun(copy_constructor, NULL);

    if (need_assign && !assign) {
      assign =
        partly_expand(
          replace(syntax{void _assign(const name & other) {$1;}}, 
                  match_local(m, assign_code, 0), mark), 
          FieldPos, lenv);
    }
    if (assign) // don't allow virtual assign for now
      parse_class_fun(assign, NULL);

    if (destructor) {
      Match * m0 = match(m, raw_syntax ($w $n $parms $ret $body @rest), destructor);    
      destructor =
        replace(raw_syntax($w $n $parms (.ptr (void)) (block $body $1 (return this)) @rest), 
                match_local(m0, destructor_code, 0), mark);
    } else if (need_destructor) {
      destructor =
        partly_expand(
          replace(syntax{void * _destructor() {$1; return this;}}, 
                  match_local(m, destructor_code, 0), mark), 
          FieldPos, lenv);
    }
    if (destructor)
      parse_class_fun_body(destructor, &destructor_collect);
  }

  virtual void parse_class_var(Syntax * p, SyntaxList * struct_b) {
    //printf("parse_class_var: %s\n", syntax_to_string(p));
    __shadow Match * m = match_args(m, raw_syntax (n @rest), p);
    bool is_static = p->flag(syntax static);
    
    // FIXME: handle flags
    if (is_static) {
      builder->add(replace(raw_syntax(var (` (mid n) internal) (mid @rest)), m, mark));
      builder->add(replace(syntax {macro n () {n`internal;}}, m, mark));
    } else {
      struct_b->append(p);
      // FIXME: (name *)(this) may cast away const
      builder->add(replace(syntax {macro n (:this ths = this) {(*(name *)(ths))..n;}}, m, mark));
    }
  }
  
  virtual Syntax * parse_class_fun(Syntax * p, struct Collect * collect) {
    //printf("parse_class_fun: %s\n", syntax_to_string(p));
    __shadow Match * m = match_args(m, raw_syntax (n parms ret @ body @rest), p);
    m = match_args(m, raw_syntax (@parms), m->var(syntax parms));
    //printf("STATIC? %d   VIRTUAL? %d\n", is_static, is_virtual);
    //assert(!(is_static && is_virtual)); // FIXME Error message

    Syntax * class_name = m->var(syntax name);
    Syntax * name = m->var(syntax n);
    if (name->eq(class_name)) {
      Syntax * parms = m->var(syntax parms);
      if (parms->num_args() == 0) {
        //printf("DEFAULT CONSTRUCTOR\n");
        constructor = replace(raw_syntax(fun _constructor (. @parms) ret body @rest), m, mark);
        return NULL;
      } else if (parms->num_args() == 1) {
        //printf("COPY CONSTRUCTOR\n");
        copy_constructor = replace(raw_syntax(fun _copy_constructor (. @parms) ret body @rest), m, mark);
        return NULL;
      } else {
        return error(p, "Only default and copy constructor supported at this time.");
      }
    } else if (name->eq(raw_syntax (operator =))) {
      //printf("ASSIGN\n");
      assign = replace(raw_syntax(fun _assign (. @parms) ret body @rest), m, mark);
      return NULL;
    } else if (!name->simple() && name->part(0)->eq(syntax ~) && name->part(1)->eq(class_name)) {
      //printf("DESTRUCTOR\n");
      // change the return type to "void *", the body will get fixed up later
      destructor = replace(raw_syntax(fun _destructor (. @parms) (.ptr void) body @rest), m, mark);
      return NULL;
    }

    // FIXME: handle flags
    bool is_static = p->flag(syntax static);
    bool is_virtual = p->flag(syntax virtual);

    // create unique name vtable entry, needs to different so that we
    // don't confuse vtable entries for special functions such as
    // _destructor with the real function
    char sbuf[1024];
    snprintf(sbuf, 1024, "%s$fp", syntax_to_string(m->var(syntax n)));
    m = match(m, syntax fpn,
              replace_context(string_to_syntax(sbuf), get_context(m->var(syntax n))));
  
    bool virtual_override = parent_vtable && parent_vtable->module->have_symbol(m->var(syntax fpn));

    if (!is_virtual && virtual_override)
      is_virtual = true;

    Syntax * this_type = NULL;
    if (!is_static) {
      if (virtual_override) {
        this_type = get_symbol_prop(replace(raw_syntax(:: (:: parent_n _VTable) fpn), m, mark),
                                    syntax this_type,
                                    env);
        //replace(raw_syntax(.tprop (.type (.tprop (-> (reinterpret_cast 
        //                                                (.ptr ((:: parent_n _VTable))) 0) fpn) 
        //                                    inner)) (parm 0)), m, mark);
      } else {
        this_type = replace(raw_syntax(.ptr name), m, mark);
      }
    }
  
    SyntaxList * macro_parms = new_syntax_list();
    SyntaxList * call_parms  = new_syntax_list();
  
    //if (!is_static) 
    //  call_parms->append(replace(syntax ((name  *)ths), m, mark));
    SyntaxEnum * parms_enum = m->varl(syntax parms);
    unsigned i = 0;
    Syntax * parm;
    while ((parm = parms_enum->next())) {
      char sbuf[8];
      snprintf(sbuf, 8, "arg%d", i);
      Syntax * arg = replace(string_to_syntax(sbuf), 0, mark);
      macro_parms->append(arg);
      call_parms->append(arg);
      ++i;
    }
    if (!is_static)
      macro_parms->append(replace(syntax (:this ths = this), m, mark));
    SyntaxList * new_parms = mk_method_parms(this_type, m->varl(syntax parms));
    
    if (!collect && m->var(syntax body)) {
      mk_method_defn(m, virtual_override, this_type, m->varl(syntax parms));
    } else {
      builder->add(replace(raw_syntax (fun (` (mid n) internal) (.(mid $1)) (mid ret)),
                           match_local(m, new_parms, 0), mark));
      collect->virtual_override = virtual_override;
      collect->this_type = this_type;
    }
    
    Syntax * call_nv = mk_call(replace(syntax n`internal, m, mark),
                               !is_static ? replace(syntax ths, m, mark) : NULL, 
                               call_parms);
    builder->add(replace(syntax {macro n`non_virtual ($1) :typed_parms($2) {$3;}},
                         match_local(m, macro_parms, m->var(syntax parms), call_nv, 0), mark));
    
    if (is_virtual) {
      //m = match(m, syntax fpn, m->var(syntax n));
      if (!virtual_override) {
        Syntax * call_v = mk_call(replace(raw_syntax (-> (-> this _vptr) fpn), m, mark),
                                  replace(syntax this, m, mark),
                                  call_parms);
        builder->add(replace(
                       syntax {macro n ($1) :typed_parms($2) {({__shadow name * fluid this = ths; $3;});}},
                       //syntax {macro n ($1) {(ths->_vptr->fpn)($2);}},
                       match_local(m, macro_parms, m->var(syntax parms), call_v, 0),
                       mark));
        m = match(m, syntax pfun, 
                  replace(raw_syntax (.ptr (.fun (.(mid $1)) (mid ret))), match_local(m, new_parms, 0), mark));
        vtable_b->append(replace(raw_syntax (var (mid fpn) (mid pfun)), m, mark));
        vtable_b->append(replace(raw_syntax (add_prop fpn this_type $1), 
                                 match_local(m, this_type, 0), mark));
      }
      vtable_i->append(replace(raw_syntax (assign (-> (id _vt) (id (mid fpn))) 
                                           (id (` (mid n) internal))), m, mark));
    } else {
      builder->add(replace(syntax {macro n ($1) :typed_parms($2) {$3;}},
                           match_local(m, macro_parms, m->var(syntax parms), call_nv, 0), mark));
    }

    return NULL;
  }

  virtual Syntax * mk_call(Syntax * fun, Syntax * ths, SyntaxList * parms) {
    if (ths)
      return replace(raw_syntax (call $1 (. $2 $3)), 
                     match_local(NULL, fun, ths, parms, NULL), mark);
    else
      return replace(raw_syntax (call $1 (. $2)), 
                     match_local(NULL, fun, parms, NULL), mark);
  }

  virtual SyntaxList * mk_method_parms(Syntax * this_type, SyntaxEnum * parms) {
    SyntaxList * new_parms = new_syntax_list();
    if (this_type) 
      new_parms->append(replace(raw_syntax($1 (fluid this)), 
                                match_local(NULL, this_type, NULL), mark));
    new_parms->append_all(parms);
    return new_parms;
  }

  virtual Syntax * parse_class_fun_body(Syntax * p, Collect * collect) {
    //printf("parse_class_fun: %s\n", syntax_to_string(p));
    __shadow Match * m = match_args(m, raw_syntax (n parms ret body @rest), p);
    m = match_args(m, raw_syntax (@parms), m->var(syntax parms));
    
    // FIXME: handle flags

    mk_method_defn(m, collect->virtual_override, collect->this_type, m->varl(syntax parms));
    
    return NULL;
  }

  Syntax * mk_method_defn(Match * m, bool virtual_override, Syntax * this_type, SyntaxEnum * parms) {
    SyntaxList * new_parms = mk_method_parms(this_type, parms);
    if (virtual_override)
      body = 
        replace(raw_syntax(block (var :__shadow (fluid this) (.ptr name) (cast (.ptr name) this)) 
                           body), m, mark);
    else
      body = m->var(syntax body);
    body = mk_method_body(this_type, body);
    builder->add(replace(raw_syntax (fun (` (mid n) internal) (.(mid $1)) (mid ret) (mid $2)),
                         match_local(m, new_parms, body, 0), mark));
  }

  virtual Syntax * mk_method_body(Syntax * this_type, Syntax * body) {
    return body;
  }

  virtual void init_special_funs() {
    need_constructor = false;
    constructor_code[0] = new_syntax_list();
    constructor_code[1] = new_syntax_list();
    constructor = NULL;
    
    need_copy_constructor = false;
    copy_constructor_code[0] = new_syntax_list();
    copy_constructor_code[1] = new_syntax_list();
    copy_constructor = NULL;
    
    need_assign = false;
    assign_code = new_syntax_list();
    assign = NULL;
    
    need_destructor = false;
    destructor_code = new_syntax_list();
    destructor = NULL;
    destructor_collect.virtual_override = false;
    destructor_collect.this_type = NULL;
  }
  
  // FIXME: Rename
  virtual void register_field(Syntax * name, Syntax * type, unsigned which) {
    Match * m0 = match(m, syntax n, name);

    fields[which]->append(name);
    
    if (symbol_exists(syntax _constructor, type, mark, lenv)) {
      need_constructor = true;
      constructor_code[which]->append(
        replace(raw_syntax(member (mid n) (call _constructor (.))), m0, mark));
    }
    
    if (symbol_exists(syntax _copy_constructor, type, mark, lenv))
      need_copy_constructor = true;
    copy_constructor_code[which]->append(
      replace(raw_syntax(init-assign (mid n) (member other (mid n))), 
              m0, mark));
    
    if (symbol_exists(syntax _assign, type, mark, lenv))
      need_assign = true;
    assign_code->append(
      replace(raw_syntax(assign (mid n) (member other (mid n))), 
              m0, mark));
    
    if (symbol_exists(syntax _destructor, type, mark, lenv)) {
      need_destructor = true;
      destructor_code->append(
        replace(raw_syntax(member (mid n) (call (` _destructor non_virtual) (.))), m0, mark));
    }
  }
};

Syntax * parse_class(Syntax * p, Environ * env) {
  ParseClass pc;
  return pc.parse(p, env, new_mark());
}
