import_file "class.zl";

.class ParseClassGccABI : public ParseClass {

  Collect base_destructor_collect;
  Collect deleting_destructor_collect;
  bool need_deleting_destructor;

  virtual void init() {
    ParseClass::init`non_virtual();
    m = match(m, syntax _base_constructor, replace_context(syntax _base_constructor, context));
    m = match(m, syntax _base_destructor, replace_context(syntax _base_destructor, context));
    m = match(m, syntax _deleting_destructor, replace_context(syntax _deleting_destructor, context));
    m = match(m, syntax _VTableBase, replace_context(syntax _VTableBase, context));
    base_destructor_collect.virtual_override = false;
    base_destructor_collect.this_type = NULL;
    deleting_destructor_collect.virtual_override = false;
    deleting_destructor_collect.this_type = NULL;
    need_deleting_destructor = false;
  }
  
  virtual Syntax * parse_class_fun(Syntax * p, struct Collect * collect) {
    printf("MAYBE: %s %s\n", syntax_to_string(this->name), syntax_to_string(p));
    Syntax * err;
    err = ParseClass::parse_class_fun`non_virtual(p, collect);
    if (err) return err;
    // Now we need to see if we are parsing a constructor or
    // destructor, if so we need to rename it to _base_* and
    // emit another copy to confirm to the gcc abi which expects it.
    // We also need to possible emit a deleting destructor.
    // The second copy of the destructor, however, is not virtual, so we
    // we need to pull that out.
    __shadow Match * m = match_args(m, raw_syntax (n @ :virtual @rest), p);
    
    Syntax * name = expand_id(m->var(syntax n), lenv);
    Syntax * again = NULL;
    if (name->eq(syntax _constructor)) {
      //assert(collect == NULL);
      again = replace(raw_syntax(fun _base_constructor @rest), m, mark);
      return ParseClass::parse_class_fun`non_virtual(again, NULL);
    } else if (name->eq(syntax _destructor)) {
      if (p->flag(syntax virtual) || (collect && collect->virtual_override))
        need_deleting_destructor = true;
      //printf("NOW WHAT?: %s\n", syntax_to_string(p));
      again = replace(raw_syntax(fun _base_destructor @rest), m, mark);
      printf("AGAIN: %s %s\n", syntax_to_string(this->name), syntax_to_string(again));
      err = ParseClass::parse_class_fun`non_virtual(again, &base_destructor_collect);
      if (err) return err;
      if (!need_deleting_destructor) return NULL;
      again = replace(raw_syntax(fun _deleting_destructor (.) (void) :virtual), m, mark);
      err = ParseClass::parse_class_fun`non_virtual(again, &deleting_destructor_collect);
    }
    return NULL;
  }
  
  virtual Syntax * finish_class_fun(Syntax * p, Collect * collect, bool inline_) {
    printf("FINISH IT: %s : %s\n", syntax_to_string(name), syntax_to_string(p));
    Syntax * err;
    err = ParseClass::finish_class_fun`non_virtual(p, collect, inline_);
    if (err) return err;
    __shadow Match * m = match_args(m, raw_syntax (n @ :virtual @rest), p);
    Syntax * name = expand_id(m->var(syntax n), lenv);
    Syntax * again = NULL;
    if (name->eq(syntax _destructor)) {
      again = replace(raw_syntax(fun _base_destructor @rest), m, mark);
      printf("again: %s %s\n", syntax_to_string(this->name), syntax_to_string(again));
      err = ParseClass::finish_class_fun`non_virtual(again, &base_destructor_collect, inline_);
      if (err) return err;
      if (!need_deleting_destructor) return NULL;
      again = replace(syntax {void _deleting_destructor() {void * ptr = _destructor`non_virtual(); __raw(free (name) ptr);}}, 
                      m, mark);
      again = partly_expand(again, FieldPos, lenv);
      //printf("AGAINv22: %s\n", syntax_to_string(again));
      err = ParseClass::finish_class_fun`non_virtual(again, &deleting_destructor_collect, inline_);
      if (err) return err;
    }
    return NULL;
  }

  virtual void create_vtable() {
//     if (!parent_vtable) {
//       SyntaxList * tmp;
//       tmp = new_syntax_list();
//       tmp->append(replace(raw_syntax(var _offset_to_top (long)), m, mark));
//       tmp->append(replace(raw_syntax(var _typeinfo (.ptr (void))), m, mark));
//       tmp->append_all(vtable_b->elements());
//       vtable_b = tmp;
//       tmp = new_syntax_list();
//       tmp->append(replace(raw_syntax(assign (-> _vt _offset_to_top) 0), m, mark));
//       tmp->append(replace(raw_syntax(assign (-> _vt _typeinfo) 0), m, mark));
//       tmp->append_all(vtable_i->elements());
//       vtable_i = tmp;
//     }
    ParseClass::create_vtable`non_virtual();
  }
};

extern "C"
Syntax * parse_class_gcc_abi(Syntax * p, Environ * env) {
  ParseClassGccABI * pc = new ParseClassGccABI;
  return pc->parse(p, env, NULL);
}

unsigned _abi_list_size = 1;
AbiInfo _abi_list[1] = {{"gcc", NULL, parse_class_gcc_abi, "gcc_abi_info", NULL}};

