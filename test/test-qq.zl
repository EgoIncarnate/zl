
Syntax * mm(Syntax * in, Environ * env) {
  Mark * mark = new_mark();
  Match * m = match_args(0, syntax (pattern, with), in);
  Syntax * pattern = m->var(syntax pattern);
  pattern = partly_expand(pattern, ExpPos, env);
  pattern = pattern->part(1);
  //dump_syntax(pattern);
  SyntaxList * aqs = gather_antiquotes(pattern);
  //dump_syntax(aqs);
  pattern = mark_antiquotes(pattern, aqs);
  //dump_syntax(pattern);
  SyntaxEnum * iter = aqs->elements();
  SyntaxList * assign = new_syntax_list();
  Syntax * aq;
  while ((aq = iter->next())) {
    assign->append(replace(syntax {$1 = match_aq_var(m, syntax_d $2);},
                           match_local(m, aq, aq),
                           mark));
  }
  UnmarkedSyntax * res = syntax {
    Match * m = match_args(NULL, syntax_d $1, with);
    $2;
  };
  return replace(res, match_local(m, pattern, assign, NULL), mark);  
}

make_macro mm;

Syntax * qq(Syntax * in, Environ * env) {
  Mark * mark = new_mark();
  Match * m = match_args(0, syntax (pattern, mark), in);
  SyntaxList * aqs = gather_antiquotes(m->var(syntax pattern));
  UnmarkedSyntax * res = syntax {
    replace(syntax pattern, match_antiquotes(NULL, syntax_d $1, $2, NULL), mark);
  };
  return replace(res, match_local(m, aqs, aqs, NULL), mark);
}

make_macro qq;

Syntax * test(Syntax * in, Environ * env) {
  Mark * mark = new_mark;
  //Match * m = match_args(NULL, syntax(A,B), in);
  //Syntax * a = m->var(syntax A);
  //Syntax * b = m->var(syntax B);
  Syntax *a, *b;
  mm(syntax ($a,$b), in);
  return qq((1 + $a + $b), mark);
}

make_macro test;


int main() {
  printf("%d\n", test(2,4));
}

