--- ../class.zl	2009-09-06 02:16:13.000000000 -0600
+++ class-new_abi.zl	2009-09-06 02:28:17.000000000 -0600
@@ -125,7 +125,7 @@
   }
 }
 
-Syntax * parse_class(Syntax * p, Environ * env) {
+Syntax * parse_class_new_abi(Syntax * p, Environ * env) {
   Mark * mark = new_mark();
 
   Match * m = match_args(0, raw_syntax (name @ body :(public parent_n) :(vtable_class (reparse vtable_class class))), p, mark);
@@ -147,8 +147,8 @@
   pre_parse(replace(raw_syntax (declare_user_type (mid name)), m, mark),
             lenv);
 
-  //printf("parse_class %s %s\n", syntax_to_string(name));
-  
+  //printf("parse_class_new_abi %s\n", syntax_to_string(name));
+
   ModuleInfo * parent_m = NULL;
   UserTypeInfo * parent_vtable = NULL;
   Syntax * parent_vtable_n = NULL;
@@ -163,6 +163,8 @@
 
   m = match(m, syntax _Data, replace_context(syntax _Data, context));
   m = match(m, syntax _parent, replace_context(syntax _parent, context));
+  m = match(m, syntax _parent_ptr, replace_context(syntax _parent_ptr, context));
+  m = match(m, syntax _child_ptr, replace_context(syntax _child_ptr, context));
   m = match(m, syntax _VTable, replace_context(syntax _VTable, context));
   m = match(m, syntax _vtable, replace_context(syntax _vtable, context));
   m = match(m, syntax _vptr, replace_context(syntax _vptr, context));
@@ -184,15 +186,33 @@
     // this needs to be one of the first things we do
     module_p->append(replace(syntax {import parent_n;}, m, mark));
 
-    parse_class_var(partly_expand(replace(syntax {parent_n _parent;}, m, mark), FieldPos, lenv),
+    parse_class_var(partly_expand(replace(syntax {parent_n * _parent_ptr;}, m, mark), FieldPos, lenv),
                     m, mark, struct_p, module_p);
+
+    Syntax * p_init = replace(syntax {_parent_ptr = malloc(sizeof(parent_n));}, m, mark);
+    sp.need_constructor = true;
+    sp.need_copy_constructor = true;
+    sp.constructor_code[0]->append(p_init);
+    sp.copy_constructor_code[0]->append(p_init);
+    Syntax * p_cleanup = replace(syntax {free(_parent_ptr);}, m, mark);
+    sp.need_destructor = true;
+    sp.destructor_code->append(p_cleanup);
+
+    module_b->append(replace(syntax {macro _parent (:this ths = this) {*ths->_parent_ptr;}}, m, mark));
+
     create_special_funs(sp, 
                         m->var(syntax _parent), 
                         replace(raw_syntax (parent_n), m, mark), 
                         0, m, mark, lenv);
+
+    // The setting of the child pointer needs to come after the
+    // parent's constructor is called
+    Syntax * p_init_2 = replace(syntax {_parent_ptr->_child_ptr = this;}, m, mark);
+    sp.constructor_code[0]->append(p_init_2);
+    sp.copy_constructor_code[0]->append(p_init_2);
     
-    module_p->append(replace(syntax {macro cast_up(p) {&(*p).._parent;}}, m, mark));
-    module_p->append(replace(syntax {macro cast_down(p) {reinterpret_cast<name *>(p);}}, m, mark));
+    module_p->append(replace(syntax {macro cast_up(p) {(*p).._parent_ptr;}}, m, mark));
+    module_p->append(replace(syntax {macro cast_down(p) {reinterpret_cast<name *>((*p).._child_ptr);}}, m, mark));
     module_p->append(replace(syntax {make_subtype parent_n cast_up cast_down;}, m, mark));
 
     SyntaxEnum * itr = parent_m->symbols();
@@ -202,6 +222,14 @@
     }
   }
 
+  parse_class_var(partly_expand(replace(syntax {void * _child_ptr;}, m, mark), FieldPos, lenv),
+                  m, mark, struct_p, module_p);
+  Syntax * c_init = replace(syntax{_child_ptr = 0;}, m, mark);
+  sp.need_constructor = true;
+  sp.constructor_code[0]->append(replace(syntax{_child_ptr = 0;}, m, mark));
+  sp.need_copy_constructor = true;
+  sp.copy_constructor_code[0]->append(replace(syntax{_child_ptr = 0;}, m, mark));
+  
   //
   // Parse Body
   //
@@ -603,4 +631,35 @@
                              match_local(m, new_parms, 0), mark));
 }
 
+make_syntax_macro class parse_class_new_abi :w_snapshot;
+
+//
+//
+//
+
+size_t zl_abi_version = 1;
+
+Syntax * parse_class_w_abi(Syntax * p, Environ * env) {
+  Mark * mark = new_mark();
+  Match * m = match_args(0, raw_syntax (name @ (pattern ({...} @body)) :(abi_ver abi_ver) @rest), p);
+
+  Syntax * body = match_var(m, syntax body);
+  Syntax * abi_ver_s = match_var(m, syntax abi_ver);
+
+  size_t abi_ver = abi_ver_s ? ct_value(abi_ver_s, env) : zl_abi_version;
+
+  printf("parse_class_w_abi %d\n", abi_ver);
+
+  switch (abi_ver) {
+  case 1:
+    return parse_class(p, env);
+  case 2:
+    return parse_class_new_abi(p, env);
+  default:
+    return error(p, "Unknown ABI version %d\n", abi_ver);
+  }
+}
+
+make_syntax_macro class parse_class_w_abi :w_snapshot;
+
 
