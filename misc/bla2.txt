t: top level
s: statment
e: expression  
l: literal (no expansion)
t: type


{"var", "it:e"},
{"talias", "iT"},
{"fun", "itt?"
{"struct", "i?"},
{"union", "i?"},


{"if", "es:s"}, 
{"loop", "s"}, 
{"goto", "I"}, 
{"break", ""}, 
{"block", "s."},
{"print" "e"},
{"return", ""},

{"eif","eee"},

{".pointer, "t"},
{".array, "t", "e"},
{".fun", "tt"},
{"struct", "i"},
{"union, "i"},

)   res = (new EStmt)->parse_self(p, env);
    else if (p->name == "goto")    res = (new Goto)->parse_self(p, env);
    else if (p->name == "lstmt")   res = (new LStmt)->parse_self(p, env);
    else if (p->name == "id")      res = (new Id)->parse_self(p, env);
    else if (p->name == "type")    res = (new Type0)->parse_self(p, env);
    else if (p->name == "literal") res = (new Literal)->parse_self(p, env);
    else if (p->name == "if")      res = (new If)->parse_self(p, env);
    else if (p->name == "eif")     res = (new EIf)->parse_self(p, env);
    else if (p->name == "loop")    res = (new Loop)->parse_self(p, env);
    else if (p->name == "break")   res = (new Break)->parse_self(p, env);
    else if (p->name == "var")     res = (new Var)->parse_self(p, env);
    else if (p->name == "block")   res = (new Block)->parse_self(p, env);
    else if (p->name == "assign")  res = (new Assign)->parse_self(p, env);
    else if (p->name == "print")   res = (new Print)->parse_self(p, env);
    else if (p->name == "noop")    res = (new NoOp)->parse_self(p, env);
    else if (p->name == "plus")    res = (new Plus)->parse_self(p, env);
    else if (p->name == "minus")   res = (new Minus)->parse_self(p, env);
    else if (p->name == "times")   res = (new Times)->parse_self(p, env);
    else if (p->name == "div")     res = (new Div)->parse_self(p, env);
    else if (p->name == "mod")     res = (new Mod)->parse_self(p, env);
    else if (p->name == "neg")     res = (new Neg)->parse_self(p, env);
    else if (p->name == "eq")      res = (new Eq)->parse_self(p, env);
    else if (p->name == "ne")      res = (new Ne)->parse_self(p, env);
    else if (p->name == "lt")      res = (new Lt)->parse_self(p, env);
    else if (p->name == "qt")      res = (new Gt)->parse_self(p, env);
    else if (p->name == "le")      res = (new Le)->parse_self(p, env);
    else if (p->name == "ge")      res = (new Ge)->parse_self(p, env);
    else if (p->name == "not")     res = (new Not)->parse_self(p, env);
    else if (p->name == "addrof")  res = (new AddrOf)->parse_self(p, env);
    else if (p->name == "deref")   res = (new DeRef)->parse_self(p, env);
    else if (p->name == "member")  res = (new MemberAccess)->parse_self(p, env);
    else if (p->name == "fun" )    res = (new Fun)->parse_self(p, env);
    else if (p->name == "return")  res = (new Return)->parse_self(p, env);
    else if (p->name == "call")    res = (new Call)->parse_self(p, env);
    else if (p->name == "struct")  res = (new Struct)->parse_self(p, env);
    else if (p->name == "union")   res = (new Union)->parse_self(p, env);
    else if (p->name == "talias")  res = (new TypeAlias)->parse_self(p, env);
    else if (p->name == "map")     res = (new Map)->parse_self(p, env);
    else if (p->name == "stmt")    res = parse_stmp(p, env);
    else if (p->name == "exp")     res = parse_exp(p, env);
    else if (p->name == "slist")   res = (new SList)->parse_self(p, env);
