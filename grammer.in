
TOP = <top> SPACING {STMT}+;

#
# C Statement
#

STMT : "statement" = 
      <<mid>> {MID} ";"
    / <lcstmt> {CASE_LABEL} ":" {STMT}
    / <lstmt> {TAGGED_LABEL} ":" {STMT}
    / <if>    "if" "(" {EXP} ")" {STMT} ("else" {STMT})?
    / <switch> "switch" "(" {EXP} ")" {STMT}
    / <while> "while" "(" {EXP} ")" {STMT}
#    / <loop>  "loop" {STMT}
    / <do>    "do" {STMT} "while" "(" {EXP} ")" ";"
    / <for>   "for" "(" {<stmt> {TOKEN}+ / <noop>} ";" {EXP/<literal 1>} ";" {<estmt> {EXP}/<noop>} ")" {STMT}
    / <break>    "break" ";"
    / <continue> "continue" ";"
    / <return>   "return" {EXP} ";"
    / <goto>     "goto" {EXP} ";"
    / {BLOCK}
    / {MAP}
    / <noop>   ";"
    / <stmt>   {TOKEN}* ({BRACE} / ";")
   ;

CASE_LABEL =
      <case> "case" {CASE_EXP}
    / <default> "default";

CASE_EXP = <exp> (!":" {TOKEN})+;

TAGGED_LABEL : "label" = 
      <label> {ID} SPACING
    / <local> [.] {ID} SPACING;

MAP =
  <map> "map" {ID} "(" {<> ({ID} ",")* {ID}?} ")" {BRACE} ;

#
# C Token
#

TOKEN = <<mid>> {MID} / 
         {STRUCT_UNION} / {ENUM} / {TYPEOF} 
         / {PARAN} / {BRACK} / <string> {STRING} 
         / <id> {ID} / <literal> {NUM} / <sym> {SYM};

STRUCT_UNION = <%> {"struct"/"union"} {ID/} {<{...}> "{" {STMT}* "}" }?;

ENUM = <enum> "enum" {ID/} 
              {<{,}> "{" ({ENUM_MEMBER} ",")* ({ENUM_MEMBER} ","?)? "}" }?;
ENUM_MEMBER = <> {ID} ("=" {ENUM_EXP})?;
ENUM_EXP = <exp> (!"," {TOKEN})+;

TYPEOF = <.typeof> "typeof" "(" {EXP} ")";

#
# Misc
#

EXP = <<mid>> {MID} / <exp> {TOKEN}+;

BLOCK = <block> "{" {STMT}* "}";

EBLOCK = <eblock> "(" "{" {STMT}* "}" ")";

#
# Raw Tokens
#

BRACE = <{}> "{" {RAW_TOKEN*} "}";
PARAN = <()> "(" {RAW_TOKEN*} ")";
BRACK = <[]> "[" {RAW_TOKEN*} "]";

RAW_TOKEN = <string> {STRING} / {BRACE} / {PARAN} / {BRACK} / {ID} / {NUM} / {SYM} / ";";

#
# Lex Like Tokens
#

ID : "identifier" =
     <<mid>> {MID} / {[`]*[\a_]+[\a_\d]*} SPACING;

MID : "macro identifier" = 
     {[\a_]+[\a_\d]*} SPACING;

NUM : "number" = 
    {[\d]+('.'[\d]+)?} SPACING;

STRING = 
     '"' ('\\'_/[^"]+) '"' SPACING
   / '\'' ('\\'_/[^']+) '\'' SPACING;

SYM : "symbol" = 
    {[\y+^,;`]+/','} SPACING;

SPACING : "spacing" =
   [\s]* COMMENT?
   ;

COMMENT = 
    '//' [^\n]* [\n] SPACING
  / '#' [^\n]* [\n] SPACING
  / '/*' _* . '*/' SPACING;

#
# Special tokens
#

"[\a_][\a\d_]*" = {_self} ![\a\d_] SPACING;
"[;,]" = {_self} SPACING;
"[\y]+" : "operator" = {_self} ![\y] SPACING;
"_" = {_self} SPACING;

#
# Productions used by macro expander
#

PARAN_EXP = {EBLOCK} / "(" {EXP} ")";

ARRAY_SIZE = {EXP} EOF / <literal 0>;

TOKENS = <(...)> {TOKEN}*;

STMTS = <slist> {STMT}*;

SPLIT_TOKEN = !"," RAW_TOKEN;
SPLIT = <(,)> ({<parm> {SPLIT_TOKEN*}} ("," {<parm> {SPLIT_TOKEN*}})+/{<parm> {SPLIT_TOKEN+}}/);

PARM : "macro paramater" = {STMT} EOF / {TOKEN} EOF / {EXP} EOF;

EOF = SPACING !_ ;

