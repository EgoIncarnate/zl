%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[12pt,english,letterpaper]{article}
\usepackage{pslatex}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
%\usepackage{geometry}
%\geometry{letterpaper,dvips,
%          top=1in,
%          bottom=1in,
%          left=1.5in,
%          right=1.5in}
\usepackage{setspace}
\usepackage{verbatim}
\usepackage{mdwlist}

% Note: when changing spacing also change to code macro below
%\singlespacing
\onehalfspacing
%\doublespacing
\setlength\parskip{\bigskipamount}
\setlength\parindent{0pt}

\IfFileExists{url.sty}{\usepackage{url}}
                      {\newcommand{\url}{\texttt}}
\usepackage{hyperref}

\special{papersize=8.5in,11in}
\pdfpageheight\paperheight
\pdfpagewidth\paperwidth

\makeatletter
\usepackage{babel}
\makeatother

\newenvironment{code}
  {\singlespacing\verbatim}
  {\endverbatim\onehalfspacing}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\title{The ZL Parset and Macro Expander}
\author{Kevin Atkinson}

\section{Overview}

Parsing a source file in ZL is a three step process.  In the first
step a string of characters in converted to a syntax object, in other
words a string is parsed into a syntax object.  The grammer is
specified as a PEG and a Pacrat parser is used to convert the string of
charaters to a syntax object.  The second step is the expander, in
this step Syntax objects are manipulated into other Syntax objects.
It is here where Macro's are expanded.  Finally, in the third step
syntax objects are converted in an AST.  However, these three steps
are deeply intertwined.

The process starts by performing an initial parse of the source code
into a Syntax object using the Packrat parser.  This initial parse
serves to seperate the source code in seperate declarations.  It does
not fully parse the code, in paraticular anything between grouping
characters "()", "\{\}", and "[]" is only minimally parsed to match
grouping characters and returned as an unparsed string.

The syntax object returned after this is esentually a list of
declarations.  Each declaration is converted into an AST object and
added to the envirment.  In order to do this it is necessary to partly
expand the syntax object to expand any macros and perform any other
necessary transformations.  The partial expansion will expand just
enough to expose the top level form so we know what type of AST object
it needs to be conveted to.

Once the top level form is exposed, it is converted into an AST
object.  During the conversion each of its parts is also converted to
an AST.  This convertion, thus involves partly expanding the source
code.  Thus as a syntax Object is convected into an AST it is expanded
as necessary, which means at no point during the expansion process is
a completely expanded Syntax object availabe.

%\section{Syntax Objects}
%
%Syntax object in ZL are analogise to S-expression in scheme and are
%thus represented in a similar manner.

\section{The Partial Expander}

During the partial expansion process a number a things happen.  First
off any unparsed strings and parsed as necessary.  Like the partial
expanader this parsing does not fully parse the string, rather it
parses just enough to be able to recognise the top level form, in
particular this means that like the initial parse anything between
grouping characters "()", "\{\}", and "[]" is only minimally parsed to
match grouping characters and returned as a unparsed string.  It will
also expand any macros as necessary.  This includes two special macros
which are built into the expander.

These two special macros are the declarion expander and the expression
expander.  These are necessary becuase the current PEG grammer does
not necessary return a valid top-level form.  It will only reconize
block structures such as "if" and "while" forms.  It will not
recognize functions, varable declarstions and expressions.  The reason
for this is primary pragmatic.  Correctly parsing C and C++
declarations involves maintaining state which in inherently
incompatible with Packrat parsing while grammers for expressions
generaly involves left-recursion, again incompatable with Packrat
parsing.  With work both of these problems can be addressed in the
Packrat parser.  It is possible to have limited state....  It is also
fairly straightforward to convert a grammer with left-recursion to one
that is not....  In addition it is even possible to modify the Pacrat
parser to support left recursion...  Nevertheless, I chose to avoid
these two issues completely by using a PEG grammer which essentially
parses a statment into a list of tokens if it not a not a recognized
block structure.  I use the term "tokens" loosely here, since anything
inside of a "()", "\{\}", or "[]" is treated as one token.

Thus when the expander encounters a "statement" the expander will
first try expanding the stmt using the declaration expander and if
that fails try expression expander which is an Operator-precedence
parser.  In principle both these expanders could be true macros.

%\section{Details}




\end{document}


%% EXPANDING MACROS

%% A pattern matching macro consists of two parts.  The first part is to
%% match the paramaters of the macro with pattern variables and (known as
%% the match step), the second part is to replace and pattern variables
%% in the macro body with the paramaters matched in the previous step
%% (known as the replace step).

%% ...

%% Pattern variablies inside the replace string are known as macro
%% identifiers and are repsented as (mid <ID>)



%% During the replace step when an unparsed string is encountered it is
%% reparsed as ....  During the reparsing step macro identifers are
%% reconized by special productions in the grammer <<mid>> which matches
%% an identifier when this rule in encountered the matching identider is
%% checked againat a list of macro identifers in the current scope and if
%% it matches than is parsed as a (mid <ID>) otherwise the production is
%% ignored...


%% MISC


%% ----

%% parse_str(String how, String what) : Syntax
%%   Parses the string "what" with production "how" and returnes a syntax
%%   object representing the parsed string.  Does not expand.

%% parse_top(Syntax, Environ) : void
%%   Parses the top level.  Does not return a value, instead populates
%%   environment with the top level declarations.

%% main = parse_top(parse_str("TOP", <source file>))

%% ---



