
//
// libc stuff
//

typedef unsigned size_t;
typedef struct _IO_FILE FILE;
extern "C" int printf (const char *, ...);
extern "C" int snprintf(char * str, size_t size, const char * format, ...);
macro NULL() {0;}
typedef int bool;
extern "C" void * malloc(size_t);
extern "C" void free(void *);
extern "C" int strcmp(const char *s1, const char *s2);
macro offsetof(TYPE, MEMBER) {(size_t) &(reinterpret_cast<TYPE *>(0))->MEMBER;}
extern "C" void *memcpy(void *dest, const void *src, size_t n);
extern "C" void *memmove(void *dest, const void *src, size_t n);

//
// language support
//

macro true() {1;}
macro false() {0;}

__raw(smacro new (type @rest)
        (eblock 
          (var tmp (.ptr type) (call malloc (. (sizeof (.type type)))))
          (construct (deref tmp) type  @rest)
          tmp));

__raw(smacro delete (exp)
        (eblock (var tmp (.ptr void))
          (assign tmp (destroy (deref exp)))
          (call free (. tmp))));

__raw(.struct .dummy);

//
// Macro ABI
//

typedef struct EnvironSnapshot EnvironSnapshot;

typedef struct Mark Mark;
__ct_callback Mark * new_mark_f(EnvironSnapshot *);
macro new_mark(es = NULL) {new_mark_f(es ? (EnvironSnapshot *)es : (EnvironSnapshot *)environ_snapshot());}
macro new_empty_mark() {new_mark_f(0);}

struct UnmarkedSyntax;
user_type UnmarkedSyntax {
  finalize_user_type struct UnmarkedSyntax;
}

user_type Syntax;
user_type SyntaxEnum;
__ct_callback bool syntax_simple(Syntax *);
__ct_callback Syntax * syntax_part(Syntax *, unsigned);
__ct_callback unsigned syntax_num_args(Syntax *);
__ct_callback Syntax * syntax_flag(Syntax *, UnmarkedSyntax *);
__ct_callback bool syntax_eq(Syntax *, UnmarkedSyntax *);
__ct_callback SyntaxEnum * syntax_args(Syntax *);
struct Syntax;
user_type Syntax {
  finalize_user_type struct Syntax;
  macro _up_cast (x) {reinterpret_cast<UnmarkedSyntax *>(x);}
  macro _down_cast (x) {reinterpret_cast<Syntax *>(x);}
  make_subtype UnmarkedSyntax _up_cast _down_cast;
  //import UnmarkedSyntax;
  //export simple, flag, part;
  macro simple(:this this) {syntax_simple(this);}
  macro num_parts(:this this) {syntax_num_args(this) + 1;}
  macro num_args(:this this) {syntax_num_args(this);}
  macro part(num, :this this) {syntax_part(this, num);}
  macro arg(num, :this this) {syntax_part(this, num + 1);}
  macro args(:this this) {syntax_args(this);}
  macro flag(str, :this this) {syntax_flag(this, str);}
  macro eq(str, :this this) {syntax_eq(this, str);}
  macro ne(str, :this this) {!syntax_eq(this, str);}
}

user_type SyntaxList;
__ct_callback SyntaxList * new_syntax_list();
__ct_callback int syntax_list_empty(const SyntaxList *);
__ct_callback size_t syntax_list_append(SyntaxList *, Syntax *);
__ct_callback void syntax_list_append_flag(SyntaxList *, Syntax *);
__ct_callback void syntax_list_append_all(SyntaxList *, SyntaxEnum *);
__ct_callback void syntax_list_reverse(SyntaxList *);
__ct_callback void syntax_list_replace(SyntaxList *, size_t pos, Syntax * el);
struct SyntaxList;
user_type SyntaxList {
  finalize_user_type struct SyntaxList;
  import Syntax;
  macro _up_cast (x) {reinterpret_cast<Syntax *>(x);}
  macro _down_cast (x) {reinterpret_cast<SyntaxList *>(x);}
  make_subtype Syntax _up_cast _down_cast;
  //export empty, append;
  macro empty(:this this) {syntax_list_empty(this);}
  macro append(:this this, syn) {syntax_list_append(this, syn);}
  macro append_flag(:this this, syn) {syntax_list_append_flag(this, syn);}
  macro append_all(:this this, els) {syntax_list_append_all(this, els);}
  macro elements(:this this) {syntax_args(this);}
  macro reverse(:this this) {syntax_list_reverse(this);}
  macro replace(:this this, pos, el) {syntax_list_replace(this, pos, el);}
}

user_type SyntaxEnum;
__ct_callback Syntax * syntax_enum_next(SyntaxEnum *);
__ct_callback SyntaxEnum * syntax_enum_clone(const SyntaxEnum *);
struct SyntaxEnum;
user_type SyntaxEnum {
  finalize_user_type struct SyntaxEnum;
  export next;
  macro next(:this this) {syntax_enum_next(this);}
  macro clone(:this this) {syntax_enum_clone(this);}
}

user_type Match;
__ct_callback Match * match_f(Match * m, UnmarkedSyntax * pattern, Syntax * with, Mark * mark);
macro match(m, pattern, with, mark = NULL) {match_f(m, pattern, with, mark);}
__ct_callback Match *match_args_f(Match *, UnmarkedSyntax * pattern, Syntax * with, Mark * mark);
macro match_args(m, pattern, with, mark = NULL) {match_args_f(m, pattern, with, mark);}
__ct_callback Match * match_local(Match *, ...);
__ct_callback Syntax * match_var(Match *, UnmarkedSyntax *);
__ct_callback SyntaxEnum * match_varl(Match *, UnmarkedSyntax *);
struct Match;
user_type Match {
  finalize_user_type struct Match;
  export var, varl;
  macro var(str, :this this) {match_var(this, str);}
  macro varl(str, :this this) {match_varl(this, str);}
}

__ct_callback Syntax * replace(UnmarkedSyntax *, Match *, Mark *);

typedef struct Context Context;
__ct_callback Context * empty_context();
__ct_callback Context * get_context(Syntax *);
__ct_callback Syntax * replace_context(UnmarkedSyntax *, Context *);

typedef struct Environ Environ;

typedef enum  {NoPos = 0, OtherPos = 1, TopLevel = 2, FieldPos = 4, 
               StmtDeclPos = 8, StmtPos = 16, ExpPos = 32} Position;
__ct_callback Syntax * partly_expand(Syntax *, Position pos, Environ *);
__ct_callback SyntaxEnum * partly_expand_list(SyntaxEnum *, Position pos, Environ *);
__ct_callback Syntax * pre_parse(Syntax *, Environ *);
__ct_callback Syntax * reparse(Syntax *, const char *, Environ *);

__ct_callback UnmarkedSyntax * string_to_syntax(const char * str);
__ct_callback const char * syntax_to_string(UnmarkedSyntax *);
__ct_callback void dump_syntax(UnmarkedSyntax *);

user_type Symbol;
user_type UserType;
user_type Module;

__ct_callback UserType * user_type_info(Syntax *, const Environ *);
__ct_callback Module * user_type_module(const UserType *);
__ct_callback Module * module_info(Syntax *, const Environ *);
__ct_callback SyntaxEnum * module_symbols(const Module *);
__ct_callback bool module_have_symbol(const Module *, const Syntax *);
__ct_callback bool user_type_have_default_constructor(const UserType *);
__ct_callback bool user_type_have_copy_constructor(const UserType *);
__ct_callback bool user_type_have_assign(const UserType *);
__ct_callback bool user_type_have_destructor(const UserType *);

//struct Symbol;
//user_type Symbol {
//  finalize_user_type struct UserType;
//  macro name;
//  macro uniq_name;
//}

struct UserType;
user_type UserType {
  finalize_user_type struct UserType;
  export module;
  macro module(:this this) {user_type_module(this);}
  macro have_default_constructor(:this this) {user_type_have_default_constructor(this);}
  macro have_copy_constructor(:this this) {user_type_have_copy_constructor(this);}
  macro have_assign(:this this) {user_type_have_assign(this);}
  macro have_destructor(:this this) {user_type_have_destructor(this);}
}

struct Module;
user_type Module {
  finalize_user_type struct Module; 
  export symbols, have_symbol;
  macro symbols(:this this) {module_symbols(this);}
  macro have_symbol(sym, :this this) {module_have_symbol(this, sym);}
}

user_type ModuleBuilder;
user_type UserTypeBuilder;
__ct_callback ModuleBuilder * new_module_builder(Syntax * name, Environ * env);
__ct_callback void module_builder_add(ModuleBuilder *, Syntax *);
__ct_callback Syntax * module_builder_to_syntax(ModuleBuilder *);
__ct_callback UserTypeBuilder * new_user_type_builder(Syntax * name, Environ * env);

struct ModuleBuilder {
  Module * module;
  UserType * user_type;
  Environ * env;
};
user_type ModuleBuilder {
  finalize_user_type struct ModuleBuilder;
  macro module(:this this) {(*this)..module;}
  macro user_type(:this this) {(*this)..user_type;}
  macro env(:this this) {(*this)..env;}
  macro add(syn, :this this) {module_builder_add(this, syn);}
  macro to_syntax(:this this) {module_builder_to_syntax(this);}
}

user_type UserTypeBuilder {
  finalize_user_type struct ModuleBuilder;
  import ModuleBuilder;
  macro _up_cast (x) {reinterpret_cast<ModuleBuilder *>(x);}
  macro _down_cast (x) {reinterpret_cast<UserTypeBuilder *>(x);}
  make_subtype ModuleBuilder _up_cast _down_cast;
  macro have_default_constructor(:this this) {this->user_type->have_default_constructor();}
  macro have_copy_constructor(:this this) {this->user_type->have_copy_constructor();}
  macro have_assign(:this this) {this->user_type->have_assign();}
  macro have_destructor(:this this) {this->user_type->have_destructor();}
}

__ct_callback Environ * temp_environ(const Environ *);
__ct_callback Environ * new_scope(const Environ *, Syntax * where);

__ct_callback size_t ct_value(Syntax *, const Environ *);

__ct_callback Syntax * error(Syntax *, const char *, ...);

__ct_callback Syntax * get_symbol_prop(UnmarkedSyntax * sym, UnmarkedSyntax * prop, const Environ * env);

__ct_callback int symbol_exists(UnmarkedSyntax * sym, Syntax * where, Mark *, const Environ *);

//

__ct_callback const char * mangle_fun_parms(Syntax *, const Environ *);

//
//
//

Syntax * parse_make_syntax_macro(Syntax * p, Environ * env);
make_macro make_syntax_macro`syntax parse_make_syntax_macro :w_snapshot;

//
//
//

Syntax * partly_expand_class(Syntax *, Mark *, Environ *);

__raw(smacro pseudo_member (VAR TYPE VAL) 
      (alias VAR TYPE VAL :need_constructor));

Syntax * parse_class(Syntax * p, Environ * env);
//make_syntax_macro class parse_class;
make_macro class`syntax parse_class :w_snapshot;

EnvironSnapshot * prelude_envss = environ_snapshot();

__ct_callback void gdb_breakpoint();
