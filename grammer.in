
TOP = <top> SPACING {STMT}+;

SLIST = <@> SPACING {STMT}+;

#
# C Statement
#

STMT : "statement" = 
      <<mid>> {MID} ";"
    / <lcstmt> {CASE_LABEL} ":" {STMT}
    / <lstmt> {ID} ":" {STMT}
    / <if>    "if" "(" {EXP} ")" {STMT} ("else" {STMT})?
    / <switch> "switch" "(" {EXP} ")" {STMT}
    / <while> "while" "(" {EXP} ")" {STMT}
#    / <loop>  "loop" {STMT}
    / <do>    "do" {STMT} "while" "(" {EXP} ")" ";"
    / <for>   "for" "(" {<stmt> {TOKEN}+ / <noop>} ";" {EXP/<literal 1>} ";" {<estmt> {EXP}/<noop>} ")" {STMT}
    / <break>    "break" ";"
    / <continue> "continue" ";"
    / <return>   "return" {EXP} ";"
    / <local_label> "__label__" {ID} ";"
    / <goto>     "goto" (<id> {ID}) ";"
    / {BLOCK}
    / {MACRO} / {MAKE_MACRO}
    / {MODULE} / {IMPORT}
    / <fluid_binding> "fluid_binding" {ID} ";"
    / <fluid_label>   "fluid_label"   {ID} ";"
    / <fluid_syntax>  "fluid_syntax"  {ID} ";"
    / <make_inner_ns> "make_inner_ns" {ID} ";"
    / <make_user_type> "make_user_type" {ID} {TOKEN}? ";" # FIXME: TOKEN not right...
    / <declare_user_type> "declare_user_type" {ID} ";"
    / <make_subtype> "make_subtype" {ID} {ID} {ID}? ";"
    / <finalize_user_type> "finalize_user_type" {TOKEN} ";"
    / <export> "export" {ID} ("," {ID})* ";"
    / <noop>   ";"
    / <stmt>   ({TOKEN_}+ {PARAN} {BRACE} / {TOKEN}+ ";")
   ;

CASE_LABEL =
      <case> "case" {CASE_EXP}
    / <default> "default";

CASE_EXP = <exp> (!":" {TOKEN})+;

MACRO =
  <macro> "macro" {ID} "(" {MATCH_LIST} ")" (:<free> ":" "(" {ID_LIST} ")" /) {BRACE}
  / <smacro> "smacro" {ID} "(" {MATCH_LIST} ")" (:<free> ":" "(" {ID_LIST} ")" /) {BRACE} ;

MAKE_MACRO  =
    <make_macro> "make_macro" {ID} {ID}? ";"
  / <make_syntax_macro> "make_syntax_macro" {ID} {ID}? ";";

MODULE = 
    <%> {"module"/"user_type"} {ID} ({<{...}> "{" {STMT}* "}" } / ";");

IMPORT = 
    <import> "import" {ID} ";";

ID_LIST =
  <> ({ID} ",")* {ID}?;

MATCH_LIST =
  <> ({MATCH} ",")* {MATCH}?;

MATCH = <<mid>> {MID} / :<> ':'{ID} {<reparse> {ID} ("=" {SPLIT_PARM})?} / <reparse> {ID} ("=" {SPLIT_PARM})? ;

#
# C Token
#

TOKEN_ : "token_" =  <<mid>> {MID} !("`" / "::") /  
         {STRUCT_UNION} / {ENUM} / {TYPEOF} / {SYNTAX}
         / {BRACK} / {CONST}
         / <id> {ID} / <sym> {SYM};

TOKEN : "token" =  <<mid>> {MID} !("`" / "::") / 
         {STRUCT_UNION} / {ENUM} / {TYPEOF} / {SYNTAX}
         / {BRACK} / {CONST}
         / <id> {ID} / <sym> {SYM} 
         / {PARAN} / {BRACE};

#TOKEN : "token" = TOKEN_ / PARAN;

# FIXME: Add support for hex-floats
CONST = <float> {([0-9]*'.'[0-9]+/[0-9]+'.')([eE][+-]?[0-9]+)?} {FLOATING_SUFFIX} SPACING
        / <literal> {'0'[xX][0-9a-fA-F]+} {INT_SUFFIX} SPACING
        / <literal> {[1-9][0-9]*} {INT_SUFFIX} SPACING
        / <literal> {'0'[0-7]*} {INT_SUFFIX} SPACING
        / <string> {STRING} (<char>)
        / <string> 'L'{STRING} (<wchar_t>)
        / <char> {CHAR} (<char>)
        / <char> 'L'{CHAR} (<wchar_t>);

INT_SUFFIX = <"unsigned long long"> ([uU][lL][lL]/[lL][lL][uU])
           / <"unsigned long"> ([uU][lL]/[lL][uU])
           / <"long long"> [lL][lL] 
           / <unsigned> [uU] 
           / <long> [lL] 
           / <int>;

FLOATING_SUFFIX = <float> [fF] / <"long double"> [lL] / <double>;

STRUCT_UNION = <%> {"struct"/"union"/"class"/"class_"} 
                   {ID/}
                   (:<public> ":" "public" {ID})?
                   {<{...}> "{" {STMT}* "}" }?;

ENUM = <enum> "enum" {ID/} 
              {<{,}> "{" ({ENUM_MEMBER} ",")* ({ENUM_MEMBER} ","?)? "}" }?;
ENUM_MEMBER = <> {ID} ("=" {ENUM_EXP})?;
ENUM_EXP = <exp> (!"," {TOKEN})+;

TYPEOF = <.typeof> "typeof" "(" {EXP} ")";

SYNTAX = 
    <syntax> "syntax" {SYNTAX_P}?
  / <raw_syntax> "raw_syntax" {PARAN};

SYNTAX_P =
  <<mid>> {MID} / {ID} / {BRACE} / {PARAN}; # / {BRACK};
#  <<mid>> {MID} / {ID} / {BRACE} / <parm> "(" {RAW_TOKEN*} ")"; # / {BRACK};

#
# Misc
#

EXP = <exp> {TOKEN}+;

INIT = <<mid>> {MID} / <init> {TOKEN}+;

BLOCK = <block> "{" {STMT}* "}";

EBLOCK = <eblock> "(" "{" {STMT}* "}" ")";

#
# Raw Tokens
#

BRACE = <{}> "{" {RAW_TOKEN*} "}";
PARAN = <()> "(" {RAW_TOKEN*} ")";
BRACK = <[]> "[" {RAW_TOKEN*} "]";

RAW_TOKEN = STRING / CHAR / BRACE / PARAN / BRACK / COMMENT / [^\)\]\}];

#
# Lex Like Tokens
#

RAW_ID : "identifier" =
  <<mid>> {MID} / {[@$\a_][\a_\d]*} SPACING;

ID_W_INNER : "identifier" =
  <w/inner> {RAW_ID} "`" {RAW_ID} / {RAW_ID};

ID_W_NS =
  <w/outer> ({ID_W_INNER} "::") {ID_W_NS} / {ID_W_INNER};

ID =
  <fluid> "fluid" {ID} / {ID_W_NS};

MID : "macro identifier" = 
     {[@$\a_][\a_\d]*} SPACING;

NUM : "number" = 
    {[\d]+('.'[\d]+)?} SPACING;

STRING = '"' ('\\'_/[^"])+ '"' SPACING;

CHAR   = '\'' ('\\'_/[^'])+ '\'' SPACING;

#SYM : "symbol" = 
#    {[\y+^,;`]+/','} SPACING;

SYM : "symbol" =
   {'...' / '>>=' / '<<=' / '..' / '>>' / '<<' / '&&' / '||' / 
   '<=' / '>=' / '==' / '!=' / '++' / '--' / '->' /
   '+=' / '-=' / '*=' / '/=' / '%=' / '/=' / '&=' / '^=' / '|=' /
   '+'  / '-'  / '*'  / '/'  / '%'  / '/'  / '&'  / '^'  / '|' /
   '=' / '<' / '>' / '?' / ':' / ',' / '.' / '!' / '~'} SPACING;

SPACING : "spacing" =
   [\s]* COMMENT?
   ;

COMMENT = 
    '//' [^\n]* [\n] SPACING
  / '#' [^\n]* [\n] SPACING
  / '/*' _* . '*/' SPACING;

#
# Special tokens
#

"[\a_][\a\d_]*" = {_self} ![\a\d_] SPACING;
"[;,]" = {_self} SPACING;
"[\y]+" : "operator" = {_self} ![\y] SPACING;
"_" = {_self} SPACING;

#
# Productions used by macro expander
#

PARAN_EXP = {EBLOCK} / "(" {EXP} ")";

ARRAY_SIZE = {EXP} EOF / <literal 0>;

TOKENS = <(...)> {TOKEN}*;

STMTS = <@> {STMT}*;

SPLIT_TOKEN = !"," RAW_TOKEN;
SPLIT = <list> (EOF / {SPLIT_ITEM} ("," {SPLIT_ITEM})* EOF) ;
SPLIT_ITEM = SPLIT_FLAG / SPLIT_PARM;
SPLIT_FLAG = :<> ':'{ID} "="? {SPLIT_PARM};
SPLIT_PARM = <parm> {SPLIT_TOKEN*};
PARAN_LIST = "(" {SPLIT} ")";

PARM : "macro paramater" = 
   {STMT} EOF / {TOKEN} EOF / {EXP} EOF;

EOF = SPACING !_ ;

