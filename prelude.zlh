
//
// libc stuff
//

typedef struct _IO_FILE FILE;
int printf (const char *, ...);
int snprintf(const char * str, size_t size, const char * format, ...);
macro NULL() {0;}
macro true() {1;}
macro false() {0;}
typedef int bool;
int strcmp(const char *s1, const char *s2);
macro offsetof(TYPE, MEMBER) {(size_t) &(reinterpret_cast<TYPE *>(0))->MEMBER;}
void *memcpy(void *dest, const void *src, size_t n);
void *memmove(void *dest, const void *src, size_t n);

//
// Macro ABI
//

typedef struct EnvironSnapshot EnvironSnapshot;

typedef struct Mark Mark;
__ct_callback Mark * new_mark_f(EnvironSnapshot *);
macro new_mark() {new_mark_f(environ_snapshot());}
macro new_empty_mark() {new_mark_f(0);}

struct UnmarkedSyntax;
user_type UnmarkedSyntax {
  finalize_user_type struct UnmarkedSyntax;
}

user_type Syntax;
user_type SyntaxEnum;
__ct_callback bool syntax_simple(Syntax *);
__ct_callback Syntax * syntax_part(Syntax *, unsigned);
__ct_callback unsigned syntax_num_args(Syntax *);
__ct_callback Syntax * syntax_flag(Syntax *, UnmarkedSyntax *);
__ct_callback bool syntax_eq(Syntax *, UnmarkedSyntax *);
__ct_callback SyntaxEnum * syntax_args(Syntax *);
struct Syntax;
user_type Syntax {
  finalize_user_type struct Syntax;
  macro _up_cast (x) {reinterpret_cast<UnmarkedSyntax *>(x);}
  macro _down_cast (x) {reinterpret_cast<Syntax *>(x);}
  make_subtype UnmarkedSyntax _up_cast _down_cast;
  //import UnmarkedSyntax;
  //export simple, flag, part;
  macro simple(:this this) {syntax_simple(this);}
  macro num_parts(:this this) {syntax_num_args(this) + 1;}
  macro num_args(:this this) {syntax_num_args(this);}
  macro part(num, :this this) {syntax_part(this, num);}
  macro arg(num, :this this) {syntax_part(this, num + 1);}
  macro args(:this this) {syntax_args(this);}
  macro flag(str, :this this) {syntax_flag(this, str);}
  macro eq(str, :this this) {syntax_eq(this, str);}
  macro ne(str, :this this) {!syntax_eq(this, str);}
}

user_type SyntaxList;
__ct_callback SyntaxList * new_syntax_list();
__ct_callback int syntax_list_empty(const SyntaxList *);
__ct_callback size_t syntax_list_append(SyntaxList *, Syntax *);
__ct_callback void syntax_list_append_flag(SyntaxList *, Syntax *);
__ct_callback void syntax_list_append_all(SyntaxList *, SyntaxEnum *);
__ct_callback void syntax_list_reverse(SyntaxList *);
__ct_callback void syntax_list_replace(SyntaxList *, size_t pos, Syntax * el);
struct SyntaxList;
user_type SyntaxList {
  finalize_user_type struct SyntaxList;
  import Syntax;
  macro _up_cast (x) {reinterpret_cast<Syntax *>(x);}
  macro _down_cast (x) {reinterpret_cast<SyntaxList *>(x);}
  make_subtype Syntax _up_cast _down_cast;
  //export empty, append;
  macro empty(:this this) {syntax_list_empty(this);}
  macro append(:this this, syn) {syntax_list_append(this, syn);}
  macro append_flag(:this this, syn) {syntax_list_append_flag(this, syn);}
  macro append_all(:this this, els) {syntax_list_append_all(this, els);}
  macro elements(:this this) {syntax_args(this);}
  macro reverse(:this this) {syntax_list_reverse(this);}
  macro replace(:this this, pos, el) {syntax_list_replace(this, pos, el);}
}

user_type SyntaxEnum;
__ct_callback Syntax * syntax_enum_next(SyntaxEnum *);
__ct_callback SyntaxEnum * syntax_enum_clone(const SyntaxEnum *);
struct SyntaxEnum;
user_type SyntaxEnum {
  finalize_user_type struct SyntaxEnum;
  export next;
  macro next(:this this) {syntax_enum_next(this);}
  macro clone(:this this) {syntax_enum_clone(this);}
}

user_type Match;
__ct_callback Match * match_f(Match * m, UnmarkedSyntax * pattern, Syntax * with, Mark * mark);
macro match(m, pattern, with, mark = NULL) {match_f(m, pattern, with, mark);}
__ct_callback Match *match_args_f(Match *, UnmarkedSyntax * pattern, Syntax * with, Mark * mark);
macro match_args(m, pattern, with, mark = NULL) {match_args_f(m, pattern, with, mark);}
__ct_callback Match * match_local(Match *, ...);
__ct_callback Syntax * match_var(Match *, UnmarkedSyntax *);
__ct_callback SyntaxEnum * match_varl(Match *, UnmarkedSyntax *);
struct Match;
user_type Match {
  finalize_user_type struct Match;
  export var, varl;
  macro var(str, :this this) {match_var(this, str);}
  macro varl(str, :this this) {match_varl(this, str);}
}

__ct_callback Syntax * replace(UnmarkedSyntax *, Match *, Mark *);

typedef struct Context Context;
__ct_callback Context * empty_context();
__ct_callback Context * get_context(Syntax *);
__ct_callback Syntax * replace_context(UnmarkedSyntax *, Context *);

typedef struct Environ Environ;

typedef enum  {NoPos = 0, OtherPos = 1, TopLevel = 2, FieldPos = 4, 
               StmtDeclPos = 8, StmtPos = 16, ExpPos = 32} Position;
__ct_callback Syntax * partly_expand(Syntax *, Position pos, Environ *);
__ct_callback SyntaxEnum * partly_expand_list(SyntaxEnum *, Position pos, Environ *);
__ct_callback Syntax * pre_parse(Syntax *, Environ *);
__ct_callback Syntax * reparse(Syntax *, const char *, Environ *);

__ct_callback UnmarkedSyntax * string_to_syntax(const char * str);
__ct_callback const char * syntax_to_string(UnmarkedSyntax *);
__ct_callback void dump_syntax(UnmarkedSyntax *);

user_type UserTypeInfo;
user_type ModuleInfo;
__ct_callback UserTypeInfo * user_type_info(Syntax *, Environ *);
__ct_callback ModuleInfo * user_type_module(UserTypeInfo *);
__ct_callback ModuleInfo * module_info(Syntax *, Environ *);
__ct_callback SyntaxEnum * module_symbols(ModuleInfo *);
__ct_callback bool module_have_symbol(ModuleInfo *, Syntax *);

struct UserTypeInfo;
user_type UserTypeInfo {
  finalize_user_type struct UserTypeInfo;
  export module;
  macro module(:this this) {user_type_module(this);}
}

struct ModuleInfo;
user_type ModuleInfo {
  finalize_user_type struct ModuleInfo; 
  export symbols, have_symbol;
  macro symbols(:this this) {module_symbols(this);}
  macro have_symbol(sym, :this this) {module_have_symbol(this, sym);}
}

__ct_callback Environ * temp_environ(Environ *);

__ct_callback size_t ct_value(Syntax *, Environ *);

__ct_callback Syntax * error(Syntax *, const char *, ...);

__ct_callback Syntax * get_symbol_prop(Syntax * sym, Syntax * prop, Environ * env);

__ct_callback int symbol_exists(UnmarkedSyntax * sym, Syntax * where, Mark *, Environ *);

//
//
//

Syntax * parse_make_syntax_macro(Syntax * p, Environ * env);
make_macro make_syntax_macro`syntax parse_make_syntax_macro :w_snapshot;

//
//
//

Syntax * partly_expand_class(Syntax *, Mark *, Environ *);

Syntax * parse_class(Syntax * p, Environ * env);
//make_syntax_macro class parse_class;
make_macro class`syntax parse_class :w_snapshot;


