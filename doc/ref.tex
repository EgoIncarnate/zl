%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Parsing and Expanding}
\label{parsing}

The macros shown so far have been fairly simply.  Writing more
sophisticated macros, such as those required to implement classes,
requires some knowledge of parsing and macro expansion in ZL.  This
chapter gives the necessary background material, while the next
chapter details how to write such macros.

\section{Parsing Overview}
\label{parsing-overview}

To deal with C's idiosyncratic syntax while also allowing the syntax
to be extensible, ZL does not parse a program in a single pass.
Instead, it uses an iterative-deepening approach to parsing.  The
program is first separated into a list of partly parsed declarations
by a Packrat~\cite{peg-p,peg} parser that effectively groups
tokens at the level of declarations, statements, grouping curly
braces, and parentheses.  Each declaration is then parsed.  As it is
being parsed and macros are expanded, subparts, such as code between
grouping characters, are further separated.

ZL's iterative-deepening strategy is needed because ZL does not
initially know how to parse any part of the syntax involved with a
macro. When ZL encounters something that looks like a function call,
such as |f(x + 2, y)|, it does not know if it is a true function call
or a macro use.  If it is a macro use, the arguments could be
expressions, statements, or arbitrary syntax fragments, depending on
the context in which they appear in the expansion.  Similarly, ZL
cannot directly parse the body of a macro declaration, as it does not
know the context in which the macro will ultimately be used.

\pagebreak

More precisely, the ZL parsing process involves three intertwined
phases as shown in Figure \ref{parsing-overview-fig}. 
\begin{figure}
\begin{center}
\theoverviewfig
\end{center}
\caption{Overview of ZL's parsing process.}
\label{parsing-overview-fig}
\end{figure}
In the first phase \textit{raw text}, such as |(x+2)|, is 
parsed.  Raw text is converted into an intermediate form known as a
\textit{syntax object}, which can still have raw-text components.  
(Throughout this paper we show syntax objects as
S-expressions, such as |("()" "x+2")|.)  In the second phase, the
syntax object is expanded as necessary and transformed into other
syntax objects by expanding macros until a fixed point is reached.  In
the third phase, the fully expanded syntax object is compiled into an
\textit{AST}.

Figure \ref{fig} details ZL's parsing and expansion process.  
\begin{figure}
\begin{center}
\UndefineShortVerb{\|}
\thefig
\DefineShortVerb{\|}
\end{center}
\caption[How ZL compiles a simple program.]%
  {How ZL compiles a simple program.  The body of \texttt{f} is
   reparsed and expanded as it is being compiled.}
\label{fig}
\end{figure}
The top box contains a simple program as raw text, which is first parsed.
The result is a \textit{syntax list} (internally represented as a~|@|)
of |stmt|'s where each |stmt| is essentially a list of tokens, as
shown in the second box.  Each statement is then expanded and compiled
in turn, and is added to the top-level environment (which can be
thought of as an AST node). The third box in the figure shows how this
is done, which requires recursive parsing and expansion.  The first
|stmt| is compiled into the |fun| |f|, while the body of the function
is left unparsed.  Next, |fun| is compiled into an AST (shown as a
rounded rectangle).  During the compilation, the body is expanded.
Since it is raw text, this process involves parsing it further, which
results in a |block|.  Parsing the block involves expanding and
compiling the subparts.  Eventually, all of the subparts are
expanded and compiled, and the fully parsed AST is added to the
top-level environment.  This process is repeated for the function
|main|, after which the program is fully compiled.
\section{The Parser}
\label{parser}

The ZL grammar is specified through a PEG~\cite{peg}, but with a few
extensions to the usual PEG notation, and a Packrat~\cite{peg-p} parser is used to
convert strings of characters to syntax objects.  A simplified version
of ZL's initial grammar is shown in Figure~\ref{grammar}.  
\begin{figure}
\begin{Verbatim}[baselinestretch=1,fontsize=\small]
TOP = <top> SPACING {STMT}+;

STMT = <<mid PARM>> {MID} ";"
     / <if> "if" "(" {EXP} ")" {STMT} ("else" {STMT})?
     / <while> "while" "(" {EXP} ")" {STMT}
     / <break> "break" ";"
     / <return> "return" {EXP} ";"
     / {BLOCK}
     # other statements ...
     / {CUSTOM_STMT}
     / <stmt> ({TOKEN_}+ {PAREN} {BRACE} / {TOKEN}+ ";");
CUSTOM_STMT = !__;

EXP = <exp> {TOKEN}+;

BLOCK = <block> "{" {STMT}* "}";

TOKEN_ =  <<mid PARM>> {MID} / {STRUCT_UNION} / 
          {BRACK} / {CONST} / {ID} / {SYM} / 
TOKEN = TOKEN_ / PAREN;

PAREN =  <<reparse ()>> "(" {RAW_TOKEN*} ")";
BRACE =  <<reparse {}>> "{" {RAW_TOKEN*} "}";
BRACEL = <<reparse @{}>> "{" {RAW_TOKENS} "}";
BRACK =  <<reparse []>> "[" {RAW_TOKEN*} "]";

CONST = <f> ...  / <l> ... / # float, numeric literal
        <s> ... / <c> ...    # string, character
ID = <<mid>> {MID} / {[@$\a_][\a_\d]*} SPACING;
SYM = {'...' / '==' / '+' / ...} SPACING;

STRUCT_UNION = <%> {"struct"/"union"/"class"} {ID/}
                   {STRUCT_UNION_PARMS} {<{...}> {BRACEL} }?;
STRUCT_UNION_PARMS = (:<public> ":" "public" {ID})?;

RAW_TOKEN = STRING / CHAR / SYM / BRACE / PAREN / 
            BRACK / COMMENT / [^\)\]\}];

STRING = '"' ('\\'_/[^"])+ '"' SPACING;
CHAR   = '\'' ('\\'_/[^'])+ '\'' SPACING;

SPACING = [\s]* COMMENT?;

COMMENT = ...;
\end{Verbatim}
\caption{Simplified PEG grammar.}
\label{grammar}
\end{figure}

For readers not familiar with PEGs, the two most important things to
note are that PEGs work with characters rather than tokens, and
the~|/| operator defines a prioritized choice.  A prioritized choice
is similar to the \verb/|/ operator used in Backus-Naur Form, except
that it \textit{unconditionally} uses the first successful match.  For
example, given the rule ``|A = 'a' / 'ab'|'' the string |ab| will
never match because the first choice is always taken.  The PEG
specification more closely resembles regular expression syntax (as
used in |grep|) than it does Backus-Naur Form. The |()|, |[]|, |?|,
|*|, |+|, and |_| (otherwise known as~|.|) operators are all used in
the same manner as they are in regular expressions.

Anything between single quotes is a literal string.  The double quote
is like the single quote, except that special rules make them behave
similarly to tokens.  For example, |"for"| will match the |for| in
|for(|, but it will not match the prefix of |foreach|.  

The |{}| and |<>| are extensions to the standard PEG syntax and are
used for constructing syntax objects in the obvious ways.  The special
|<<reparse>>| operator creates a syntax object with a raw-text
component that will be parsed later.  The special |<<mid>>| operator
and |MID| production are explained later in Section \ref{reparser}.

The |CUSTOM_STMT| production serves as a hook to allow easily adding
new statements to the grammar.  The |__| operator always matches and
the |!| inverts the results; thus, |!__| never matched.  This
production therefor does nothing by default.

\section{Extending the Parser}
\label{extending-parser}

ZL currently provides very basic support for expanding the parser by
rewriting productions.  Like macros, parser extensions in ZL are given
in source code using the |new_syntax| form (as oppose to using a
separate file).  For example, the following add a new |foreach|
statement form (from Section \ref{foreach} in the tutorial)
\begin{code}
new_syntax {
  CUSTOM_STMT := _cur / <foreach> "foreach" "(" {ID} "in" {EXP} ")" {STMT};
}
\end{code}
by adding a new prioritized choice to the special |CUSTOM_STMT|
production in which the special |_cur| production refers to the
previous version of the |CUSTOM_STMT|.  The other common way to add
new syntax is to add a new sequence item; for example,
\begin{code}
new_syntax {
  STRUCT_UNION_PARMS := _cur (:<fix_size> ":" "fix_size" "(" {EXP} ")" )?;
}
\end{code}
adds extra syntax to the |class| form (used in the example in Section
\ref{fix_size}).

The |new_syntax| form works by creating a new parser, which is then
used for any text within the current scope that has not yet been parsed.
This has not precisely defined yet, but for the most part it will work as
expected.  A consequence of this rule is that redefining fundamental
aspects of the grammar (such as strings, comments, deliminators) is
unlikely to work.


\section{Built-in Macros}
\label{built-in}

The grammar serves to separate individual statements and declarations,
and to recognize forms that are convenient to recognize using a
Packrat parser.  As such, it creates syntax objects that need
additional processing before they can be compiled into an AST.  The
expander has several built-in macros for this purpose: |stmt|,
|exp|, |()|, |[]|, and |{}|.

The |stmt| macro recognizes declarations and expressions.  It first tries the
declarations expander, which is a handwritten parser designed to
deal with C's idiosyncratic syntax for declarations.  If the
declarations expander fails, then the expression expander is tried,
which is an operator-precedence parser~\cite{opp}.  
The |exp| macro is like the |stmt| macro, but only the expression
expander is tried.

The macros |()|, |[]|, and |{}| are used for reparsing
strings.  The |()| and |[]| macros reparse the string as an
expression using the |EXP| production in the grammar, where as the
|{}| generally reparses the string as a block using the |BLOCK|
production.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Procedural Macros}
\label{proc-macros}

So far only the high level syntax for procedural macros are shown.  ZL
also allows for defining the macro-transformer function directly.
This chapter will present the low-level interface, and the associated
API.  Many of the API function can also be used with the higher-level
procedural macro form.  The chapter ends with an extended example to
get a better idea of how many of the API components work.

\section{Low Level Procedural Macros}
\label{low-level-proc}

Figure~\ref{proc-example} demonstrates the essential parts of any
procedural macro.  The macro is defined as a function that takes a
syntax object (and optionally an environment), and returns a
transformed syntax object.  Syntax is created using the |syntax| form.
The |match_f| function is used to decompose the input while the
|replace| function is used to rebuild the output.  Finally,
|make_macro| is used to create a macro from a function.  More
interesting macros use additional API functions to take action based
on the input.  Figure~\ref{core-macro-abi} defines the key parts of
the macro API, which we describe in the rest of this section.

\begin{figure}
\begin{codef}
Syntax * or(Syntax * p) {
  Match * m = match_f(NULL, syntax (x, y), p);
  return replace(syntax 
                   {({typeof(x) t = x; t ? t : y;});}, 
                 m, new_mark());
}
make_macro or;
\end{codef}
\caption{Procedural macro version of \texttt{or} macro from Section \ref{pattern-macros}.}
\label{proc-example}
\end{figure}

\begin{figure}
\textbf{Types:} |UnmarkedSyntax|, |Syntax|, |Match|, and |Mark| \\

\textbf{Syntax forms:} \\
\hspace*{1em}\verb/new_mark()/ --- returns \verb/Mark */ \\
\hspace*{1em}\verb/syntax (...)|{...}|ID/ --- returns \verb/UnmarkedSyntax */ \\
\hspace*{1em}\verb/raw_syntax (...)/ --- returns \verb/UnmarkedSyntax */ \\
\hspace*{1em}\verb/make_macro ID [ID];/ \\

\textbf{Callback functions:} \\
\hspace*{1em}\verb/Match * match_f(Match * prev, UnmarkedSyntax * pattern, Syntax * with)/\\
\hspace*{1em}\verb/Syntax * match_var(Match *, UnmarkedSyntax * var);/\\
\hspace*{1em}\verb/Syntax * replace(UnmarkedSyntax *, Match *, Mark *)/\\
\hspace*{1em}\verb/size_t ct_value(Syntax *, Environ *)/
\caption{Basic macro API.}
\label{core-macro-abi}
\end{figure}

Syntax is created using the |syntax| and |raw_syntax| forms.  The
different forms create different types of code fragments.  In most
cases, the |syntax {...}| form can be used, such as when a code
fragment is part of the resulting expansion; the braces will not be in
the resulting syntax.  If an explicit list is needed, for example,
when passed to |match_f| as in Figure \ref{proc-example}, then
the |syntax (...)| form should be used (in which the commas are part
of the syntax used to create the list).  Neither of these forms create
syntax directly, however; for example, |syntax {x + y;}| is first
parsed as {\tt |("{}"| |"x + y;")|} before eventually becoming {\tt
  |(plus| |x y)|}.  When it is necessary to create syntax directly,
the |syntax ID| form can be used for simple identifiers.  For more
complicated fragments the |raw_syntax| form can be used in which the
syntax is given in S-expression form.

The |match_f| function decomposes the input.  It matches pattern
variables (the second parameter) with the arguments of the macro (the
third parameter).  If it is successful, it prepends the results to
|prev| (the first parameter) and returns the new list.  If |prev| is
|NULL|, then it is treated as an empty list.  In the match pattern a
|_| can be used to mean ``don't care.''

The |replace| function is used to rebuild the output.  It takes a
syntax object (the first parameter, and generally created with
|syntax|), replaces the pattern variables inside it with the values
stored in the |Match| object (the second parameter), and returns a new
|Syntax| object.

The final argument to |replace| is the \textit{mark}, which is used to
implement hygiene.  A mark captures the lexical context at the point
where it is created.  Syntax objects created with |syntax| do not have
any lexical information associated with them, and are thus
\textit{unmarked} (represented with the type |UnmarkedSyntax|).  It is
therefore necessary for |replace| to attach lexical information to the
syntax object by using the mark created with the |new_mark| primitive
(the third parameter to |replace|).

Match variables exist only inside the |Match| object.  When it is
necessary to access them directly, for example, to get a compile-time
value, |match_var| can be used; it returns the variable as a |Syntax|
object, or |NULL| if the match variable does not exist.  If the 
compile-time value of a syntax object is needed, |ct_value| can be used, which
will expand and parse the syntax object and return the value as an
integer.  

Once the function for a procedural macro is defined, it must be
declared as a macro using |make_macro|.

\section{Macro Transformer Arguments}

The macro transformer can take one of four forms.  So far only the
most basic of forms was shown, that is a transformer that takes a
single argument which is the syntax object to be transformed:
\begin{code}
Syntax * macro_fun(Syntax *)
\end{code}
The passed in syntax object is the arguments to the macro call and not
the call itself.  When the call itself is needed a two argument form
can be used:
\begin{code}
Syntax * macro_fun(Syntax * call, Syntax * args)
\end{code}
In the case of a syntax macro |call| and |args| point to the same object.
In the case of a function-call macro |call| has the form
\begin{code} 
(call name (. arg1 arg2 ...))
\end{code}
and |args| has the form 
\begin{code}
(. arg1 arg2 ...)
\end{code}

The macro transformer can also accept an environment in either if the
above forms:
\begin{code}
Syntax * macro_fun(Syntax *, const Environ *)
Syntax * macro_fun(Syntax *, Syntax *, const Environ *)
\end{code}
ZL will also accept a transformer that expects a non-const
environment, but that form is deprecated as directly modifying the
environment in the transformer can lead to unpredictable results.

\section{Macro API}

The next couple of sections will detail various aspects of the Macro
API.  The API has both a class-like form and a procedure form; these
sections presents the class-like form.  The mapping from the class API
to the raw API is straightforward.  The general scheme is that the
object name prepends the method in all lower case with an underscore
separating it from the method name.  The object is then passed in as
the first parameter.  For example, the method:%
\begin{code}
Syntax * Match::var(UnmarkedSyntax * var);
\end{code}
becomes
\begin{code}
Syntax * match_var(Match *, UnmarkedSyntax * var)
\end{code}

You may notice that many functions have seemly pointless default
parameters.  In reality these are expected to bind to a local fluid
binding, which is used by high-level procedural macros and the
quasiquotes.  The details of how both use these arguments will be
given the next chapter.  For now, it is sufficient to know that when
using high-level procedural macros the |mark| and |envision| symbols
will be defined for you.

\section{The Syntax Object}
\label{syntax-obj}

The API for syntax objects (see \ref{parsing-overview}) is
listed in Figure \ref{syntax-abi}.
\begin{figure}
\begin{apil}
\item \kw{Type} |UnmarkedSyntax|
\item \kw{Type} |Syntax|, \textit{subtype of} |UnmarkedSyntax|, with \kw{methods}:
\begin{apill}
\item \verb/Syntax * num_parts(unsigned)/
\item \verb/Syntax * part(unsigned)/
\item \verb/Syntax * flag(UnmarkedSyntax *)/
\item \verb/bool simple()/
\item \verb/bool eq(UnmarkedSyntax *)/
\item \verb/Syntax * stash_ptr(void *)/ (static method)
\item \verb/void * extract_ptr()/
\end{apill}
\end{apil}
\caption{Syntax object API.}
\label{syntax-abi}
\end{figure}
There are two syntax-objects types, \verb/UnmarkedSyntax/ and
\verb/Syntax/.  The difference between the two is the first represents
a syntax object that has not been marked (see \ref{low-level-proc}) yet, 
while the second one
has.  A \verb/Syntax/ object will automatically convert to a
\verb/UnmarkedSyntax/.  But in order to go from \verb/UnmarkedSyntax/
to \verb/Syntax/ the syntax object needs be marked, which is generally
done via \verb/replace/.

Internally \verb/UnmarkedSyntax/ and \verb/Syntax/ are the same type.
The distinction in the API is to avoid invalid use of unmarked syntax
objects.

A syntax object consists of one or more parts, and optional flags.
The first part has special meaning and is used to identify the syntax,
provided that it is simple.  A \textit{simple} syntax object is
basically\footnote{This is an over simplification since ``foo'' and
  ``(foo)'' are not the same.  The first is considered simple while
  the second is not.} a syntax object with just one part, and no
flags.  Internally it is represented slightly differently.  Parts
other than the first are considered arguments.

\label{syntax-flags}
Syntax objects can also have any number of optional flags.  A flag is a
named argument and is retrieved by name, rather than position.  A flag
itself is just a normal syntax object with the first part used to name
the flag.  Flags can be tested for existence using the \verb/Syntax/'s
|flag| method (which returns |NULL| if the flag does not exist) or
matched with the match family of functions (see \ref{matching}).
Flags are primarily used when parsing declarations and can be created in
macros by using the \verb/raw_syntax/ primitive.  For example the
following syntax object:
\begin{code}
(... :flag1 :(flag2 value2))
\end{code}
contains two flags, where \verb/flag1/ is a flag without any value
associated with it while \verb/flag2/ is a flag with a value.  Flags
can also be passed into function call macros in which are just another
name for the already described keyword arguments.

Syntax objects can also contain other types of objects embedded within
them.  A syntax object of such form is considered an \textit{entity}.
The most common types of objects are parsed syntax either in the form
of an AST node or a symbol.  However, it is also possible to embed
arbitrary objects such as pointers in a syntax object using the
|stash_ptr| and |extract_ptr| methods.  These methods are most
commonly used in combinations with Symbol properties, which will be
described in \ref{symbol-prop}.

Sometimes it is useful to get information on the syntax object
without having to use |match_f|.  For this ZL provides a number of
methods to directly access the syntax object and get basic
information.  The |part| and |num_parts| method can be used for direct
access.  The |eq| and |simple| method can be used to get basic
properties on the syntax object.  The |eq| method tests if the syntax
object is equal to another, taking into account that the first one may
be marked.  The |simple| method tests if the syntax object is simple
as previously described.

\section{The Syntax List}
\label{SyntaxList}

A \textit{syntax list} is a syntax object whose first part is a |@|.
It represents a list of syntax objects (which can include flags).
Lists have the effect of being spliced into the parent syntax object.

Syntax lists can be used as values for macro identifiers, in which case
the results are spliced in.  Macros can return syntax lists, but the
results are not automatically spliced in.  Rather when a list of
elements is parsed any |@| are flattened as the list is read in.
It is an error to return a syntax list in a nonlist context.

The |SyntaxList| API is shown in Figure \ref{syntax_list-api}.
\begin{figure}
\begin{apil}
\item \kw{Type} |SyntaxList|, \textit{subtype of} |Syntax|, with \kw{constructor}:
\begin{apill}
\item |SyntaxList * new_syntax_list()|
\end{apill}
and \kw{methods:}
\begin{apill}
\item |int empty()|
\item |void append(Syntax *)|
\item |void append_flag(Syntax *)|
\item |SyntaxEnum * elements()|
\end{apill}
\item \kw{Type} |SyntaxEnum| with \kw{methods}:
\begin{apill}
\item |Syntax * next()|
\item |SyntaxEnum * clone()|
\end{apill}
\end{apil}
\caption{Syntax list API.}
\label{syntax_list-api}
\end{figure}
Syntax lists are created using the \verb/new_syntax_list/ function.
Elements are then appended to the list using the \verb/append/ or
\verb/append_flag/ method.  The \verb/empty/ method returns true if
the list has 0 elements.  The \verb/elements/ method is used to
iterate through the elements and return a \verb/SyntaxEnum/.  The
|next| method of |SyntaxEnum| returns the next element in the list or
NULL if there is none, while the |clone| method returns a copy of the
|SyntaxEnum|.

\section{Matching and Replacing}
\label{matching}

Figure \ref{match-api} lists the API for matching and replacing (see
\ref{low-level-proc}).
\begin{figure}
\begin{apil}
\item \kw{Type} \verb/Match/ with \kw{methods}:
\begin{apill}
\item |Syntax * var(UnmarkedSyntax *)|
\item |SyntaxEnum * varl(UnmarkedSyntax *)|
\end{apill}
and \kw{related functions}:
\begin{apill}
\item |Match * match_f(Match * prev, UnmarkedSyntax * pattern, Syntax * with)|
\item |Match * match_parts_f(Match *, UnmarkedSyntax * pattern, Syntax * with)|
\item |Match * match_local(Match *, ...)|
\end{apill}
\item \kw{Callback function}:
\begin{apill}
\item |Syntax * replace(UnmarkedSyntax *, Match *, Mark *)|
\end{apill}
\end{apil}
\caption{Match and replace API.}
\label{match-api}
\end{figure}
The |match_f| and |replace| functions have already been
described.  The |var| method is identical to the previously described
|match_var| function.  The |varl| method is like |var| except that it
returns an an enumeration for iterating through the elements of a
syntax object that is also a list.  The fact that it results an
enumeration rather than a list is deliberate, since syntax lists are
mutable objects, and the results from a match are not.  


The |match_f| function matches the \textit{arguments} of a syntax
objects, which excludes the first part (generally the name of a syntax
object).  The |match_parts_f|, by contrast, matches the complete
syntax object by matching the \textit{parts} of the syntax object.

When it is necessary to build syntax directly from syntax objects, the
|match_local| function provides a convenient way to do so.  It takes
in a match object and a list of syntax objects, terminated by
|NULL|.  It will assign a numeric match variable in the form of
\verb|$NUM| with the first one being \verb|$1|.

%Strictly speaking, only the \verb/match/ function is necessary, as the
%others (including methods) can be written in terms of it.  However,
%for efficiency reasons, they are all defined directly in the API.

\section{Match Patterns}
\label{match_patterns}

A pattern to be matched against is expected to either be a simple list
of the form \verb/syntax (a, b, ...)/ or fully parsed, i.e., created
with \verb/raw_syntax/.  The difference is that pattern variables
matched with the former will need to be reparsed while patterns
variables matched with latter do not.

The |syntax ()| form is designed to be used when matching parameters
passed in via a function-call macro.  The pattern contains a list of
the following (with some restrictions on order):
\begin{itemize*}
\item \ID\
\item \ID\ \verb/=/ \VALUE\ -- must be after all plain ID's
\item \verb/@/ -- can only appear once
\item \verb/@/\ID\ -- must be last
\item \verb/:/\FLAG\
\item \verb/:/\FLAG\ \ID\
\item \verb/:/\FLAG\ \ID\ \verb/=/ VALUE
\end{itemize*}
\ID\ matches a normal parameter.  The second item, ``\ID\ \verb/=/
\VALUE'', is used for giving parameter default values if they are
omitted.  A |_| can be used any place an identifier will be used when
the value is irrelevant.  Parameters can also be optional if they are after the
special |@| instruction, in which case they will simply be omitted
from the match list.  The |@|\ID\ form will match any remaining
parameters and store them in a syntax list.  
Flags (otherwise known as keyword arguments) 
can also be matched with any of the \verb/:/\FLAG\ forms.
Flags, in the current implementation, are always optional; however, any
matched flags will not appear in the syntax list matched with \verb/@/\ID.

For example, in the pattern \snip{(X, \_, Y, Z~=~9, :flag1, :flag2~\_,
  :flag3~F2~=~8, @, A, B, @REST)}, the first three positional
parameters are required, but we do not care about the value of the
second.  In addition the flags |flag1| and |flag2| are required,
with the second one also requiring a value.  In addition to the
required parameters, the next three positional parameters will be
stored in |Z|, |A|, and |B| respectively.  If the fourth parameter is
not given it will get the default value 9, while if the other two are
not given they will simply not be present in the match list.  Any
additional parameters passed in will be stored in |REST| as a list.
Finally, the flag |flag3| may also be given, but if it is not, it
will assume the default value |8|.

A pattern can also be specified in |raw_syntax| form, which is designed
to be used with syntax macros.  In the |raw_syntax| form a pattern
can represent anything that a match list can.  
In addition, it is possible to match the subparts of
an expression using {\tt |(pattern| |(WHAT ...))|}.  For example, to
match the list of declarations inside of a class body which is
represented as {\tt |(class foo| |({...} decl1 decl2))|} into the
pattern variable |body|, the {\tt |(_ _| |(pattern| |({...} @body)))|}
pattern can be used.

It is also possible to use the |raw_syntax| form with function-call
macros; however, when doing so it is important to know that the macro
parameters are not parsed.  For example if |f| is a function-call
macro, the parameter of the call |f(x+2)| is passed in as 
|(parm "x+2")|. When using the |syntax| forms for matching, ZL's normal parsing
process (see \ref{parsing}, \ref{reparser}) parses the string at
the right time.  But the |raw_syntax| form skips this step.  Thus, it
it necessary to manually instruct ZL to parse the parameter passed in by
using |(reparse ID)|.  For example, to match the parameter in the |f|
macro above use:%
\begin{code}
match_f(..., raw_syntax((reparse ID), ...))
\end{code}

\section{Creating Marks}
\label{marks}

Marks (see \ref{low-level-proc}) are used to implement lexical scope, and
the API is listed in Figure~\ref{mark-api}.  The |new_mark| primitive
is actually a macro that calls the callback function
|new_mark_f| and uses the primitive |environ_snapshot()| to capture
the environment.

\begin{figure}
\begin{apil}
\item \kw{Type} |EnvironSnapshot| with \kw{related syntax form}:
\begin{apill}
\item |environ_snapshot()| --- returns |EnvironSnapshot *|
\end{apill}
\item \kw{Type} \verb/Mark/ with \kw{related function}:
\begin{apill}
\item |Mark * new_mark_f(EnvironSnapshot *)|
\end{apill}
and \kw{macros}:
\begin{apill}
\item |macro new_mark(es = NULL) {new_mark_f(es ? es : environ_snapshot();}|
\item |macro new_empty_mark() {new_mark_f(0);}|
\end{apill}
\end{apil}
\caption{Mark API.}
\label{mark-api}
\end{figure}

\section{Partly Expanding Syntax}

In complex syntax macros, it is often necessary to decompose the parts
passed in.  However, in most cases, those parts are not yet expanded;
thus it is necessary to expand them first.  To support this expansion
ZL provides a way to partly expanded a syntax object in the same way
it will internally; the API is shown in Figure~\ref{expander}.

\begin{figure}
\begin{apil}
\item \kw{Callback functions}:
\begin{apill}
\item |Syntax * partly_expand(Syntax *, Position pos, Environ *)|
\item |SyntaxEnum * partly_expand_list(SyntaxEnum *, Position pos, Environ *)|
\end{apill}
and \kw{enum} \verb/Position/ with \kw{possible values}:
\begin{apill}
\item |NoPos|, |OtherPos|, |TopLevel|, |FieldPos|, |StmtDeclPos|, |StmtPos|, |ExpPos|
\end{apill}
\end{apil}
\caption{Expander API.}
\label{expander}
\end{figure}

The |pos| parameter tells ZL what position the syntax object is
in; the values of the |Position| enum can be bitwise or'ed together.
This parameter will affect how the expansion and, if
necessary, reparsing is done.  Common
values are |TopLevel| for declarations, |StmtPos| for statements, and
|ExpPos| for expressions. The |Environ| parameter is the
environment as passed into the macro.  

If the parts of a syntax object represent a list of some kind, it is
best to use |partly_expand_list|.  The function |partly_expand_list|
is like |partly_expand|, except that it expects a list of elements in
the form of an |SyntaxEnum|, and it automatically flattens any Syntax
Lists (ie |@|) found inside the list.  The elements of the list are
expanded as they are iterated through, rather than all at once when
the function is called.

\section{Compile-Time Reflection}

Often it is necessary to do more than just decompose syntax.
Sometimes, it is necessary to get compile-time information on the
syntax objects or the environment itself---for example, to get numerical
value of an expression as was done in with |fix_size| in Section
\ref{fix_size} or to check if a symbol exists as is done in |foreach|
in Section \ref{foreach-proc}.  Figure \ref{ctf} shows some of the
available API functions for compile-time reflection.

\begin{figure}
\begin{apil}
\item \kw{Callback functions}:
\begin{apill}
\item |unsigned ct_value(Syntax *, const Environ * = environ)|
\item |bool symbol_exists(UnmarkedSyntax * sym, Syntax * where,|\\
      |                   Mark * = mark, const Environ * = environ)|
\item |Environ * temp_environ(const Environ *)|
\item |Syntax * pre_parse(Syntax *, Environ *)|
\end{apill}
\end{apil}
\caption{Compile time reflection API.}
\label{ctf}
\end{figure}

The |ct_value| function (which was used in the |fix_size| example)
takes a syntax object, expands the expression, parses the expansion,
and evaluates the parsed expression as an integer to determine its
value.  An error is thrown if the expression passed in is not a
compile time constant.

To see if a symbol exists in the current environment or an object that
is a user type (as was done in the |foreach| example), the
|symbol_exists| function can be used.  The |first| argument is the
symbol to check for.  The |second| argument is the user type to check
that the symbol exists in; if it is |NULL| then the current
environment will be checked instead.  The third argument provides the
context in which to look up the current symbol, and finally the last
argument is the environment to use.

Sometimes in order to get compile-time information it is necessary to
add additional symbols to the environment.  For this the
|temp_environ| and |pre_parse| functions are used, as was done in the
|fix_size| macro.  The |temp_environ| function creates a new temporary
environment while |pre_parse| parses a declaration just enough to get
basic information on it, and then adds it the the environment. The
creation of a temporary environment avoids affecting the outside
environment with any temporary objects added with |pre_parse|.

\section{Misc API Functions}

Sometimes it is necessary to create syntax on the fly, such as
creating syntax from a number that is computed at run time.  The
|string_to_syntax| function, shown in Figure \ref{misc-api}, converts
a raw string to a syntax object.
\begin{figure}
\begin{apil}
\item \kw{Callback functions}:
\begin{apill}
\item |UnmarkedSyntax * string_to_syntax(const char *)|
\item |const char * syntax_to_string(UnmarkedSyntax *)|
\item |void dump_syntax(UnmarkedSyntax *)|
\item |Syntax * error(Syntax *, const char *, ...)|
\end{apill}
\end{apil}
\caption{Misc API functions.}
\label{misc-api}
\end{figure}
The string passed in is the same as given for the |syntax| form, which
can be specified at run time.

The |syntax_to_string| function does the reverse, which is primarily
useful for checking an identifier for a literal value.  It is also
useful for debugging to see the results of a complex macro.  However,
for large syntax objects the |dump_syntax| function is more efficient.
For complex syntax objects the output of both functions is designed to
be human readable and as such the output is not suitable for reparsing
with |string_to_syntax|.

The |error| function is used to return an error condition.  It
creates a syntax object that results in an error when it is
parsed.  The first argument is used to determine the location where
the error will be reported; the location associated with this syntax
object is used as the location of the error.

\section{An Extended Example}

\label{fix_size}

To get a better idea of how procedural macros work, this section gives
the code of a macro that fixes the size of a class.  Fixing the size
of a class is useful because changing the size often breaks
binary compatibility, which forces code using that class to be
recompiled.  Additional examples of how ZL can be used to mitigate the
problem of binary compatibility are given in our previous
work~\cite{abi-gpce10}.

\begin{figure}
\begin{codefnum}
Syntax * parse_myclass(Syntax * p, Environ * env) {
  Mark * mark = new_mark();
  Match * m = match_f
      (0, raw_syntax(name @ (pattern ({...} @body))
                       :(fix_size fix_size) @rest), p);
  Syntax * body = match_var(m, syntax body);
  Syntax * fix_size_s = match_var(m, syntax fix_size);

  if (!body || !fix_size_s) return parse_class(p, env);

  size_t fix_size = ct_value(fix_size_s, env);

  m = match(m, syntax dummy_decl,
            replace(syntax {char dummy;}, NULL, mark));
  Syntax * tmp_class = replace(raw_syntax
      (class name ({...} @body dummy_decl) @rest),
                               m, mark);
  Environ * lenv = temp_environ(env);
  pre_parse(tmp_class, lenv);
  size_t size = ct_value
      (replace(syntax(offsetof(name, dummy)), m, mark),
       lenv);

  if (size == fix_size)
    return replace(raw_syntax
                     (class name ({...} @body) @rest),
                   m, mark);
  else if (size < fix_size) {
    char buf[32];
    snprintf(buf, 32, "{char d[%u];}", fix_size - size);
    m = match(m, syntax buf,
            replace(string_to_syntax(buf), NULL, mark));
    return replace(raw_syntax
                    (class name ({...} @body buf) @rest),
                   m, mark);
  } else
    return error(p,"Size of class larger than fix_size");
}
make_syntax_macro class parse_myclass;
\end{codefnum}
\caption[Macro to fix the size of a class.]%
  {Macro to fix the size of a class.  All \texttt{...} in
  this figure are literal.}
\label{fix_size-fig}
\end{figure}


The macro to fix the size of the class is shown in Figure
\ref{fix_size-fig}.  To support this macro the grammar has been
enhanced to support fixing the size.  The syntax for the new class
form is:
\begin{code}
class C : fix_size(20) { ... };
\end{code}
which will allow a macro to fix the size of the class |C| to 20 bytes.
The enhancement involved modifying the |STRUCT_UNION_PARMS| production
to support the |fix_size| construct using the |new_syntax| form (see
Section \ref{extending-parser}):
\begin{code}
new_syntax {
  STRUCT_UNION_PARMS := _cur (:<fix_size> ":" "fix_size" "(" {EXP} ")" )?;
}
\end{code}
Most of the syntax is already described in Section \ref{parser}.  The
only new thing is |:<>|, which constructs a property to be added to
the parent syntax object, which in this case is |class|.  The |{...}|
(in which the |...| are literal) is the name of the syntax object for
the class body.

The macro in Figure \ref{fix_size-fig} redefines the built-in |class|
macro.  It works by parsing the class declaration and taking its size.
If the size is smaller than the required size, an array of characters
is added to the end of the class to make it the required size.

The details are as follows. Lines 2--7 decompose the class syntax
object to extract the relevant parts of the class declaration.  A |@|
by itself in a pattern makes the parts afterward optional.  The
|pattern| form matches the sub-parts of a syntax object; the first
part of the object (the |{...}| in this case) is a literal\footnote{ZL
  matches literals symbolically (i.e., not based on lexical context).
  Matching sensitive to lexical context is future work.} to match
against, and the other parts of the object are pattern variables.  A
|@| followed by an identifier matches any remaining parameters and
stores them in a syntax list; thus, |body| contains a list of the
declarations for the class.  Finally, |:(fix_size fix_size)| matches
an optional keyword argument; the first |fix_size| is the keyword to
match, and the second |fix_size| is a pattern variable to hold the
matched argument.

If the class does not have a body (i.e., a forward declaration) or a
declared |fix_size|, then the class is passed on to the original class
macro in line 9.  Line 11 compiles the |fix_size| syntax object to get
an integer value.

Lines 13--22 involve finding the original size of the class.  Due to
alignment issues the |sizeof| operator cannot be used, since a class
such as ``{\tt |class D| |{int x;| |char c;}|}'' has a packed size of
5 on most 32 bit architectures, but |sizeof(D)| will return 8.  Thus,
to get the packed size a dummy member is added to the
class.  For example, the class |D| will become ``{\tt |class D| |{int x;|
    |char c;| |char dummy;}|}'' and then the offset of the dummy member
with respect to the class |D| is taken.  This new class is created in
lines 13--17.  Here, the |@| before the identifier in the replacement template
splices in the values of the syntax list.

To take the offset of the dummy member of the
temporary class, it is necessary to parse the class and get it into an
environment.  However, we do not want to affect the outside
environment with the temporary class.  Thus, a new temporary environment
is created in line 18 using the |temp_environ| macro API
function.  Line 19 then parses the
new class and adds it to the temporary environment.  The
|pre_parse| API function partly expands the passed-in syntax object and
then parses just enough of the result to get basic information 
about symbols.

With the temporary class now parsed, lines 20--22 get the size of the
class using the |offsetof| primitive.

Lines 24--37 then act based on the size of the class.  If the
size is the same as the desired size, there is nothing to do and the
class is reconstructed without the |fix_size| property (lines
24--27).  If the class size is smaller than the desired size, then the
class is reconstructed with an array of characters at the end to get
the desired size (lines 28--35).  (The |string_to_syntax| API function
simply converts a string to a syntax object.)  Finally, an error is
returned if the class size is larger than the desired size (lines
36--37).

The last line declares the function |parse_myclass| as a syntax macro
for the |class| syntax form.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Quasiquoting}
 
To be written.  How high level procedural macro are implemented.

%% FIXME: Write chapter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Hygiene System}

Section \ref{macro-export-intro} and \ref{fluid-intro} of the tutorial
give two simple ways to bend hygiene.  Doing anything more advanced
requires knowledge of how ZL's hygiene system works.  This chapter
explains ZL hygiene system (Section \ref{hygiene}) and how to bend it
(Section \ref{bending-hygiene}).

In some ways ZL's hygiene system is similar to the |syntax-case|
system~\cite{syn-abst}.  However, the data structures are different. A
mark holds a lexical environment, and marks are applied during
|replace| rather than to the input and result of a macro
transformer. Special lookup rules search mark environments in lieu of
maintaining a list of substitutions.

\section{Implementation}
\label{hygiene}
During parsing, ZL maintains an environment that maps from one type of
symbol to another.  Symbols in the environment's domain correspond to
symbols in syntax objects, while each symbol in the environment's
range is generated to represent a particular binding.  Symbols in
syntax objects (and hence the environment domain) have a set of marks
associated with them.  The set of marks are considered part of the
symbol's identity.  A mark is created with the |new_mark| primitive
and applied to symbols during the replacement process (via |replace|).
During this process, each symbol is either replaced, if it is a macro
parameter, or marked.  A mark also has an environment associated with
it, which is the global environment at the site of the |new_mark|
call.

When looking up a binding, the current environment is first checked.  If
a symbol with the same set of marks is not found in the current
environment, then the outermost mark is stripped and the symbol is
looked up in the environment associated with the stripped mark.  This
process continues until no more marks are left.

%% \subsection{A Simple Example}
%%
%% \FIXME{Example From Sceme Workshop Presentation}
%%
%% \subsection{Another Example}

\subsection{An Illustrative Example}

To better understand this process, consider the code in Figure
\ref{hygiene-fig}.  
\begin{figure}
\begin{codef}
float r = 1.61803399;

Syntax * make_golden(Syntax * syn, Environ * env) { 
  Mark * mark = new_mark(); 
  Match * m = match_f(0, syntax (A,B,ADJ,FIX), syn); 
  UnmarkedSyntax * r = syntax { 
    for (;;) { float a = A, b = B; 
               float ADJ = (a - r*b)/(1 + r); 
               if (fabs(ADJ/(a+b)) > 0.01) FIX; 
               else break; } 
  }; 
  return replace(r, m, mark); 
} 
make_macro make_golden; 

int main() {
  float q = 3, r = 2;
  make_golden(q, r, a, {q -= a; r += a;});
}
\end{codef}
\caption[Example code to illustrate how hygiene is maintained.]%
{Example code to illustrate how hygiene is maintained.
  The {\tt make\char`\_golden} macro will test if {\tt A} and {\tt
    B} are within 1\% of the golden ratio.  If not, it will execute
  the code in {\tt FIX} to try to fix the ratio (where the required
  adjustment will be stored in {\tt ADJ}) and then try again until the 
  golden ratio condition is satisfied.}
\label{hygiene-fig}
\end{figure}
When the first binding form ``|float r = ...|'' is
parsed, |r| is bound to the unique symbol \verb/$r0/, and the mapping
\verb/r => $r0/ is added to the current environment.  When the
function |make_golden| is parsed, it is added to the environment.
When the |new_mark()| primitive is parsed inside the body of the
function, the current global environment is remembered.  The
|new_mark()| primitive does not capture local variables, since it
makes little sense to use them in the result of the macro.  Next,
``|make_macro make_golden|'' is parsed, which makes the function
|make_golden| into a macro.

Now the body of |main| is parsed.  A new local environment is
created.  When ``|float q = 3, r = 2|'' is parsed, two unique symbols
\verb/$q0/ and \verb/$r1/ are created and corresponding mappings are
added to the local environment.  At this point, we have:
\begin{code}
float $r0 = 1.61803399;
[make_golden => ..., r => $r0]
int main () {
  float $q0 = 3, $r1 = 2;
  [r => $r1, q => $q0, make_golden => ..., r => $r0]
  make_golden(q, r, a, {q -= a; r += a;});
}
\end{code}
The expanded output is represented in this section as
pseudo-syntax that is like the input language of ZL with some
additional annotations.  Variables starting with \verb/$/ represent bound
symbols.  The \verb/[...]/ list represents the current environment
in which new binding forms are added to the front of the list.

Now, |make_golden| is expanded and, in the body of |main|, we have:
\begin{code}
  ...
  [r => $r1, q => $q0, make_golden => ..., r => $r0]
  for (;;) { float a'0 = q, b'0 = r;
             float a = (a'0 - r'0*b'0)/(1 + r'0);
             if (fabs(a/(a'0+b'0)) > 0.01) 
               {q -= a; r += a;} 
             else break; }
  '0 => [r => $r0]
\end{code}
where |'0| represents a mark and |'0 => [...]| is the environment for
the mark.  Notice how marks keep the duplicate |a| and |r|'s in
the expanded output distinct.

Now, the statement ``{\tt |float| |a'0 = q,| |b'0 = r|}'' is compiled.
Compiling the first part creates a unique symbol \verb/$a0/ and the
mapping \verb/a'0 => $a0/ is added to the new environment inside the
|for| loop.  \fixme{Maybe add back something like: Notice how the the
  mark produces a new, unique name.}  The variable |q| on the
right-hand-side resolves to the \verb/$q0/ symbol in the local
environment.  A similar process is performed for the second part.  We
now have:
\begin{code}
   ...
   for (;;) { float $a0 = $q0, $b0 = $r1;
              [b'0 => $b0, a'0 => $a0, r => $r1, 
               q => $q0, ...]
              float a = (a'0 - r'0*b'0)/(1 + r'0);
              ...}
   '0 => [r => $r0]
\end{code}

Next, the statement ``|float a = ...|'' is compiled.  A unique
symbol \verb/$a1/ is created for |a| and the associated mapping is
added to the local environment.  Then the right-hand-side expression must be
compiled.  The variables |a'0| and |b'0| resolve to \verb/$a0/ and
\verb/$b0/, respectively, since they are found in the local environment.
However, |r'0| is not found, so the mark |'0| is stripped, and |r|
is looked up in the environment for the |'0| mark and resolves to
\verb/$r0/. We now have:
\begin{code}
   ...
   for (;;) { ...
              float $a1 = ($a0 - $r0*$b0)/(1 + $r0);
              [a => $a1, b'0 => $b0, a'0 => $a0, 
               r => $r1, q => $q0, ...] 
              if (fabs(a/(a'0+b'0)) > 0.01) 
                {q -= a; r += a;} 
              else break; }
   '0 => [r => $r0]
\end{code}

Next, the |if| is compiled.  The marks keep the two |a| variables in
the expression |a/(a'0+b'0)| distinct, and everything correctly
resolves.  Thus, we finally have:

\begin{code}
float $r0 = 1.61803399;
int main() {
  float $q0 = 3, $r1 = 2;
  for (;;) { float $a0 = $q0, $b0 = $r1;
             float $a1 = ($a0 - $r0*$b0)/(1 + $r0);
             if (fabs($a1/($a0+$b0)) > 0.01) 
               {$q0 -= $a1; $r1 += $a1;} 
             else break; }
}
\end{code}

Hence, all symbols are correctly bound and hygiene is maintained.

\fixme{Consider changing {\tt '0 => [...]} to {\tt '0 := [...]}.}

\subsection{Multiple Marks}

The symbols in the expansion of |make_golden| only had a single mark
applied to them.  However, in some cases, such as when macros expand
to other macros, multiple marks are needed.
For example, multiple marks are needed in the expansion of |plus_10|
in Figure \ref{macro-macro}.  
\begin{figure}
\begin{codef}
macro mk_plus_n (NAME, N) {
  macro NAME (X) { ({int x = X; x + N;}); }
}

static const int x = 10;
mk_plus_n(plus_10, x);

int main() {
  int x = 20;
  return plus_10(x);
}
\end{codef}
\caption{Example code to show how hygiene is maintained when a macro
  expands to another macro.}
\label{macro-macro}
\end{figure}
In this figure, |mk_plus_n| expands to
\begin{code}
macro plus_10 (X'0) { ({int x'0 = X'0; x'0 + x;}); }
\end{code}
where the first mark |'0| is applied.  A second mark is then applied
in the expansion of |plus_10(x)| in |main|:
\begin{code}
{ ({int x'0'1 = x; x'0'1 + x'1;}) }
\end{code}
In particular, a second mark is added to |x'0|, making it |x'0'1|.
This symbol then resolves to the |x| local to the macro |plus_10|.  In
addition, |x'1| resolves to the global |x| constant\footnote{In pattern
based macros there is an implicit call to \texttt{new\_mark} at the point
where the macro was defined; hence, the \texttt{'1} mark captures the
environment where \texttt{mk\_plus\_10} (expanded from \texttt{mk\_plus\_n}) 
is defined, which includes the global
constant \texttt{x}.} and the unmarked |x| resolves to the |x| local to
|main|.  Thus, hygiene is maintained in spite of three different |x|'s
in the expansion.

\subsection{Structure Fields}

Normal hygiene rules will not have the desired effect when accessing
fields of a structure or class.  Instead of trying to look up a symbol
in the current environment, we are asking to look up a symbol within a
specialized subenvironment.

For example, the following code will not work with normal hygiene rules:
\begin{code}
macro sum(q) {q.x + q.y;}
struct S {int x; int y;}
int f() {
  struct S p;
  ...
  return sum(p);
}
\end{code}
The problem is that
|sum(p)| will not be able to access the fields of |p| since
it will expand to ``|p.x'0 + p.y'0|'' with marks on |x| and
|y|.  The solution is to use a special lookup rule for structure
fields.  The rule is that if the current symbol with its sets of
marks is not found in the structure, strip the outermost mark and try
again, and repeat the process until no more marks are left.  This
process is similar to the normal lookup rule except that the
subenvironment associated with the mark is ignored since it is
irrelevant.  In the above example, |p.x'0| in the expansion of
|sum(p)| will resolve to the structure field |x| in
|struct S|.

A similar strategy is used when accessing members inside a module or
user type (including classes).  For example, looking for |X::f'0()|
will also find |X::f()|.

\subsection{Importing Symbols from A Module}
\label{module-import}

The handling of marks when importing symbols of a module is tricky.
Importing a module in which the name is provided as a parameter should
not expose additional symbols that are not normally visible inside the
macro.  On the other hand, if a macro imports a module in which the
name is not a parameter its symbols should only visible to the macro
and not outside of the macro.  The following example illustrates which
imported symbols should be visible from where where:
\begin{code}
module X {int x = 1;}

module Y {int y = 2;}

macro foo(VAR,MOD) {
  module Z {int VAR = 3;
            int z = 4;}
  import X; import MOD; import Z;
  printf("%d %d %d\n", x, VAR, z);
  // Y::y is not visible
}

int main() {
  foo(v,Y);
  printf("%d %d %d\n", y, v); 
  // X::x and Z::z not visible
}
\end{code}

The context of the imported symbols is defined by the marks that are
stripped in order to find the module.  More specially, the stripped
marks are applied to every symbol imported.  In the above example when
|foo| imports the module |X| the macro's mark is stripped, this mark
is then applied to |X::x| making the imported symbol visible to the
macro but not the caller.  In contrast when the module |Y| (from the
pattern variable |MOD|) is imported in the expansion of |foo(v,Y)|,
no marks are applied to |y| thus is is visible to the caller but not
the macro.  Finally, when the module |Z| is imported in the macro no
additional marks are applied since the module was defined by the macro
and hence the module name already has a mark on it, and thus no marks
are stripped to resolve the modules symbol.  If additional marks were
applied when importing the |Z| module the symbol |v| (from the
pattern variable |VAR|) will not be visible outside the macro.

\section{Bending Hygiene}
\label{bending-hygiene}

\subsection{Exporting Marked Symbols}
\label{macro-export}

One common reason to bend hygiene is to make macro introduced symbols
visible outside the macro.  To archive this effect ZL provided a way to
\textit{export} symbols introduced by the macro.

As already mentioned in Section \ref{macro-export-intro}, 
ZL allows top-level symbols to be exported in pattern based
macro (and simple procedural macros) by using:
\begin{code}
macro foo() :(*) {/* body */}
\end{code}
Additionally, individual symbols can be exported.  For example, to
export the symbols, |x| and |y|:
\begin{code}
macro bar() :(x,y) {/* body */}
\end{code}

Exporting is handled using two primitives that can be used
directly by lower level procedural macros.

\paragraph{Exporting Specific Symbols.}

Exporting specific symbols is handled using the |macro_export|
primitive.  For example, the macro |bar| could be written as:
\begin{code}
Syntax * bar(Syntax * call, Syntax * parms) {
   Mark * mark = ...;
   Match * repl = match_f(NULL, syntax [NAME], call);
   return replace(syntax {
     __raw(macro_export NAME (symbol x) (symbol y));
     /* body */
   }, repl, mark);
}
make_macro bar;
\end{code}
(As |macro_export| is not a form that is commonly used ZL does not
provide support for it in the higher level syntax, hence the |__raw|
form is used, which switches the syntax to the lower level
s-expression form until the end of the current statement.)

The use of |macro_export| involves the use of a pattern variable NAME
that is used to get the context in which to export the symbols.
After expansion the |macro_export| line would become:
\begin{code}
__raw(macro_export' bar (symbol' x') (symbol' y')) 
\end{code}
where marks are applied to |x| and |y| and |bar| gets the context of
the call site (which for most cases is the empty context, i.e., no
marks).  The symbols |x'| and |y'| (with the marks) then get exported
to the context of |bar|, which in this case is the empty context.

\paragraph{Exporting Top-Level Symbols.} 

Exporting all top-level symbols with a specific mark is handled by
calling the |new_mark_f| function directly and a special form of the
|macro_export| primitive.

The full version of the |new_mark_f| function is:
\begin{code}
Mark * new_mark_f(EnvironSnapshot *, bool export_tl, 
                  Context * export_to, Context * also_allow);
\end{code}
If |export_tl| is true, than all top-level like symbols that
contain the newly created mark are exported to |export_to|, this
includes structure fields and module symbols.

If a macro is expanded inside a function than any symbols created in
the outermost scope of the expansion are not exported as the environment
inside a function is not a top-level one.  Since exporting these
symbols is often a desirable behavior, ZL provides a special form of
the |macro_export| primitive which is used as follows:
\begin{code}
__raw(macro_export NAME tl_this_mark)
\end{code}
This form will export all symbols in the same scope where the
directive was used.  Unlike with the |symbol| directive, any symbols
in an inner scope, are not exported.  For example, given
\begin{code}
__raw(macro_export NAME tl_this_mark)
int x;
{
  int y = 2;
  x = y;
}
\end{code}
the symbol |x| will be exported, but |y| will not.

For simplicity of the implementation, only marks created with
|export_tl| set to true can be used with the |tl_this_mark| directive,
in addition the context of |NAME| is ignored and the context of
|export_to| (when creating the mark) is used instead.

Putting it all together, the macro |foo()| could be written as:
\begin{code}
Syntax * foo(Syntax * call, Syntax * parms) {
  Match * repl = match_f(NULL, syntax [NAME], call);
  Mark * mark = new_mark_f(environ_snapshot(), true, 
                           get_context(repl->var(syntax NAME)), NULL);
  return replace(syntax {
    __raw(macro_export NAME tl_this_mark);
    /* body */
  }, repl, mark);
}
\end{code}
The |also_allow| allow paramter is most useful in the context of macro
expanding to other macros and is thus not used here.

\paragraph{Implementation.}

The exporting of symbols is handled by creating an alias to the
original symbol in the desired context when a marked symbol is
defined.  This way uses of the symbol inside the macro will
unconditionally bind to the symbol the macro defined, while also making the
symbol visible outside the macro.  

When a new symbol is introduced by importing a module the additional
marks are first applied as outlined in Section \ref{module-import}.
Then, after the marks are applied, the new symbol is considered for
exporting using the same criteria as if the symbol is defined normally
except that the |tl_this_mark| directive is never used.  This
directive is not used because it is unclear how it
should be handled as symbols imported from a module are
normally not considered to be in the same scope.

\subsection{Fluid Binding}
\label{fluid}

The other common case for wanting to bend hygiene is to make symbols
visible to the macro parameters.  For this ZL provides
|fluid_binding|, which allows a variable to take its meaning from the
use site of a macro rather than the macro's definition site, in a
similar fashion to |define-syntax-parameter| in Racket~\cite{plt-tr1,
  syn-parm}.

Section \ref{fluid-intro} of the tutorial gave one example of the need
for |fluid_binding|; another prime example is the special variable
|this| in classes.  Variables in ZL are lexically scoped. For example,
the code:
\begin{code}
int g(X *);
int f() {return g(this);}
int main() {X * this = ...; return f();}
\end{code}
will not compile because the |this| defined in |main| is not visible
in |f|, even though |f| is called inside |main|. However, if the
|this| variable was instead dynamically scoped, the |this| in |main|
would be visible to |f|.
 
Normal hygiene rules preserve lexical scope in a similar fashion, such that:
\begin{code}
int g(X *);
macro m() {g(this);}
int main() {X * this = ...; return m();}
\end{code}
will also not compile.  Attempts to make this work with |get_| and
|replace_context| will not compose well~\cite{syn-parm}.  What
is really needed is something akin to dynamic scoping in the hygiene
system.  That is, for |this| to be scoped based on where it is used
when expanded, rather than where it is written in the macro
definition.  This can be done by marking the |this| symbol as |fluid|
using |fluid_binding| at the top level and then using |fluid| when
defining the symbol in local scope.  For example:
\begin{code}
fluid_binding this;
int g(X *);
macro m() {g(this);}
int main() {X * fluid this = ...; return m();}
\end{code}
will work as expected.  That is, the |this| in |m| will bind to the
|this| in |main|. 

%% \subsection{Sharing Marks}

%% As marks are first class objects, there can be shared between macros,
%% are multiple explanations of the same macro.  In addition ZL allows
%% the separation of the mark used as part of the name and the mark used
%% for the context.

%% \FIXME{...}

\subsection{Replacing Context}
\label{replace_context}

When all other methods of bending hygiene fail, ZL provides the analog
to |datum->syntax-object| in the |syntax-case|
expander~\cite{syntax-case} in the form of two functions:
|get_context| and |replace_context|, shown in Figure
\ref{visibility-api}, which changes the context (ie the set of marks)
associated with a symbol.

\begin{figure}
\begin{apil}
\item \kw{Type} |Context| with \kw{related functions}:
\begin{apill}
\item |Context * get_context(Syntax *)|
\item |Syntax * replace_context(UnmarkedSyntax *, Context *)|
\end{apill}
\end{apil}
\caption{Visibility API.}
\label{visibility-api}
\end{figure}
For example, a macro defining a class needs to
create a vtable that is accessible outside of the macro creating the
class.  The |get_context| function gets the context from some symbol,
generally some part of the syntax object passed in, while
|replace_context| replaces the context of the symbol with the one
provided.  For example, code to create a symbol |_vtable| that can be
used later might look something like:
\begin{code}
...
Match * m = match_f(0, raw_syntax (name ...), p);
Syntax * name = m->var(m, syntax name);
Context * context = get_context(name);
Syntax * _vtable = replace_context(syntax _vtable, context);
...
\end{code}
Here |name| is the name of the class that is passed in as |m|.  The
|name| symbol is extracted into a syntax object so that it can be used
for |get_context|.  The |replace_context| function is then used to put
the symbol |_vtable| in the same context as |name|.  Now |_vtable|
will have the same visibility as the |name| symbol, and thus be
visible outside the macro.

\subsection{Gensym}

ZL does not provide the equivalent to Lisp's gensym as it is simply
not needed.  In the rare case a truly unique symbol is needed a fresh
mark, with an empty context, can be used:
\begin{code}
Syntax * name = replace(syntax anon, NULL, new_empty_mark());
\end{code}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Procedural Macro Implementation and State Management}

In order to use procedural macros effectively, it is necessary to know
a little bit about how they are implemented.  This section gives
the details on how procedural macros are implemented, the use of macro
libraries, and how to share state between procedural macros.

\section{The Details}

The current ZL compiler does not contain an interpreter; thus
procedural macros are compiled and then dynamically linked into the
compiler when the macro is first used.  A simple dependency analysis
is done so that any components that the procedural macro depends on
(and are not already compiled and linked in) are also compiled at the
same time.

In addition, ZL determines the role of each function as for run-time or
compile-time only to avoid included macro related functions in the
executable.  A compile-time only function is any function that uses
part of a macro API, or one that depends on a function which does.

The dependency analysis that determines which code to include when a
procedural macro is first used is separate from the dependency
analysis used to determine a role.  Thus, it is possible for a
function to be used at both run-time and compile-time if the function
is used by both a normal (i.e., run-time) function and a compile-time
only function.  Such a function will be considered a run-time function
even though it is also used at compile time.

\section{Macro Libraries}

Since the compilation of a complicated procedural macro can take a
decent amount of time, ZL also provides a mechanism for precompiling
macros ahead of time via macro libraries.  A macro library is similar
to a normal library, except that the code is loaded while compiling the
program, instead of during the programs execution.

A macro library is a collection of code compiled with the |-C| option.
The compilation creates a shared library with the |-fct.so|
extension; for example, if the code for the library was contained in
the file |lib.zl|, the shared library will be called |lib-fct.so|.  The
macro library is then used by importing the same file (used to create
the library) using the |import_file| primitive.  Importing will:
1) parse enough of the macro library code to get the function
prototypes and related information; and 2) load the related shared
library.  A header file can also be provided (with an extension of
|.zlh|), which will be read in instead of the full macro code.

Normally, when |new_mark()| (which uses the |environ_snapshot()|
primitive) is used, the environmental snapshot is taken at the place in
the code where the syntax is used.  (Basically, |environ_snapshot()|
gets replaced with a pointer the the current environment as the
procedural macro is being parsed.)  Unfortunately, ZL does not have
the ability to serialize the environment, which means a snapshots can
only be taken for code that is compiled in the same translation unit
(also known as the compilation unit).  This creates a problem when a
procedural macro is compiled into a library.  To work around this
problem the user can declare that the environmental snapshot is taken
where the macro is declared, rather then where |environ_snapshot()| is
used, by adding |:w_snapshot| to |make_macro|, for example:
\begin{code}
make_syntax_macro foreach :w_snapshot
\end{code}
Since, unlike the function body, the |make_macro| declaration is
always read as the program is being compiled, this ensures that there
is always a point where the snapshot can be taken.  In the rare cases
when this strategy will not work, it is possible to store a snapshot of
an environment in a variable.  For example, if:
\begin{code}
EnvironSnapshot * prelude_envss = environ_snapshot();
\end{code}
is found in a header file, than ZL will ensure that the value of
global variable |prelude_envss| is a pointer to an environmental
snapshot in the current compilation unit.  Within the macro library,
this variable can then be used with an alternative form of |new_mark|,
which accepts a pointer to |EnvironSnapshot| as its first parameter.

When macro libraries are used no automatic dependency analysis is
done; everything included in the macro library is assumed to used at
compile-time only.  If it is necessary to use the same code at both
compile-time and run-time, special previsions need to be made, such as
moving the shared code into a separate file so that it can be linked
in at both compile and run time.  Linking compile-time only
functions into the executable will fail with undefined symbols.

\section{State Management}

Macros may maintain global state in one of two ways.  The first way is
to simply use global variables; any state stored within a global
variable will be accessible to any macros used in the same
compilation, even if they are compiled and linked in separately.  The
other way to maintain global state is to store the information inside
of a top-level symbol via the use of symbol properties, the details of
which are provided in the next section.

Using either method, state is only maintained during within the
compilation unit.  Separate provisions need to be made to store state
between compilations.

\section{Symbol Properties}
\label{symbol-prop}

Any top-level symbol can have any number of \textit{properties}
associated with it.  The value of the propriety is simply a syntax
object.  Symbol properties are used extensively by the class macro to
store information about the class which is then used by the parent
class and when expanding method definitions defined outside of the
class.

Figure \ref{symbol-prop-fig} shows the syntax for the |add_prop|
primitive used for adding symbol properties.  
\begin{figure}
Syntax to add properties to existing symbols:\\
\hspace*{1em}|(add_prop SYMBOL PROPERTY-NAME VALUE)|\\

Syntax to add properties within modules:\\
\hspace*{1em}|(add_prop PROPERTY-NAME VALUE)|\\

Macro API function to retrieve properties:\\
\hspace*{1em}\sverb/Syntax * get_symbol_prop(UnmarkedSyntax * symbol, UnmarkedSyntax * prop,/\\
\hspace*{1em}\sverb/                         const Environ *)/
\caption{Symbol properties syntax and API.}
\label{symbol-prop-fig}
\end{figure}
Note that |add_prop| is not an API function; it is part of the syntax
returned by the macro.  In addition, the |add_prop| primitive is
always used in the lower level s-expression form (i.e., created using
|raw_syntax| instead of |syntax|) in order to be able to precisely
control the syntax object being added.  Such control would not be
possible in the higher level syntax due to reparsing.

The three argument form of |add_prop| is used to add properties to
already existing top-level symbols.  For example the class macro adds
the propriety |is_method| to the macro representing methods by using:
\begin{code}
(add_prop (fun method (. @parms)) is_method true)
\end{code}
where |method| and |@parms| are pattern variables.  The two argument
form of |add_prop| is used within a module or user type to add
properties to the module.

To retrieve properties from a symbol the macro API function
|get_symbol_prop| can be used.  The function will return NULL if the
property does not exist for that symbol.

When used in combination with |stash_ptr| and |extract_ptr| arbitrary
objects can be stashed away for latter retrieval.  For example the
class macro uses this to store a pointer to the class used to
implement the class in the module for the class.  This pointer is then
extracted when expanding method definitions defined outside of the
class, thus greatly simplifying the implementation.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{ABI Related APIs}

This section gives additional procedural macro API components that are
important to creating classes and controlling the ABI.

\section{User Type and Module API}

Within the class macro it is necessary to get some basic properties on
data member types and the parent class.  In particular it is
necessary to determine if the type is a user type with any special
methods such as a default constructor or destructor.  The API for user
types and modules is shown in Figure \ref{module-api}.

\begin{figure}
\begin{apil}
\item \kw{Constructors}:
\begin{apill}
\item |UserType * user_type_info(Syntax *, const Environ *)|
\item |Constructor: Module * module_info(Syntax *, const Environ *)|
\end{apill}
\item \kw{Type} |UserType| with \kw{methods}:
\begin{apill}
\item|Module * module()|
\item|bool have_default_constructor()|
\item|bool have_copy_constructor()|
\item|bool have_assign()|
\item|bool have_destructor()|
\end{apill}
\item \kw{Type} |Module| with \kw{methods}:
\begin{apill}
\item |bool have_symbol(const Syntax *)|
\end{apill}
\end{apil}
\caption{User type and module API.}
\label{module-api}
\end{figure}

The constructors |user_type_info| and |module_info| get the
corresponding symbol from a symbol name.  From a |user_type| it is also
possible to get the underlying module using the |module| method.

The |have_*| user type methods are used to check if a
data-member type has any special methods.  The class macro uses this
information when building the corresponding special method.  For
example if any the data-members have the assign method is is necessary
to create an assign method for the class.

\section{User Type Builder}

Due to the need to get information about the user type as it is being
built, the class macro builds the user type directly and then returns
a syntax object with the compiled syntax object embedded directly.
The builder API is shown in Figure \ref{builder-api}.

\begin{figure}
\begin{apil}
\item \kw{Type} |UserTypeBuilder| with \kw{constructor}:
\begin{apill}
\item |UserTypeBuilder * new_user_type_builder(Syntax * name, Environ * env)|
\end{apill}
and \kw{methods}:
\begin{apill}
\item |void add(Syntax *)|
\item |Syntax * to_syntax()|
\item |bool have_default_constructor()|
\item |bool have_copy_constructor()|
\item |bool have_assign()|
\item |bool have_destructor()|
\end{apill}
and \kw{members} (read only):
\begin{apill}
\item |Environ * env|
\item |UserType * user_type|
\end{apill}
\end{apil}
\caption{User type builder API.}
\label{builder-api}
\end{figure}

A new builder is created using |new_user_type_builder|.  Components
are added using the |add| method.  Finally, the |to_syntax|
method is used to finalize the user type and return a syntax object
with the compiled user type embed within.

The |have_*| methods are used for querying the user type as it is
being built.  They are needed because, due to overloading, it is
difficult for the class macro to determine if a constructor or
assignment operator is provided that satisfies the requirements of a
copy constructor or copy assignment operator, restively.  Thus, after
all the methods are added to the user type, the class macro uses these
methods to check for the existence of the special methods and can act
appropriately.

The user type builder also exposes several read only members.  The
most important one is the local environment inside the module.  This
environment is needed when partly expanding class components, for
example, in the following code:
\begin{code}
typedef const char * iterator;
iterator begin();
\end{code}
the second line, will not expand correctly unless the |iterator| type
is in the environment.  
%Hence, the typedef is parsed and added to the
%module environment with the |add| method, then the |begin| method is
%partly expanded using the module environment, and finally after some tras

%%
%% FIXME?: Add bit about partly expanding classes.
%%

\section{The ABI Switch}
\label{abi-switch}

Since class layout is a key component to the ABI, a new ABI can be
created by extending (or overriding) the class macro and then
remapping the |class| syntax object to use the new macro.  Another way
to define a new ABI is to register the ABI so that it can be used with
the ABI switch.  The ABI switch is an extension of C++ |extern| with
an additional part for the ABI.  For example:
\begin{code}
extern "C++" : "gcc"
class C {...};
\end{code}
causes the class |C| to use the ``gcc'' ABI.  In addition to class
layout, the ABI switch also controls name managing and other key
components of the ABI, which can differ between compilers.

A class macro is registered with the ABI switch by compiling it 
into into a macro library and defining the symbols |_abi_list| and
|_abi_list_size|.  The |_abi_list| variable is an array of |AbiInfo| and
|_abi_list_size| is the array size.  The struct |AbInfo| is defined as:
\begin{code}
struct AbiInfo {
  const char * abi_name;
  MangleFun mangler;
  MacroLikeFun parse_class;
  const char * module_name;
  Module * module;
};
\end{code}
The |abi_name| member is the name of the ABI, and |parse_class| points
to the macro function defining the class.  The |mangler| member is
part of the mangler ABI and will be described the next section.

Class layout and mangling are two important parts of the ABI.
Another important part is the implementation of |new| and |delete|.
To support any ABI specific implementations a module name can be
provided.  Any symbols is this module will shadow any global symbols
when the ABI is in effect; thus ABI specific |new| and |delete| macros
can be defined.  In addition the ABI info is tied to a user type so a
class is always allocated and deleted with the class ABIs |new| and
|delete|.

For example the macro library implementing the ``gcc'' ABI has the
following lines:
\begin{code}
unsigned _abi_list_size = 1;
AbiInfo _abi_list[1] = {{"gcc", NULL, parse_class_gcc_abi, 
                         "gcc_abi_info", NULL}};
\end{code}
with the following lines in the header file:
\begin{code}
module gcc_abi_info {
  macro alloc(type, size) {...}
  macro free(type, ptr) {...}
}
\end{code}
where |alloc| and |free| are called by the |new| and |delete|
primitives, receptively.

The final member |module| is filled in by ZL when the macro library
is read in, by looking for a module with the name |module_name|.

\section{Mangler API}

The final aspect of the ABI that ZL can control is the mangling
scheme.  The API to implement the alternative manglers is part of ABI
switch implementation just described.  The function type |MangleFun|
is defined as:
\begin{code}
StringObj * (*MangleFun)(Symbol *)
\end{code}

The mangler takes a symbol and transforms it into a string of the form
of a pointer to |StringObj|.  The string object is expected to build
up a string using the |StringBuf| and then call the |freeze| method,
which returns a |StringObj|.  An overview of the |StringBuf| class is
given in Figure \ref{StringBuf}.

\begin{figure}
\begin{codef}
class StringBuf {
public:
    StringBuf();
    StringBuf(const char * s);
    StringBuf(const char * s, unsigned size);
    StringBuf(const StringBuf & other);
    StringBuf & operator= (const char * other);
    StringBuf & operator= (const StringBuf & other);
    StringBuf & append(char * start, char * stop);
    StringBuf & operator+= (const char * s);
    StringBuf & operator+= (const StringBuf & s);
    StringBuf & prepend(const char * str);
    int printf(const char * format, ...);
    size_t size() const;
    bool empty() const;
    char * data();
    StringObj * freeze();
    ...;
};
\end{codef}
\caption{Overview of the StringBuf class.}
\label{StringBuf}
\end{figure}

In order to transform the string the mangler needs access to a large
number of properties about the symbol.  The most important of these
properties is the parameter types for function symbols as they are the
primary components of the mangled name.  An overview of the API used
for getting symbol properties is given in Figure \ref{symbol-api}.

\begin{figure}
\begin{apil}
\item \kw{Type} |Symbol| with \kw{methods}:
\begin{apill}
\item |const char * name()|
\item |const char * uniq_name()|
\item |Type * type()|
\item |FunType * fun_type()|
\item |Syntax * prop(UnmarkedSyntax * prop)|
\end{apill}
\item \kw{Type} |Type| with \kw{methods}:
\begin{apill}
\item |Type * subtype()|
\item |int qualifiers()|
\item |bool is_scalar()|
\item |bool is_qualified()|
\item |bool is_pointer()|
\end{apill}
\item \kw{Constants}:
\begin{apill}
\item |TypeQualifier_CONST    = 1|
\item |TypeQualifier_VOLATILE = 2|
\item |TypeQualifier_RESTRICT = 4|
\end{apill}
\item \kw{Type} |FunType| with \kw{methods}:
\begin{apill}
\item |Type * ret_type()|
\item |unsigned num_parms(const FunType *)|
\item |Type * parm_type(unsigned num)|
\end{apill}
\end{apil}
\caption{Overview of the symbol API}
\label{symbol-api}
\end{figure}

Once the mangler function is defined it is necessary to register it
with ABI switch.  Different components of the ABI may be given in
different libraries, and any NULL fields will simply be left alone if there
where defined elsewhere for that ABI.  For example, the GCC mangler is
defined with the following line:

\begin{code}
unsigned _abi_list_size = 1;
AbiInfo _abi_list[1] = {{"gcc", to_external_name, NULL, NULL, NULL}};
\end{code}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \chapter{Misc}
%% \label{zl}

%% \section{Other Extensions}

%% \begin{code}
%% __raw(...)
%% \end{code}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Classes and User Types}
\label{class-user-type}

%\section{Details}

A user type (see \ref{user-types-intro}), which is ZL's minimal
notion of a class, consists of two parts: a type, generally a
|struct|, to hold the data for the class instance, and a
\textit{module}, which is collection of symbols for manipulating the
data.  

%% All symbols inside a module are considered to be top-level, even if
%% the module is defined inside a function or other local scope. Modules
%% are parsed using a simple two-pass strategic.  The first pass parses
%% everything except function bodies and initial values for variables.
%% The second pass parses them.  This strategy is avoided the need for
%% forward declarations of functions, while avoiding significantly
%% compacting the parsing process.  It is also the same strategy used for
%% parsing class bodies in C++.

As an example,
\begin{code}
class C { int i; 
          int f(int j) {return i + j;} };
\end{code}
expands to:
\begin{code}
user_type C {
  struct Data {int i;};
  associate_type struct Data;
  macro i (:this ths = this) {(*(C *)ths)..i;}
  macro f(j, :this ths = this) {f`internal(ths, j);}
  int f`internal(C * fluid this, int j) {return i + j;}
}
\end{code}
and creates the class |C|.

To allow user types to behave like classes, member-access
syntax gets special treatment.  For example, if |x| is an instance of
the user type above, |x.i| calls the |i| macro in the |C| module,
and it passes a pointer to |x| as the |this| keyword argument.
This protocol allows |x.i| to expand to something that accesses the |x|
field of the underlying struct, which can be done using the special
syntax |x..i|.  Thus, |i| effectively becomes a data member of |x|.
Methods can similarly be defined.  For example, |x.f(12)| calls
the |f| macro with one positional parameter and the |this| keyword
argument.

The default value for the |this| keyword argument is necessary to
support the implicit |this| variable when data members and methods are
accessed inside method definitions.  The function |f`internal|, which
implements the |f| method, demonstrates this.  (\label{inner}The |`internal| simply
specifies an alternative namespace for the |f| symbol so that it does
not conflict with the |f| macro.)  The first parameter of the function
is |this|, which puts the symbol into the local environment.  When |i|
is called inside the function body the |this| keyword argument is not
supplied, since we are not using the member access form.  Therefore,
the |this| keyword argument defaults to the |this| specified as the
default value, which binds to the |this| in the local environment.
The |fluid| keyword (see \ref{fluid}) is necessary to make the |this|
variable visible to the |i| macro; with normal hygiene rules, binding
forms at the call site of a macro are invisible, as symbols normally
bind to whatever is visible where the macro was defined.

User types can also be declared to have a subtype relationship.  The
declaration specifies a macro for performing both casts to and from
the subtype.  Subtypes are used to implement inheritance.  For example
the class:
\begin{code}
class D : public C { int j; };
\end{code}
expands to something like:
\begin{code}
user_type D {
  import C;
  struct Data {struct C::Data parent; int j;};
  associate_type struct Data;
  macro _up_cast (ths) {&(*ths)..parent;}
  macro _down_cast (other) {(D*)other;}
  make_subtype C _up_cast _down_cast;
  macro j (:this ths = this) {(*(D*)ths)..j;}
}
\end{code}

New symbols defined in a module are allowed to shadow imported
symbols, so the fact that there is also a |Data| in |C| does not
create a problem.  Also, note that there is no need to redefine the
data member and method macros imported from |C|, since the existing
ones will work just fine.  They work because the class macro makes sure
that the |ths| macro parameter is cast to the right type before anything 
is done with it.  For example, if |y| is an instance of the type |D|,
then |y.i| expands to |(*(C*)&y)..i|.  When ZL tries to cast |&y| to
|C*|, the |D::_up_cast| macro is called and the expression expands to
|((*&(*&y)..parent))..i|, which simplifies to |y..parent..i|.  Method
calls expand similarly, except that the cast is implicit when the
|ths| macro parameter is passed into the function.

If a class contains any virtual methods, then a vtable is also created.
The macro that implements the method then looks up the function in the
vtable instead of calling it directly.  For example, if |f| was a
virtual function in the class |C|, then the macro for |f| would look
something like:
\begin{code}
macro f(j, :this ths = this) {_vptr->f(ths, j);}
\end{code}
where |_vptr| is a hidden member of the class that contains a pointer
to the virtual table.  The vtable is also a class, so to implement
inheritance with virtual methods a child's vtable simply inherits the
vtable of the parent.  To override a method, the constructor for the
child's vtable simply assigns a new value to the entry for the method's
function pointer.



