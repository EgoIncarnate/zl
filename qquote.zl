Syntax * uint_to_syntax(unsigned i) {
  char buf[16];
  snprintf(buf, 16, "%u", i);
  UnmarkedSyntax * s = string_to_syntax(buf);
  return (Syntax *)s;
}

Syntax * parse_quasiquote(Syntax * qq, Environ * env) {
  Mark * outer_mark = new_mark(prelude_envss);
  Match * m = match_f(0, raw_syntax (pattern aqs), qq);
  printf("XXX: ");
  dump_syntax(qq);
  Syntax * aqs = m->var(syntax aqs);
  if (aqs->num_args() == 0) {
    return replace(syntax {replace(syntax_d pattern, repl, mark);}, m, outer_mark);
  } else {
    UnmarkedSyntax * res = syntax {
      replace_w_antiquotes(syntax_d $1, repl, mark, $2, $3);
    };
    return replace(res, match_local(m, qq, uint_to_syntax(aqs->num_args()), aqs, NULL), outer_mark);
  }
}

Syntax * parse_match(Syntax * in, Environ * env) {
  Mark * mark = new_mark(prelude_envss);
  Match * m = match_f(0, syntax (qq, with, :match_f match_f = match_f_), in, mark);
  Syntax * qq = m->var(syntax qq);
  Environ * lenv = temp_environ(env);
  pre_parse(replace(raw_syntax(kill_fluid (` quasiquote syntax)),
                    NULL, mark), lenv);
  qq = partly_expand(qq, ExpPos, lenv);
  // FIXME: make sure with have a quasiquote
  dump_syntax(qq);
  Syntax * pattern = qq->arg(0);
  dump_syntax(pattern);
  Syntax * aqs = qq->arg(1);
  SyntaxEnum * iter = aqs->args();
  SyntaxList * assign = new_syntax_list();
  Syntax * aq;
  unsigned idx = 0;
  while ((aq = iter->next())) {
    assign->append(replace(syntax {$1 = match_aq_var(m, $2);},
                           match_local(m, aq, uint_to_syntax(idx)),
                           mark));
    idx++;
  }
  UnmarkedSyntax * res = syntax {({
    Match * m = match_f(repl, syntax_d $1, with, NULL);
    $2;
    m;
  });};
  return replace(res, match_local(m, qq, assign, NULL), mark);  
}
