Syntax * parse_make_syntax_macro(Syntax * p, Environ * env) {
  Mark * mark = new_mark();
  Match * m = match_args(0, raw_syntax (name @ fun @rest), p);

  if (m->var(syntax fun))
    return replace(raw_syntax(make_macro (` name syntax) fun @rest), m, mark);
  else
    return replace(raw_syntax(make_macro (` name syntax) name @rest), m, mark);
}

Syntax * partly_expand_class(Syntax * p, Mark * mark, Environ * env) {
  Match * m = match(0, raw_syntax (what name @ body @rest), p);
  Syntax * body = m->var(syntax body);
  if (!body) return p;
  Environ * lenv = temp_environ(env);
  pre_parse(replace(raw_syntax (declare_user_type name), m, mark), lenv);
  SyntaxList * new_body = new_syntax_list();
  SyntaxEnum * itr = partly_expand_list(body->args(), FieldPos, lenv);
  Syntax * member;
  while ((member = itr->next))
    new_body->append(pre_parse(member, lenv));
  return replace(raw_syntax(what name ({...} @$1) @rest), 
                 match_local(m, new_body, NULL), mark);
}

include_file "class.zl";
