import_file "class-simple.zlh";

/* 
 * Example class definition 
 * (slightly out of date)
 *

  class Y : public X {
    struct D {
      ...
    };
    D d;
    virtual Y make_y();
    virtual D foo();
  }

  user_type Y {
    make_subtype X; // this must come first otherwise X may be redefined by import
    import X;
    struct D {
    };
    class _VTable;
    struct _Data {
      _VTable * _vptr;
      ...
    };
    finalize user_type _Data;
    class _VTable { / must come after _Data and finalize user_type;
      Y (*make_y)();
      D (*foo());
    }
    static _VTable _vtable;
    ...
    now come access macros and functions in the order they appear
    ...
    init() : static_constructor ...;
    map _vptr ...;
    void _constructor() ..;
  }
 */

typedef struct Collect {
  bool virtual_override;
  Syntax * this_type;
} Collect;

.class ConstructorCode {
public:
  Syntax * field;
  Syntax * name;
  Syntax * type;
  Syntax * code;
  ConstructorCode * next;
};

.class ParseClass {
public:
  Mark * mark;

  Match * m;

  Syntax * class_s;
  Environ * env;

  Syntax * name;
  Syntax * body;
  Syntax * parent_s;

  UserType * parent;

  Context * context;

  Environ * lenv;
  
  Module * parent_m;
  UserType * parent_vtable;
  Syntax * parent_vtable_n;
  Syntax * vtable;
  SyntaxList * struct_p;
  SyntaxList * struct_b;
  UserTypeBuilder * builder;
  //SyntaxList * module_p;
  //SyntaxList * module_b;
  SyntaxList * vtable_b;
  SyntaxList * vtable_i;
  SyntaxList * exports;
  SyntaxList * fields;

  SyntaxList * constructors;

  bool need_constructor;
  ConstructorCode * constructor_code;
  ConstructorCode * * constructor_code_ip;
  void add_constructor_field(Syntax * f, Syntax * nm, Syntax * t, Syntax * c) {
    ConstructorCode * n = new ConstructorCode;
    n->field = f;
    n->name = nm;
    n->type = t;
    n->code = c;
    n->next = NULL;
    *constructor_code_ip = n;
    constructor_code_ip = &n->next;
  }
  void add_constructor_code(Syntax * c) {
    add_constructor_field(NULL, NULL, NULL, c);
  }

  bool need_copy_constructor;
  SyntaxList * copy_constructor_code;

  bool need_assign;
  SyntaxList * assign_code;
  //Syntax * assign;

  bool need_destructor;
  SyntaxList * destructor_code;
  Syntax * destructor;
  Collect destructor_collect;

  virtual Syntax * parse(Syntax * p_, Environ * e_, Mark * m_) {

    class_s = p_;
    env = e_;
    mark = m_ ? m_ : new_mark(prelude_envss);
    
    init_match();
    
    if (!body) {
      //printf("DONE (declare only) %s\n", syntax_to_string(name));
      return replace(raw_syntax (<@ (declare_user_type name) (.type name)), m, mark);
    }

    init();

    builder->add(replace(
                   raw_syntax(add_prop ptr $1),
                   match_local(m, Syntax::stash_ptr(this), 0),
                   mark));
    builder->add(replace(
                   syntax {make_macro memberdecl`syntax parse_memberdecl;}, 
                   m, mark));
                 
    if (parent) {
      import_parent();
      init_parent_info();
      add_parent_info();
    }

    add_other_info();

    Syntax * err = parse_body();
    if (err) return err;

    parse_special_forward();

    if (!vtable_i->empty())
      create_vtable();

    builder->add(replace(
                   raw_syntax (.struct _Data @$1 @$2),
                   match_local(m, struct_p, struct_b, 0),
                   mark));
    builder->add(replace(
                   raw_syntax (finalize_user_type ((` _Data tag))),
                   m,
                   mark));
    builder->add(replace(
                   raw_syntax (add_prop fields (. @$1)),
                   match_local(m, fields, 0),
                   mark));

    //module_b->append(replace(
    //                   syntax {export $1;},
    //                   match_local(m, exports, 0),
    //                   mark));

    create_special();

    Syntax * res = builder->to_syntax();
    res = replace(raw_syntax(<@ $1 (.type name)), match_local(m, res, 0), mark);
    //printf("DONE %s\n", syntax_to_string(name));
    //dump_syntax(res);
    //printf("---\n");
    return res;
  }

  virtual void init_match() {
    m = match_args(0, raw_syntax (name @ body :(public parent_n) :(vtable_class (reparse vtable_class class))), class_s, mark);
    name = m->var(syntax name);
    if (strcmp(syntax_to_string(name), "") == 0) {
      name = replace(syntax anon, m, mark);
      m = match(m, syntax name, name);
    }
    body = m->var(syntax body);
  }

  virtual void init() {
    parent_s = m->var(syntax parent_n);
    parent = parent_s ? user_type_info(parent_s, env) : NULL;

    context = empty_context();

    //printf("parse_class %s %s\n", syntax_to_string(name));
    
    parent_m = NULL;
    parent_vtable = NULL;
    parent_vtable_n = NULL;
    vtable = NULL;
    struct_p = new_syntax_list();
    struct_b = new_syntax_list();
    //module_p = new_syntax_list();
    //module_b = new_syntax_list();
    builder = new_user_type_builder(name, env);
    builder->add(replace(raw_syntax (link_once), NULL, mark));
    //printf("USER TYPE BUILDER for %s = %p (%d)\n", syntax_to_string(name), builder);
    lenv = builder->env;
    vtable_b = new_syntax_list();
    vtable_i = new_syntax_list();
    exports  = new_syntax_list();
    fields = new_syntax_list();

    m = match(m, syntax _Data, replace_context(syntax _Data, context));
    m = match(m, syntax _parent, replace_context(syntax _parent, context));
    m = match(m, syntax _VTable, replace_context(syntax _VTable, context));
    m = match(m, syntax _vtable, replace_context(syntax _vtable, context));
    m = match(m, syntax _vptr, replace_context(syntax _vptr, context));
    m = match(m, syntax _set_vptr, replace_context(syntax _set_vptr, context));
    m = match(m, syntax _constructor, replace_context(syntax _constructor, context));
    m = match(m, syntax _destructor, replace_context(syntax _destructor, context));
    m = match(m, syntax _assign, replace_context(syntax _assign, context));
    m = match(m, syntax _vtable_init, replace_context(syntax _vtable_init, context));
    m = match(m, syntax _init, replace_context(syntax _init, context));
    m = match(m, syntax fields, replace_context(syntax fields, context));
    m = match(m, syntax this_type, replace_context(syntax this_type, context));
    m = match(m, syntax ptr, replace_context(syntax ptr, context));
    m = match(m, syntax is_method, replace_context(syntax is_method, context));
    m = match(m, syntax is_static, replace_context(syntax is_static, context));
    m = match(m, syntax memberdecl, replace_context(syntax memberdecl, context));
    
    init_special_funs();
  }

  virtual void add_other_info() {
  }

  virtual void init_parent_info() {
    parent_m = parent->module;
    parent_vtable_n = replace(syntax parent_n::_VTable, m, mark);
    parent_vtable = user_type_info(parent_vtable_n, env);
  }

  virtual void import_parent() {
    builder->add(replace(syntax {import parent_n;}, m, mark));

    //SyntaxEnum * itr = parent_m->symbols();
    //Syntax * syn;
    //while ((syn = itr->next())) {
    //  exports->append(syn);x
    //}
  }

  virtual void add_parent_info() {
    parse_class_var(partly_expand(replace(syntax {parent_n _parent;}, m, mark), FieldPos, lenv),
                    struct_p);
    register_field(m->var(syntax _parent), parent_s,
                   replace(raw_syntax (parent_n), m, mark));
    
    builder->add(replace(syntax {macro cast_up(p) {&(*p).._parent;}}, m, mark));
    builder->add(replace(syntax {macro cast_down(p) {reinterpret_cast<name *>(p);}}, m, mark));
    builder->add(replace(syntax {make_subtype parent_n cast_up cast_down;}, m, mark));
  }

  Syntax * parse_body() {
    SyntaxEnum * itr = partly_expand_list(match(NULL, raw_syntax ({...} @body), body)->varl(syntax body),
                                          FieldPos, lenv);
    Syntax * member;
    while ((member = itr->next)) {
      //printf("MEMBER: %s\n", syntax_to_string(member));
      Match * m0 = match(m, raw_syntax (what n @ type @_), member);
      if (!m0) {
        builder->add(member);
        continue;
      }

      const char * what = syntax_to_string(m0->var(syntax what));

      // ignore access control labels for now
      if (strcmp(what, "label")==0) continue;

      Syntax * err = NULL;
      if (strcmp(what, "var")==0) {
        parse_class_var(member, struct_b);
        register_field(m0->var(syntax n), NULL, m0->var(syntax type));
      } else if (strcmp(what, "alias")==0) {
        Match * m0 = match(m, raw_syntax (what n type value @_), member);
        //builder->add(replace(raw_syntax (macro n (:(this (reparse this this))) value), m0, mark));
        builder->add(replace(syntax {macro n (:this ths = this) {({__shadow typeof(ths) fluid this = ths; value;});}}, m0, mark));
        if (member->flag(syntax need_constructor))
          register_field(m0->var(syntax n), NULL, m0->var(syntax type));
      } else if (strcmp(what, "fun")==0) {
        err = parse_class_fun(member, NULL);      
      } else if (strcmp(what, "add_prop")==0) {
        builder->add(member);
      } else {
        builder->add(member);
      }
      if (err) return err;
      exports->append(m0->var(syntax n));
    }
    return NULL;
  }

  virtual void parse_special_forward() {
    // Parse special functions as forward declarations in order to build
    // necessary vptr and related info, for now only handle the _destructor

    Syntax * destrtr = NULL;

    if (destructor) {
      destrtr = destructor;
    } else if (need_destructor) {
      destrtr = partly_expand(replace(syntax{void * _destructor();}, m, mark), FieldPos, lenv);
    }
    if (destrtr)
      parse_class_fun(destrtr, &destructor_collect);
  }

  void create_vtable() {

    SyntaxList * flags = new_syntax_list();
    if (parent_vtable) // inherit parent vtable if one
      flags->append_flag(replace(raw_syntax(public $1), 
                                 match_local(m, parent_vtable_n, NULL), mark));
    if (m->var(syntax vtable_flag))
      flags->append_flag(m->var(syntax vtable_flag));
    
    // create new vtable class, 
    vtable = replace (raw_syntax(vtable_class _VTable @$1 ({...} $2)),
                      match_local(m, flags, vtable_b, 0),
                      mark);
    
    // create static vtable obj
    // create init function
    //   and add init code
    builder->add(vtable);
    //builder->add(replace(raw_syntax (vtable_class _VTable), m, mark));
    builder->add(replace(
                       syntax {static void _vtable_init(_VTable * _vt) {$1;} },
                       match_local(m, vtable_i, 0),
                       mark));
    exports->append(replace(syntax _vtable_init, m, mark));
    
    if (parent_vtable) {
      builder->add(replace(
                     syntax {static __static_constructor void _init() {/*printf("INIT %s %p%c", $1, &_vtable, 0x0A); */
                                                                       parent_n::_vtable_init(&_vtable); _vtable_init(&_vtable);}},
                     match_local(m, stringify(name), 0), 
                     mark));
    } else {
      builder->add(replace(
                     syntax {static __static_constructor void _init() {_vtable_init(&_vtable);}},
                     m, mark));
    }
    
    //printf("Adding _vptr\n");
    if (parent_vtable) {
      builder->add(replace(
                     syntax {macro _vptr (:this ths = this) 
                       {(_VTable *)(implicit_ptr_cast<parent_n>(ths)->_vptr);}},
                     m, mark));
    } else {
      Syntax * v = replace(raw_syntax (var (mid _vptr) (.ptr (mid _VTable))), m, mark);
      parse_class_var(v, struct_p); // Note: beginning of structure but end of module
      builder->add(replace(
                     syntax {macro _set_vptr (:this ths = this, other) 
                       {(*implicit_ptr_cast<name>(ths)).._vptr = other;}}, 
                     m, mark));
    }
    exports->append(replace(syntax _vptr, m, mark));
    Syntax * assign = replace(syntax (_set_vptr(&_vtable)), m, mark);
    need_constructor = true;
    add_constructor_code(assign);
    need_copy_constructor = true;
    copy_constructor_code->append(assign);
    
    exports->append(replace(syntax _VTable, m, mark));
    exports->append(replace(syntax _VTable`outer, m, mark));
    
    builder->add(replace(syntax {static _VTable _vtable;}, m, mark));
  }

  SyntaxList * get_constructor_code() {
    SyntaxList * code = new_syntax_list();
    for (ConstructorCode * cur = constructor_code; cur; cur = cur->next)
      if (cur->code) code->append(cur->code);
    return code;
  }

  .class InitCode {
    struct Data {
      Syntax * field;
      Syntax * code;
    } * data;
    unsigned size;
    void init(Syntax * syn) {
      if (syn) {
        size = syn->num_args();
        data = zl_malloc(sizeof(struct Data) * size);
        for (unsigned i = 0; i != size; ++i) {
          data[i].field = syn->arg(i)->part(0);
          data[i].code = syn->arg(i)->part(1);
        }
      } else {
        data = NULL;
        size = 0;
      }
    }
    Syntax * find(Syntax * syn) {
      for (unsigned i = 0; i != size; ++i) {
        if (data[i].field->eq(syn))
          return data[i].code;
      }
      return NULL;
    }
  };

  Syntax * prep_constructor(Syntax * constructor) {
    Match * m0 = match(m, raw_syntax (w n parms ret @ body @_), constructor);
    InitCode init_code;
    init_code.init(constructor->flag(syntax init));
    SyntaxList * code = new_syntax_list();
    for (ConstructorCode * cur = constructor_code; cur; cur = cur->next) {
      Syntax * c = cur->name ? init_code.find(cur->name) : NULL;
      if (c) {
        code->append(replace(raw_syntax(construct (kill_const (-> this $1))
                                        $2 . $3), 
                             match_local(m0, cur->field, cur->type, c, 0), mark));
      } else {
        if (cur->code) code->append(cur->code);
      }
    }
    if (m0->var(syntax body)) {
      constructor =
        replace(raw_syntax(w n parms ret (block $1 body)),
                match_local(m0, code, 0), mark);
    }
    return constructor;
  }

  virtual void create_special() {
    destructor_code->reverse();

    unsigned num_constructors = constructors->size();

    SyntaxEnum * itr = constructors->elements();
    Syntax * constructor;
    while ((constructor = itr->next())) {
      parse_class_fun(prep_constructor(constructor), NULL);
    }
    constructors = NULL;

    if (builder->have_copy_constructor())
      num_constructors--;

    if (num_constructors == 0 && need_constructor) {
      constructor = 
        partly_expand(
          replace(syntax{void _constructor() {$1;}}, 
                  match_local(m, get_constructor_code(), 0), mark), 
          FieldPos, lenv);
      parse_class_fun(constructor, NULL);
    }

    if (!builder->have_copy_constructor() && need_copy_constructor) {
      constructor = 
        partly_expand(
          replace(syntax{void _constructor(const name & other) {$1;}}, 
                  match_local(m, copy_constructor_code, 0), mark), 
          FieldPos, lenv);
      parse_class_fun(constructor, NULL);
    }

    if (!builder->have_assign() && need_assign && builder->can_have_assign()) {
      Syntax * assign = 
        partly_expand(
          replace(syntax{void _assign(const name & other) {$1;}}, 
                  match_local(m, assign_code, 0), mark), 
          FieldPos, lenv);
      // don't allow virtual assign for now
      parse_class_fun(assign, NULL);
    }

    if (destructor) {
      Match * m0 = match(m, raw_syntax ($w $n $parms $ret @ $body @rest), destructor);
      if (m0->var(syntax $body))
        destructor =
          replace(raw_syntax($w $n $parms (.ptr (void)) (block $body $1 (return this)) @rest), 
                  match_local(m0, destructor_code, 0), mark);
    } else if (need_destructor) {
      destructor =
        partly_expand(
          replace(syntax{void * _destructor() {$1; return this;}}, 
                  match_local(m, destructor_code, 0), mark), 
          FieldPos, lenv);
    }
    if (destructor)
      parse_class_fun_body(destructor, &destructor_collect, true);
  }

  virtual void parse_class_var(Syntax * p, SyntaxList * struct_b) {
    //printf("parse_class_var: %s\n", syntax_to_string(p));
    __shadow Match * m = match_args(m, raw_syntax (n t @rest), p);
    bool is_static = p->flag(syntax static);
    
    // FIXME: handle flags
    if (is_static) {
      builder->add(replace(raw_syntax(var (` (mid n) internal) (mid t) (mid @rest)), m, mark));
      builder->add(replace(syntax {macro n () {n`internal;}}, m, mark));
    } else {
      struct_b->append(replace(raw_syntax((mid t) (mid n)), m, mark));
      // FIXME: (name *)(this) may cast away const
      builder->add(replace(syntax {macro n (:this ths = this) {(*(name *)(ths))..n;}}, m, mark));
    }
  }

  virtual Syntax * parse_class_fun(Syntax * p, struct Collect * collect) {
    //printf("parse_class_fun: %s\n", syntax_to_string(p));
    __shadow Match * m = match_args(m, raw_syntax (n parms0 ret @ body :static @rest), p);
    m = match_args(m, raw_syntax (@parms), m->var(syntax parms0));
    //printf("STATIC? %d   VIRTUAL? %d\n", is_static, is_virtual);
    //assert(!(is_static && is_virtual)); // FIXME Error message

    Syntax * class_name = expand_id(m->var(syntax name), lenv);
    Syntax * name = expand_id(m->var(syntax n), lenv);
    //printf("<><>%s %s\n", syntax_to_string(class_name), syntax_to_string(name));
    if (name->eq(class_name)) {
      constructors->append
        (replace(raw_syntax(fun _constructor (. @parms) ret body @rest), m, mark));
      return NULL;
    } else if (name->eq(raw_syntax (operator =))) {
      //printf("ASSIGN\n");
      // just change the name, nothing special needs to be done
      m = match(m, syntax n, replace(syntax _assign, m, mark));
    } else if (!name->simple() && name->part(0)->eq(syntax ~) 
               && expand_id(name->part(1), lenv)->eq(class_name)) {
      //printf("DESTRUCTOR\n");
      // change the return type to "void *", the body will get fixed up later
      destructor = replace(raw_syntax(fun _destructor (. @parms) (.ptr void) body @rest), m, mark);
      return NULL;
    }

    // FIXME: handle flags
    bool is_static = p->flag(syntax static);
    bool is_virtual = p->flag(syntax virtual);

    m = create_vtable_entry_name(m);
    bool virtual_override = determine_virtual_override(m);
    if (!is_virtual && virtual_override) is_virtual = true;
    Syntax * ptr_self = determine_ptr_self(p);
    Syntax * this_type = is_static ? NULL : determine_this_type(p, m, ptr_self, virtual_override);
  
    SyntaxList * macro_parms = new_syntax_list();
    SyntaxList * typed_parms = new_syntax_list();
    SyntaxList * call_parms  = new_syntax_list();
  
    //if (!is_static) 
    //  call_parms->append(replace(syntax ((name  *)ths), m, mark));
    SyntaxEnum * parms_enum = m->varl(syntax parms);
    unsigned i = 0;
    Syntax * parm;
    while ((parm = parms_enum->next())) {
      Match * m0 = match(m, raw_syntax(type @ name :(default default)), parm);
      //printf("AND THE PARM IS %s w/ type %s\n", syntax_to_string(parm), syntax_to_string(m0->var(syntax type)));
      //printf("AND THE PARM IS %s\n", syntax_to_string(parm));
      Syntax * arg = m0 ? m0->var(syntax name) : NULL;
      bool now_optional = false;
      if (!arg) {
        char sbuf[8];
        snprintf(sbuf, 8, "arg%d", i);
        arg = replace(string_to_syntax(sbuf), 0, mark);
      }
      if (m0) {
        if (m0->var(syntax default)) {
          //printf("W/DEFAULT MAN\n");
          macro_parms->append(replace(raw_syntax(reparse name default), m0, mark));
          if (!now_optional)
            typed_parms->append(replace(syntax @, NULL, mark));
          now_optional = true;
        } else {
          macro_parms->append(replace(raw_syntax(reparse $1), match_local(m0, arg, NULL), mark));
        }
        typed_parms->append(parm);
        call_parms->append(arg);
      } else if (parm->eq(syntax ...)) {
        macro_parms->append(replace(raw_syntax (reparse @varargs), NULL, mark));
        typed_parms->append(parm);
        call_parms->append(replace(syntax varargs, NULL, mark));
      }
      ++i;
    }
    if (!is_static)
      macro_parms->append_flag(replace(raw_syntax(this (reparse ths this)), m, mark));
    SyntaxList * new_parms = mk_method_parms(this_type, m->varl(syntax parms));
    
    if (!collect && m->var(syntax body)) {
      builder->add(mk_method_defn(m, ptr_self, true, virtual_override, 
                                  this_type, m->varl(syntax parms)));
    } else {
      builder->add(replace(raw_syntax (fun (` (mid n) internal) (.(mid $1)) (mid ret)),
                           match_local(m, new_parms, 0), mark));
      if (collect) {
        collect->virtual_override = virtual_override;
        collect->this_type = this_type;
      }
    }
    
    Syntax * call_nv = mk_call(replace(syntax n`internal, m, mark),
                               !is_static ? replace(syntax ths, m, mark) : NULL, 
                               call_parms);
    //printf("TP: %s\n", syntax_to_string(typed_parms));
    //builder->add(replace(syntax {macro n`non_virtual ($1) :typed_parms($2) {$3;}},
    //                     match_local(m, macro_parms, typed_parms, call_nv, 0), mark));
    builder->add(replace(raw_syntax (macro (` n non_virtual) (@$1) :(typed-parms (. @$2)) $3),
                         match_local(m, macro_parms, typed_parms, call_nv, 0), mark));
    
    if (is_virtual) {
      //m = match(m, syntax fpn, m->var(syntax n));
      if (virtual_override) {
        // don't define a new method but bring the parent method into
        // the same scope
        builder->add(replace(
                       raw_syntax (bring_to_this_scope (:: parent_n n)),
                       m, mark));
      } else {
        Syntax * call_v = mk_call(replace(raw_syntax (-> (-> this _vptr) fpn), m, mark),
                                  replace(syntax this, m, mark),
                                  call_parms);
        builder->add(replace(
                       //syntax {macro n ($1) :typed_parms($2) {({__shadow name * fluid this = ths; $3;});}},
                       raw_syntax (macro n (@$1) :(typed-parms (. @$2)) 
                                  (eblock (:shadow var (fluid this) $3 ths) $4)),
                       match_local(m, macro_parms, typed_parms, ptr_self, call_v, 0),
                       mark));
        m = match(m, syntax pfun, 
                  replace(raw_syntax (.ptr (.fun (.(mid $1)) (mid ret))), match_local(m, new_parms, 0), mark));
        vtable_b->append(replace(raw_syntax (var (mid fpn) (mid pfun)), m, mark));
        vtable_b->append(replace(raw_syntax (add_prop fpn this_type $1), 
                                 match_local(m, this_type, 0), mark));
      }
      if (p->flag(syntax pure_virtual)) {
        vtable_i->append(replace(raw_syntax (assign (-> _vt fpn) 0), m, mark));
      } else {
        vtable_i->append(replace(raw_syntax (assign (-> _vt fpn) (` n internal)), m, mark));
        //vtable_i->append(replace(syntax {printf("%p%c", _vt->fpn, 0xA);}, m, mark));
      }
    } else {
      //printf("OK HERE WE GO: %s %s\n", 
      //       syntax_to_string(macro_parms),
      //       syntax_to_string(typed_parms));
      builder->add(replace(raw_syntax (macro n (@$1) :(typed-parms (. @$2)) $3),
                           //syntax {macro n ($1) :typed_parms($2) {$3;}},
                           match_local(m, macro_parms, typed_parms, call_nv, 0), mark));
    }
    builder->add(replace(raw_syntax (add_prop (fun n (. @parms)) is_method true), m, mark));
    if (is_static)
      builder->add(replace(raw_syntax (add_prop (fun n (. @parms)) is_static true), m, mark));

    //printf("DONE %s\n", syntax_to_string(m->var(syntax n)));
    return NULL;
  }

  Match * create_vtable_entry_name(Match * m) {
    // create unique name vtable entry, needs to different so that we
    // don't confuse vtable entries for special functions such as
    // _destructor with the real function
    char sbuf[1024];
    snprintf(sbuf, 1024, "%s%s$fp", 
             mangle_name(m->var(syntax n), env),
             mangle_fun_parms(m->var(syntax parms0), lenv));
    return match(m, syntax fpn,
                 replace_context(string_to_syntax(sbuf), get_context(m->var(syntax n))));
  }

  bool determine_virtual_override(Match * m) {
    return parent_vtable && parent_vtable->module->have_symbol(m->var(syntax fpn));
  }

  Syntax * determine_ptr_self(Syntax * p) {
    if (p && p->flag(syntax const_method))
      return replace(raw_syntax(.ptr (name :const)), m, mark);
    else
      return replace(raw_syntax(.ptr (name)), m, mark);
  }

  Syntax * determine_this_type(Syntax * p, Match * m, Syntax * ptr_self, bool virtual_override) {
    if (virtual_override) {
      return get_symbol_prop(replace(raw_syntax(:: (:: parent_n _VTable) fpn), m, mark),
                             syntax this_type,
                             env);
      //replace(raw_syntax(.tprop (.type (.tprop (-> (reinterpret_cast 
      //                                                (.ptr ((:: parent_n _VTable))) 0) fpn) 
      //                                    inner)) (parm 0)), m, mark);
    } else {
      return ptr_self;
    }
  }

  virtual Syntax * mk_call(Syntax * fun, Syntax * ths, SyntaxList * parms) {
    if (ths)
      return replace(raw_syntax (call $1 (. $2 $3)), 
                     match_local(NULL, fun, ths, parms, NULL), mark);
    else
      return replace(raw_syntax (call $1 (. $2)), 
                     match_local(NULL, fun, parms, NULL), mark);
  }

  virtual SyntaxList * mk_method_parms(Syntax * this_type, SyntaxEnum * parms) {
    SyntaxList * new_parms = new_syntax_list();
    if (this_type) 
      new_parms->append(replace(raw_syntax($1 (fluid this)), 
                                match_local(NULL, this_type, NULL), mark));
    new_parms->append_all(parms);
    return new_parms;
  }

  // ok the body part is a bit of a lie...
  virtual Syntax * parse_class_fun_body(Syntax * p, Collect * collect, bool inline_) {
    //printf("parse_class_fun: %s\n", syntax_to_string(p));
    __shadow Match * m = match_args(m, raw_syntax (n parms ret @ body @rest), p);
    m = match_args(m, raw_syntax (@parms), m->var(syntax parms));
    
    // FIXME: handle flags

    if (m->var(syntax body)) {
      builder->add(mk_method_defn(m, determine_ptr_self(p), inline_, collect->virtual_override, 
                                  collect->this_type, m->varl(syntax parms)));
    } else {
      SyntaxList * new_parms = mk_method_parms(collect->this_type, m->varl(syntax parms));
      builder->add(replace(raw_syntax (fun (` (mid n) internal) (.(mid $1)) (mid ret)),
                           match_local(m, new_parms, 0), mark));
    }
    
    return NULL;
  }

  Syntax * mk_method_defn(Match * m, Syntax * ptr_self, 
                          bool inline_, bool virtual_override, 
                          Syntax * this_type, SyntaxEnum * parms) {
    SyntaxList * new_parms = mk_method_parms(this_type, parms);
    Syntax * body;
    if (virtual_override) {
      body = 
        replace(raw_syntax(block (var :__shadow (fluid this) $1 (cast (.ptr (:const name)) this)) 
                             body), match_local(m, ptr_self, 0), mark);
    } else {
      body = m->var(syntax body);
    }
    body = mk_method_body(this_type, body);
    if (inline_)
      return replace(raw_syntax (:inline 
                                 fun (` (mid n) internal) (.(mid $1)) (mid ret) (mid $2)),
                     match_local(m, new_parms, body, 0), mark);
    else
      return replace(raw_syntax (fun (` (mid n) internal) (.(mid $1)) (mid ret) (mid $2)),
                     match_local(m, new_parms, body, 0), mark);
  }

  virtual Syntax * mk_method_body(Syntax * this_type, Syntax * body) {
    return body;
  }

  virtual void init_special_funs() {
    constructors = new_syntax_list();

    need_constructor = false;
    constructor_code = NULL;
    constructor_code_ip = &constructor_code;
    
    need_copy_constructor = false;
    copy_constructor_code = new_syntax_list();
    
    need_assign = false;
    assign_code = new_syntax_list();
    //assign = NULL;
    
    need_destructor = false;
    destructor_code = new_syntax_list();
    destructor = NULL;
    destructor_collect.virtual_override = false;
    destructor_collect.this_type = NULL;
  }
  
  // FIXME: Rename
  virtual void register_field(Syntax * name, Syntax * user_name, Syntax * type) {
    if (!user_name) user_name = name;
    Match * m0 = match(m, syntax n, name);
    const UserType * ut = user_type_info(type, lenv);

    fields->append(name);
    
    if (ut && ut->have_default_constructor()) {
      need_constructor = true;
      add_constructor_field(name, user_name, type, 
        replace(raw_syntax(member (kill_const (mid n)) (call _constructor (.))), m0, mark));
    } else {
      add_constructor_field(name, user_name, type, NULL);
    }
    
    if (ut && ut->have_copy_constructor())
      need_copy_constructor = true;
    copy_constructor_code->append(
      replace(raw_syntax(init-assign (kill_const (mid n)) (member other (mid n))), 
              m0, mark));
    
    if (ut && ut->have_assign())
      need_assign = true;
    assign_code->append(
      replace(raw_syntax(assign (mid n) (member other (mid n))), 
              m0, mark));
    
    if (ut && ut->have_destructor()) {
      need_destructor = true;
      destructor_code->append(
        replace(raw_syntax(member (kill_const (mid n)) (call (` _destructor non_virtual) (.))), m0, mark));
    }
  }

  virtual Syntax * parse_class_fun_defn(Syntax * p) {
    //printf("parse_class_fun: %s\n", syntax_to_string(p));
    __shadow Match * m = match_args(m, raw_syntax (n parms0 ret @ body :static @rest), p);
    m = match_args(m, raw_syntax (@parms), m->var(syntax parms0));

    Syntax * class_name = m->var(syntax name);
    Syntax * name = m->var(syntax n);

    //printf("ABC>%s\n", syntax_to_string(name));
    if (name->eq(class_name)) { // constructor
      Syntax * c = replace(raw_syntax(fun _constructor (. @parms) ret body @rest), m, mark);
      c = prep_constructor(c);
      return parse_class_fun_defn(c);
    } else if (name->eq(raw_syntax (operator =))) { // assign
      // just change the name, nothing special needs to be done
      //printf("OK GOT ASSIGN\n");
      m = match(m, syntax n, replace(syntax _assign, m, mark));
    } else if (!name->simple() && name->part(0)->eq(syntax ~) && name->part(1)->eq(class_name)) { // destructor
      m = match(m, syntax n, replace(syntax _destructor, m, mark));
      m = match(m, syntax ret, replace(raw_syntax(.ptr void), m, mark));
      m = match(m, syntax body, replace(raw_syntax(block body $1 (return this)), match_local(m, destructor_code, 0), mark));
      return mk_method_defn(m, determine_ptr_self(NULL), false, destructor_collect.virtual_override, 
                            destructor_collect.this_type, m->varl(syntax parms));
    }

    // FIXME: handle flags
    bool is_static = p->flag(syntax static);

    if (get_symbol_prop(replace(raw_syntax(fun (:: name n) parms0), m, mark), syntax is_static, env))
      is_static = true;

    m = create_vtable_entry_name(m);
    bool virtual_override = determine_virtual_override(m);
    Syntax * ptr_self = determine_ptr_self(p);
    Syntax * this_type = is_static ? NULL : determine_this_type(p, m, ptr_self, virtual_override);

    SyntaxList * new_parms = mk_method_parms(this_type, m->varl(syntax parms));
    
    return mk_method_defn(m, ptr_self, false, virtual_override, 
                          this_type, m->varl(syntax parms));
  }
};

Syntax * parse_class(Syntax * p, Environ * env) {
  ParseClass * pc = new ParseClass;
  return pc->parse(p, env, NULL);
}

Syntax * parse_memberdecl(Syntax * p, Environ * env) {
  Match * m = match_args(NULL, raw_syntax (name defn), p);
  Syntax * defn = m->var(syntax defn);
  defn = partly_expand(defn, OtherPos, env);
  Syntax * ptr_syn = get_symbol_prop(m->var(syntax name), syntax ptr, env);
  void * ptr = ptr_syn->extract_ptr();
  ParseClass * pc = (ParseClass *)ptr;
  if (defn->part(0)->eq(syntax fun)) {
    Syntax * res = pc->parse_class_fun_defn(m->var(syntax defn));
    return res;
  } else if (defn->part(0)->eq(syntax var)) {
    m = match_args(m, raw_syntax(n @rest), defn);
    return replace(raw_syntax(var (` n internal) @rest), m, pc->mark);
  } else {
    return defn;
  }
}


