
//
// libc stuff
//

typedef unsigned size_t;
//typedef struct _IO_FILE FILE;
extern "C" int printf (const char *, ...);
extern "C" int snprintf(char * str, size_t size, const char * format, ...);
macro NULL() {0;}
extern "C" void * malloc(size_t);
extern "C" void free(void *);
extern "C" int strcmp(const char *s1, const char *s2);
macro offsetof(TYPE, MEMBER) {(size_t) &(reinterpret_cast<TYPE *>(0))->MEMBER;}
extern "C" void *memcpy(void *dest, const void *src, size_t n);
extern "C" void *memmove(void *dest, const void *src, size_t n);

// libc hacks
typedef long long int64_t;

// If compiling for compile time these will point to ct_malloc and
// ct_free, otherwise they will point to malloc and free.
extern "C" void * zl_malloc(size_t);
extern "C" void * zl_malloc_atomic(size_t);
extern "C" void zl_free(void *);

// Use these (or zl_ variants) when allocating memory in a macro so
// that the compilers garbage collector will know about it which is
// important if the memory contains pointers to other objects.
// ct_free is optional.
__ct_callback void * ct_malloc(size_t);
__ct_callback void * ct_malloc_atomic(size_t);
__ct_callback void ct_free(void *);

//
// language support
//

macro true() {1;}
macro false() {0;}

__raw(smacro .new (type @rest)
        (eblock 
          (var tmp (.ptr type) (alloc type (sizeof (.type type))))
          (construct (deref tmp) type  @rest)
          tmp));

__raw(smacro .delete (exp) (eblock 
         (var to_del (.typeof exp) exp)
         (if to_del
            (free (.typeof (deref to_del)) (destroy (deref to_del))))
         (cast (void) 0)));

__raw(smacro .delete2 (exp type method) (eblock 
         (var to_del type exp)
         (if to_del
             (call method (. :(this to_del))))
         (cast (void) 0)));

__raw(smacro default_alloc (type size) 
      (call zl_malloc (. size)));

__raw(smacro default_free (type ptr) 
      (call zl_free (. ptr)));

__raw(.struct .dummy (char whocares));


//
// Macro ABI
//

typedef struct EnvironSnapshot EnvironSnapshot;

typedef struct Mark Mark;
__ct_callback Mark * new_mark_f(EnvironSnapshot *);
macro new_mark(es = NULL) {new_mark_f(es ? (EnvironSnapshot *)es : (EnvironSnapshot *)environ_snapshot());}
macro new_empty_mark() {new_mark_f(0);}

struct UnmarkedSyntax;
user_type UnmarkedSyntax {
  associate_type struct UnmarkedSyntax;
}

user_type Syntax;
user_type SyntaxEnum;
__ct_callback bool syntax_simple(Syntax *);
__ct_callback Syntax * syntax_part(Syntax *, unsigned);
__ct_callback unsigned syntax_num_args(Syntax *);
__ct_callback Syntax * syntax_flag(Syntax *, UnmarkedSyntax *);
__ct_callback bool syntax_eq(Syntax *, UnmarkedSyntax *);
__ct_callback SyntaxEnum * syntax_args(Syntax *);
__ct_callback Syntax * stash_ptr_in_syntax(void *);
__ct_callback void * extract_ptr_from_syntax(Syntax *);
struct Syntax;
user_type Syntax {
  associate_type struct Syntax;
  macro _up_cast (x) {reinterpret_cast<UnmarkedSyntax *>(x);}
  macro _down_cast (x) {reinterpret_cast<Syntax *>(x);}
  make_subtype UnmarkedSyntax _up_cast _down_cast;
  //import UnmarkedSyntax;
  //export simple, flag, part;
  macro simple(:this this) {syntax_simple(this);}
  macro num_parts(:this this) {syntax_num_args(this) + 1;}
  macro num_args(:this this) {syntax_num_args(this);}
  macro part(num, :this this) {syntax_part(this, num);}
  macro arg(num, :this this) {syntax_part(this, num + 1);}
  macro args(:this this) {syntax_args(this);}
  macro flag(str, :this this) {syntax_flag(this, str);}
  macro eq(str, :this this) {syntax_eq(this, str);}
  macro ne(str, :this this) {!syntax_eq(this, str);}
  macro stash_ptr(ptr) {stash_ptr_in_syntax(ptr);}
  macro extract_ptr(:this this) {extract_ptr_from_syntax(this);}
}

user_type SyntaxList;
__ct_callback SyntaxList * new_syntax_list();
__ct_callback int syntax_list_empty(const SyntaxList *);
__ct_callback unsigned syntax_list_size(const SyntaxList *);
__ct_callback size_t syntax_list_append(SyntaxList *, Syntax *);
__ct_callback void syntax_list_append_flag(SyntaxList *, Syntax *);
__ct_callback void syntax_list_append_all(SyntaxList *, SyntaxEnum *);
__ct_callback void syntax_list_reverse(SyntaxList *);
__ct_callback void syntax_list_replace(SyntaxList *, size_t pos, Syntax * el);
struct SyntaxList;
user_type SyntaxList {
  associate_type struct SyntaxList;
  import Syntax;
  macro _up_cast (x) {reinterpret_cast<Syntax *>(x);}
  macro _down_cast (x) {reinterpret_cast<SyntaxList *>(x);}
  make_subtype Syntax _up_cast _down_cast;
  macro empty(:this this) {syntax_list_empty(this);}
  macro size(:this this) {syntax_list_size(this);}
  macro append(:this this, syn) {syntax_list_append(this, syn);}
  macro append_flag(:this this, syn) {syntax_list_append_flag(this, syn);}
  macro append_all(:this this, els) {syntax_list_append_all(this, els);}
  macro elements(:this this) {syntax_args(this);}
  macro reverse(:this this) {syntax_list_reverse(this);}
  macro replace(:this this, pos, el) {syntax_list_replace(this, pos, el);}
}

user_type SyntaxEnum;
__ct_callback Syntax * syntax_enum_next(SyntaxEnum *);
__ct_callback SyntaxEnum * syntax_enum_clone(const SyntaxEnum *);
struct SyntaxEnum;
user_type SyntaxEnum {
  associate_type struct SyntaxEnum;
  export next;
  macro next(:this this) {syntax_enum_next(this);}
  macro clone(:this this) {syntax_enum_clone(this);}
}

user_type Match;
__ct_callback Match * match_f(Match * m, UnmarkedSyntax * pattern, Syntax * with, Mark * mark);
macro match(m, pattern, with, mark = NULL) {match_f(m, pattern, with, mark);}
__ct_callback Match *match_args_f(Match *, UnmarkedSyntax * pattern, Syntax * with, Mark * mark);
macro match_args(m, pattern, with, mark = NULL) {match_args_f(m, pattern, with, mark);}
__ct_callback Match * match_local(Match *, ...);
__ct_callback Syntax * match_var(Match *, UnmarkedSyntax *);
__ct_callback SyntaxEnum * match_varl(Match *, UnmarkedSyntax *);
struct Match;
user_type Match {
  associate_type struct Match;
  export var, varl;
  macro var(str, :this this) {match_var(this, str);}
  macro varl(str, :this this) {match_varl(this, str);}
}

__ct_callback Syntax * replace(UnmarkedSyntax *, Match *, Mark *);

typedef struct Context Context;
__ct_callback Context * empty_context();
__ct_callback Context * get_context(Syntax *);
__ct_callback Syntax * replace_context(UnmarkedSyntax *, Context *);

typedef struct Environ Environ;

typedef enum  {NoPos = 0, OtherPos = 1, TopLevel = 2, FieldPos = 4, 
               StmtDeclPos = 8, StmtPos = 16, ExpPos = 32} Position;
__ct_callback Syntax * partly_expand(Syntax *, Position pos, Environ *);
__ct_callback SyntaxEnum * partly_expand_list(SyntaxEnum *, Position pos, Environ *);
__ct_callback Syntax * expand_id(Syntax *, Environ *);
__ct_callback Syntax * pre_parse(Syntax *, Environ *);
__ct_callback Syntax * reparse(Syntax *, const char *, Environ *);

__ct_callback UnmarkedSyntax * string_to_syntax(const char * str);
__ct_callback const char * syntax_to_string(UnmarkedSyntax *);
__ct_callback void dump_syntax(UnmarkedSyntax *);

user_type Symbol;
user_type Type;
user_type FunType;
user_type UserType;
user_type Module;

__ct_callback UserType * user_type_info(Syntax *, const Environ *);
__ct_callback Module * user_type_module(const UserType *);
__ct_callback Module * module_info(Syntax *, const Environ *);
__ct_callback SyntaxEnum * module_symbols(const Module *);
__ct_callback bool module_have_symbol(const Module *, const Syntax *);
__ct_callback bool user_type_have_default_constructor(const UserType *);
__ct_callback bool user_type_have_copy_constructor(const UserType *);
__ct_callback bool user_type_have_assign(const UserType *);
__ct_callback bool user_type_can_have_assign(const UserType *);
__ct_callback bool user_type_have_destructor(const UserType *);

__ct_callback unsigned symbol_num(const Symbol *);
__ct_callback Symbol * symbol_where(const Symbol *);
__ct_callback const char * symbol_name(const Symbol *);
__ct_callback const char * symbol_uniq_name(const Symbol *);
__ct_callback Type * symbol_to_type(const Symbol *);
__ct_callback FunType * symbol_to_fun_type(const Symbol *);
__ct_callback Syntax * symbol_get_prop(const Symbol *, UnmarkedSyntax * prop);
//__ct_callback Type * symbol_to_module(const Symbol *);
//__ct_callback Type * symbol_to_variable(const Symbol *);
struct Symbol;
user_type Symbol {
  associate_type struct Symbol;
  macro num(:this this) {symbol_num(this);}
  macro where(:this this) {symbol_where(this);}
  macro name(:this this) {symbol_name(this);}
  macro uniq_name(:this this) {symbol_uniq_name(this);}
  macro to_type(:this this) {symbol_to_type(this);}
  macro to_fun_type(:this this) {symbol_to_fun_type(this);}
  macro get_prop(:this this, prop) {symbol_get_prop(this, prop);}
}

static const int TypeQualifier_CONST    = 1;
static const int TypeQualifier_VOLATILE = 2;
static const int TypeQualifier_RESTRICT = 4;

__ct_callback Symbol * type_to_symbol(const Type *);

__ct_callback Type * type_root(const Type *);
__ct_callback Type * type_subtype(const Type *);
__ct_callback int type_qualifiers(const Type *);
__ct_callback const char * type_tag(const Type *);

__ct_callback const bool type_is_scalar(const Type *);
__ct_callback const bool type_is_qualified(const Type *);
__ct_callback const bool type_is_pointer(const Type *);
__ct_callback const bool type_is_reference(const Type *);
__ct_callback const bool type_is_array(const Type *);
__ct_callback const bool type_is_fun(const Type *);
__ct_callback const bool type_is_user(const Type *);

struct Type;
user_type Type {
  associate_type struct Type;
  import Symbol;
  macro _up_cast (x) {type_to_symbol(x);}
  macro _down_cast (x) {abort();}
  make_subtype Symbol _up_cast _down_cast;

  associate_type struct Type;
  macro root(:this this) {type_root(this);}
  macro subtype(:this this) {type_subtype(this);}
  macro qualifiers(:this this) {type_qualifiers(this);}
  macro tag(:this this) {type_tag(this);}
  macro is_scalar(:this this) {type_is_scalar(this);}
  macro is_qualified(:this this) {type_is_qualified(this);}
  macro is_pointer(:this this) {type_is_pointer(this);}
  macro is_reference(:this this) {type_is_reference(this);}
  macro is_array(:this this) {type_is_array(this);}
  macro is_fun(:this this) {type_is_fun(this);}
  macro is_user(:this this) {type_is_user(this);}
}


__ct_callback Type * fun_type_ret_type(const FunType *);
__ct_callback unsigned fun_type_num_parms(const FunType *);
__ct_callback Type * fun_type_parm_type(const FunType *, unsigned num);
struct FunType;
user_type FunType {
  associate_type struct FunType;
  import Type;
  macro _up_cast (x) {fun_type_to_type(x);}
  macro _down_cast (x) {abort();}
  make_subtype Type _up_cast _down_cast;

  macro ret_type(:this this) {fun_type_ret_type(this);}
  macro num_parms(:this this) {fun_type_num_parms(this);}
  macro parm_type(:this this, num) {fun_type_parm_type(this, num);}
}

struct UserType;
user_type UserType {
  associate_type struct UserType;
  export module;
  macro module(:this this) {user_type_module(this);}
  macro have_default_constructor(:this this) {user_type_have_default_constructor(this);}
  macro have_copy_constructor(:this this) {user_type_have_copy_constructor(this);}
  macro have_assign(:this this) {user_type_have_assign(this);}
  macro can_have_assign(:this this) {user_type_can_have_assign(this);}
  macro have_destructor(:this this) {user_type_have_destructor(this);}
}

struct Module;
user_type Module {
  associate_type struct Module; 
  export symbols, have_symbol;
  macro symbols(:this this) {module_symbols(this);}
  macro have_symbol(sym, :this this) {module_have_symbol(this, sym);}
}

user_type ModuleBuilder;
user_type UserTypeBuilder;
__ct_callback ModuleBuilder * new_module_builder(Syntax * name, Environ * env);
__ct_callback void module_builder_add(ModuleBuilder *, Syntax *);
__ct_callback Syntax * module_builder_to_syntax(ModuleBuilder *);
__ct_callback UserTypeBuilder * new_user_type_builder(Syntax * name, Environ * env);

struct ModuleBuilder {
  Module * module;
  UserType * user_type;
  Environ * env;
};
user_type ModuleBuilder {
  associate_type struct ModuleBuilder;
  macro module(:this this) {(*this)..module;}
  macro user_type(:this this) {(*this)..user_type;}
  macro env(:this this) {(*this)..env;}
  macro add(syn, :this this) {module_builder_add(this, syn);}
  macro to_syntax(:this this) {module_builder_to_syntax(this);}
}

user_type UserTypeBuilder {
  associate_type struct ModuleBuilder;
  import ModuleBuilder;
  macro _up_cast (x) {reinterpret_cast<ModuleBuilder *>(x);}
  macro _down_cast (x) {reinterpret_cast<UserTypeBuilder *>(x);}
  make_subtype ModuleBuilder _up_cast _down_cast;
  macro have_default_constructor(:this this) {this->user_type->have_default_constructor();}
  macro have_copy_constructor(:this this) {this->user_type->have_copy_constructor();}
  macro have_assign(:this this) {this->user_type->have_assign();}
  macro can_have_assign(:this this) {this->user_type->can_have_assign();}
  macro have_destructor(:this this) {this->user_type->have_destructor();}
}

__ct_callback Environ * temp_environ(const Environ *);
__ct_callback Environ * new_scope(const Environ *, Syntax * where);

__ct_callback size_t ct_value(Syntax *, const Environ *);

__ct_callback Syntax * error(Syntax *, const char *, ...);

__ct_callback Syntax * get_symbol_prop(UnmarkedSyntax * sym, UnmarkedSyntax * prop, const Environ * env);

__ct_callback int symbol_exists(UnmarkedSyntax * sym, Syntax * where, Mark *, const Environ *);


__ct_callback const char * mangle_name(Syntax *, Environ *);
__ct_callback const char * mangle_fun_parms(Syntax *, const Environ *);

__ct_callback void gdb_breakpoint();

__ct_callback Syntax * stringify(Syntax * p);

//
// make_syntax_macro
//

Syntax * parse_make_syntax_macro(Syntax * p, Environ * env);
make_macro make_syntax_macro`syntax parse_make_syntax_macro :w_snapshot;

//
// class support
//

Syntax * partly_expand_class(Syntax *, Mark *, Environ *);

__raw(smacro pseudo_member (VAR TYPE VAL) 
      (alias VAR TYPE VAL :need_constructor));

Syntax * parse_class(Syntax * p, Environ * env);
Syntax * parse_memberdecl(Syntax * p, Environ * env);
//make_syntax_macro class parse_class;
make_macro memberdecl`internal parse_memberdecl :w_snapshot; // HACK!
make_macro class`syntax parse_class :w_snapshot;

Syntax * parse_enum(Syntax * p, Environ * env);
make_macro stupid_hack_dont_use parse_enum;

//
// misc.
//

EnvironSnapshot * prelude_envss = environ_snapshot();


